{
	"profile_info": {
		"profile_id": "xccdf_org.ssgproject.content_profile_pci-dss",
		"description": "Ensures PCI-DSS v3.2.1 security configuration settings are applied.",
		"title": "PCI-DSS v3.2.1 Control Baseline for Red Hat Enterprise Linux 9"
	},
	"scan_result": {
		"title": "OSCAP Scan Result",
		"identity": "jrodak",
		"profile_id": "xccdf_org.ssgproject.content_profile_pci-dss",
		"target": "rhel90",
		"cpe_platforms": [
			"#chrony",
			"#grub2",
			"#yum",
			"#audit",
			"#sssd",
			"#pam",
			"#gdm",
			"cpe:/o:redhat:enterprise_linux:9",
			"#machine",
			"#non-uefi",
			"#libuser",
			"#login_defs"
		],
		"scanner": "OpenSCAP",
		"scanner_version": "1.3.6",
		"benchmark_url": "#scap_org.open-scap_comp_ssg-rhel9-xccdf-1.2.xml",
		"benchmark_id": "xccdf_org.ssgproject.content_benchmark_RHEL-9",
		"benchmark_version": "0.1.63",
		"start_time": "2022-10-26T09:45:20+01:00",
		"end_time": "2022-10-26T09:46:14+01:00",
		"test_system": "cpe:/a:redhat:openscap:1.3.6",
		"score": 41.266533,
		"score_max": 100.0
	},
	"rules": {
		"xccdf_org.ssgproject.content_rule_rpm_verify_hashes": {
			"rule_id": "xccdf_org.ssgproject.content_rule_rpm_verify_hashes",
			"title": "Verify File Hashes with RPM",
			"result": "pass",
			"time": "2022-10-26T09:46:00+01:00",
			"severity": "high",
			"identifiers": [
				"CCE-90841-8"
			],
			"references": [
				"11",
				"2",
				"3",
				"9",
				"5.10.4.1",
				"APO01.06",
				"BAI03.05",
				"BAI06.01",
				"BAI10.01",
				"BAI10.02",
				"BAI10.03",
				"BAI10.05",
				"DSS06.02",
				"3.3.8",
				"3.4.1",
				"CCI-000366",
				"CCI-001749",
				"164.308(a)(1)(ii)(D)",
				"164.312(b)",
				"164.312(c)(1)",
				"164.312(c)(2)",
				"164.312(e)(2)(i)",
				"4.3.4.3.2",
				"4.3.4.3.3",
				"4.3.4.4.4",
				"SR 3.1",
				"SR 3.3",
				"SR 3.4",
				"SR 3.8",
				"SR 7.6",
				"A.11.2.4",
				"A.12.1.2",
				"A.12.2.1",
				"A.12.5.1",
				"A.12.6.2",
				"A.14.1.2",
				"A.14.1.3",
				"A.14.2.2",
				"A.14.2.3",
				"A.14.2.4",
				"CM-6(d)",
				"CM-6(c)",
				"SI-7",
				"SI-7(1)",
				"SI-7(6)",
				"AU-9(3)",
				"PR.DS-6",
				"PR.DS-8",
				"PR.IP-1",
				"Req-11.5",
				"SRG-OS-000480-GPOS-00227"
			],
			"description": "Without cryptographic integrity protections, system\nexecutables and files can be altered by unauthorized users without\ndetection.\nThe RPM package management system can check the hashes of\ninstalled software packages, including many that are important to system\nsecurity.\nTo verify that the cryptographic hash of system files and commands matches vendor\nvalues, run the following command to list which files on the system\nhave hashes that differ from what is expected by the RPM database:\n<pre>$ rpm -Va --noconfig | grep &#x27;^..5&#x27;</pre>\nA &quot;c&quot; in the second column indicates that a file is a configuration file, which\nmay appropriately be expected to change. If the file was not expected to\nchange, investigate the cause of the change using audit logs or other means.\nThe package can then be reinstalled to restore the file.\nRun the following command to determine which package owns the file:\n<pre>$ rpm -qf <i>FILENAME</i></pre>\nThe package can be reinstalled from a dnf repository using the command:\n<pre>$ sudo dnf reinstall <i>PACKAGENAME</i></pre>\nAlternatively, the package can be reinstalled from trusted media using the command:\n<pre>$ sudo rpm -Uvh <i>PACKAGENAME</i></pre>",
			"rationale": "The hashes of important files like system executables should match the\ninformation given by the RPM database. Executables with erroneous hashes could\nbe a sign of nefarious activity on the system.",
			"oval_definition_id": "oval:ssg-rpm_verify_hashes:def:1",
			"remediations": [
				{
					"remediation_id": "rpm_verify_hashes",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "\n# Find which files have incorrect hash (not in /etc, because of the system related config files) and then get files names\nfiles_with_incorrect_hash=\"$(rpm -Va --noconfig | grep -E '^..5' | awk '{print $NF}' )\"\n\n# From files names get package names and change newline to space, because rpm writes each package to new line\npackages_to_reinstall=\"$(rpm -qf $files_with_incorrect_hash | tr '\\n' ' ')\"\n\ndnf reinstall -y $packages_to_reinstall\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_rpm_verify_permissions": {
			"rule_id": "xccdf_org.ssgproject.content_rule_rpm_verify_permissions",
			"title": "Verify and Correct File Permissions with RPM",
			"result": "pass",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "high",
			"identifiers": [
				"CCE-90840-0"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"18",
				"3",
				"5",
				"6",
				"9",
				"5.10.4.1",
				"APO01.06",
				"APO11.04",
				"BAI03.05",
				"BAI10.01",
				"BAI10.02",
				"BAI10.03",
				"BAI10.05",
				"DSS05.04",
				"DSS05.07",
				"DSS06.02",
				"MEA02.01",
				"3.3.8",
				"3.4.1",
				"CCI-001493",
				"CCI-001494",
				"CCI-001495",
				"CCI-001496",
				"164.308(a)(1)(ii)(D)",
				"164.312(b)",
				"164.312(c)(1)",
				"164.312(c)(2)",
				"164.312(e)(2)(i)",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.7.3",
				"4.3.4.3.2",
				"4.3.4.3.3",
				"4.3.4.4.7",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 2.1",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.8",
				"SR 2.9",
				"SR 5.2",
				"SR 7.6",
				"A.10.1.1",
				"A.11.1.4",
				"A.11.1.5",
				"A.11.2.1",
				"A.12.1.2",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.5.1",
				"A.12.6.2",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.1.3",
				"A.13.2.1",
				"A.13.2.3",
				"A.13.2.4",
				"A.14.1.2",
				"A.14.1.3",
				"A.14.2.2",
				"A.14.2.3",
				"A.14.2.4",
				"A.6.1.2",
				"A.7.1.1",
				"A.7.1.2",
				"A.7.3.1",
				"A.8.2.2",
				"A.8.2.3",
				"A.9.1.1",
				"A.9.1.2",
				"A.9.2.3",
				"A.9.4.1",
				"A.9.4.4",
				"A.9.4.5",
				"CIP-003-8 R4.2",
				"CIP-003-8 R6",
				"CIP-007-3 R4",
				"CIP-007-3 R4.1",
				"CIP-007-3 R4.2",
				"CM-6(d)",
				"CM-6(c)",
				"SI-7",
				"SI-7(1)",
				"SI-7(6)",
				"AU-9(3)",
				"CM-6(a)",
				"PR.AC-4",
				"PR.DS-5",
				"PR.IP-1",
				"PR.PT-1",
				"Req-11.5",
				"SRG-OS-000256-GPOS-00097",
				"SRG-OS-000257-GPOS-00098",
				"SRG-OS-000258-GPOS-00099",
				"SRG-OS-000278-GPOS-00108"
			],
			"description": "The RPM package management system can check file access permissions\nof installed software packages, including many that are important\nto system security.\nVerify that the file permissions of system files\nand commands match vendor values. Check the file permissions\nwith the following command:\n<pre>$ sudo rpm -Va | awk &#x27;{ if (substr($0,2,1)==&quot;M&quot;) print $NF }&#x27;</pre>\nOutput indicates files that do not match vendor defaults.\nAfter locating a file with incorrect permissions,\nrun the following command to determine which package owns it:\n<pre>$ rpm -qf <i>FILENAME</i></pre>\n<br>\nNext, run the following command to reset its permissions to\nthe correct values:\n<pre>$ sudo rpm --setperms <i>PACKAGENAME</i></pre>",
			"rationale": "Permissions on system binaries and configuration files that are too generous\ncould allow an unauthorized user to gain privileges that they should not have.\nThe permissions set by the vendor should be maintained. Any deviations from\nthis baseline should be investigated.",
			"warnings": [
				{
					"text": "Profiles may require that specific files have stricter file permissions than defined by the\nvendor.\nSuch files will be reported as a finding and need to be evaluated according to your policy\nand deployment environment.",
					"category": "general"
				}
			],
			"oval_definition_id": "oval:ssg-rpm_verify_permissions:def:1",
			"remediations": [
				{
					"remediation_id": "rpm_verify_permissions",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "high",
					"disruption": "medium",
					"strategy": "restrict",
					"fix": "\n# Declare array to hold set of RPM packages we need to correct permissions for\ndeclare -A SETPERMS_RPM_DICT\n\n# Create a list of files on the system having permissions different from what\n# is expected by the RPM database\nreadarray -t FILES_WITH_INCORRECT_PERMS < <(rpm -Va --nofiledigest | awk '{ if (substr($0,2,1)==\"M\") print $NF }')\n\nfor FILE_PATH in \"${FILES_WITH_INCORRECT_PERMS[@]}\"\ndo\n        # NOTE: some files maybe controlled by more then one package\n        readarray -t RPM_PACKAGES < <(rpm -qf \"${FILE_PATH}\")\n        for RPM_PACKAGE in \"${RPM_PACKAGES[@]}\"\n        do\n                # Use an associative array to store packages as it's keys, not having to care about duplicates.\n                SETPERMS_RPM_DICT[\"$RPM_PACKAGE\"]=1\n        done\ndone\n\n# For each of the RPM packages left in the list -- reset its permissions to the\n# correct values\nfor RPM_PACKAGE in \"${!SETPERMS_RPM_DICT[@]}\"\ndo\n\trpm --restore \"${RPM_PACKAGE}\"\ndone\n"
				},
				{
					"remediation_id": "rpm_verify_permissions",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "high",
					"disruption": "medium",
					"strategy": "restrict",
					"fix": "- name: Read list of files with incorrect permissions\n  command: rpm -Va --nodeps --nosignature --nofiledigest --nosize --nomtime --nordev\n    --nocaps --nolinkto --nouser --nogroup\n  args:\n    warn: false\n  register: files_with_incorrect_permissions\n  failed_when: files_with_incorrect_permissions.rc > 1\n  changed_when: false\n  check_mode: false\n  tags:\n  - CCE-90840-0\n  - CJIS-5.10.4.1\n  - NIST-800-171-3.3.8\n  - NIST-800-171-3.4.1\n  - NIST-800-53-AU-9(3)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-6(c)\n  - NIST-800-53-CM-6(d)\n  - NIST-800-53-SI-7\n  - NIST-800-53-SI-7(1)\n  - NIST-800-53-SI-7(6)\n  - PCI-DSS-Req-11.5\n  - high_complexity\n  - high_severity\n  - medium_disruption\n  - no_reboot_needed\n  - restrict_strategy\n  - rpm_verify_permissions\n\n- name: Create list of packages\n  command: rpm -qf \"{{ item }}\"\n  args:\n    warn: false\n  with_items: '{{ files_with_incorrect_permissions.stdout_lines | map(''regex_findall'',\n    ''^[.]+[M]+.* (\\/.*)'', ''\\1'') | map(''join'') | select(''match'', ''(\\/.*)'')\n    | list | unique }}'\n  register: list_of_packages\n  changed_when: false\n  check_mode: false\n  when: (files_with_incorrect_permissions.stdout_lines | length > 0)\n  tags:\n  - CCE-90840-0\n  - CJIS-5.10.4.1\n  - NIST-800-171-3.3.8\n  - NIST-800-171-3.4.1\n  - NIST-800-53-AU-9(3)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-6(c)\n  - NIST-800-53-CM-6(d)\n  - NIST-800-53-SI-7\n  - NIST-800-53-SI-7(1)\n  - NIST-800-53-SI-7(6)\n  - PCI-DSS-Req-11.5\n  - high_complexity\n  - high_severity\n  - medium_disruption\n  - no_reboot_needed\n  - restrict_strategy\n  - rpm_verify_permissions\n\n- name: Correct file permissions with RPM\n  command: rpm --setperms '{{ item }}'\n  args:\n    warn: false\n  with_items: '{{ list_of_packages.results | map(attribute=''stdout_lines'') | list\n    | unique }}'\n  when: (files_with_incorrect_permissions.stdout_lines | length > 0)\n  tags:\n  - CCE-90840-0\n  - CJIS-5.10.4.1\n  - NIST-800-171-3.3.8\n  - NIST-800-171-3.4.1\n  - NIST-800-53-AU-9(3)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-CM-6(c)\n  - NIST-800-53-CM-6(d)\n  - NIST-800-53-SI-7\n  - NIST-800-53-SI-7(1)\n  - NIST-800-53-SI-7(6)\n  - PCI-DSS-Req-11.5\n  - high_complexity\n  - high_severity\n  - medium_disruption\n  - no_reboot_needed\n  - restrict_strategy\n  - rpm_verify_permissions\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_package_aide_installed": {
			"rule_id": "xccdf_org.ssgproject.content_rule_package_aide_installed",
			"title": "Install AIDE",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-90843-4"
			],
			"references": [
				"BP28(R51)",
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"2",
				"3",
				"5",
				"7",
				"8",
				"9",
				"5.10.1.3",
				"APO01.06",
				"BAI01.06",
				"BAI02.01",
				"BAI03.05",
				"BAI06.01",
				"BAI10.01",
				"BAI10.02",
				"BAI10.03",
				"BAI10.05",
				"DSS01.03",
				"DSS03.05",
				"DSS04.07",
				"DSS05.02",
				"DSS05.03",
				"DSS05.05",
				"DSS05.07",
				"DSS06.02",
				"DSS06.06",
				"CCI-002696",
				"CCI-002699",
				"CCI-001744",
				"4.3.4.3.2",
				"4.3.4.3.3",
				"4.3.4.4.4",
				"SR 3.1",
				"SR 3.3",
				"SR 3.4",
				"SR 3.8",
				"SR 4.1",
				"SR 6.2",
				"SR 7.6",
				"1034",
				"1288",
				"1341",
				"1417",
				"A.11.2.4",
				"A.12.1.2",
				"A.12.2.1",
				"A.12.4.1",
				"A.12.5.1",
				"A.12.6.2",
				"A.14.1.2",
				"A.14.1.3",
				"A.14.2.2",
				"A.14.2.3",
				"A.14.2.4",
				"A.14.2.7",
				"A.15.2.1",
				"A.8.2.3",
				"CM-6(a)",
				"DE.CM-1",
				"DE.CM-7",
				"PR.DS-1",
				"PR.DS-6",
				"PR.DS-8",
				"PR.IP-1",
				"PR.IP-3",
				"Req-11.5",
				"SRG-OS-000363-GPOS-00150",
				"SRG-OS-000445-GPOS-00199"
			],
			"description": "The <code>aide</code> package can be installed with the following command:\n<pre>\n$ sudo dnf install aide</pre>",
			"rationale": "The AIDE package must be installed if it is to be available for integrity checking.",
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-package_aide_installed:def:1",
			"remediations": [
				{
					"remediation_id": "package_aide_installed",
					"system": "urn:redhat:osbuild:blueprint",
					"fix": "\n[[packages]]\nname = \"aide\"\nversion = \"*\"\n"
				},
				{
					"remediation_id": "package_aide_installed",
					"system": "urn:redhat:anaconda:pre",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "\npackage --add=aide\n"
				},
				{
					"remediation_id": "package_aide_installed",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nif ! rpm -q --quiet \"aide\" ; then\n    dnf install -y \"aide\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "package_aide_installed",
					"system": "urn:xccdf:fix:script:puppet",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "include install_aide\n\nclass install_aide {\n  package { 'aide':\n    ensure => 'installed',\n  }\n}\n"
				},
				{
					"remediation_id": "package_aide_installed",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "- name: Ensure aide is installed\n  package:\n    name: aide\n    state: present\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-90843-4\n  - CJIS-5.10.1.3\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-11.5\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_aide_installed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_aide_build_database": {
			"rule_id": "xccdf_org.ssgproject.content_rule_aide_build_database",
			"title": "Build and Test AIDE Database",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83438-2"
			],
			"references": [
				"BP28(R51)",
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"2",
				"3",
				"5",
				"7",
				"8",
				"9",
				"5.10.1.3",
				"APO01.06",
				"BAI01.06",
				"BAI02.01",
				"BAI03.05",
				"BAI06.01",
				"BAI10.01",
				"BAI10.02",
				"BAI10.03",
				"BAI10.05",
				"DSS01.03",
				"DSS03.05",
				"DSS04.07",
				"DSS05.02",
				"DSS05.03",
				"DSS05.05",
				"DSS05.07",
				"DSS06.02",
				"DSS06.06",
				"4.3.4.3.2",
				"4.3.4.3.3",
				"4.3.4.4.4",
				"SR 3.1",
				"SR 3.3",
				"SR 3.4",
				"SR 3.8",
				"SR 4.1",
				"SR 6.2",
				"SR 7.6",
				"A.11.2.4",
				"A.12.1.2",
				"A.12.2.1",
				"A.12.4.1",
				"A.12.5.1",
				"A.12.6.2",
				"A.14.1.2",
				"A.14.1.3",
				"A.14.2.2",
				"A.14.2.3",
				"A.14.2.4",
				"A.14.2.7",
				"A.15.2.1",
				"A.8.2.3",
				"CM-6(a)",
				"DE.CM-1",
				"DE.CM-7",
				"PR.DS-1",
				"PR.DS-6",
				"PR.DS-8",
				"PR.IP-1",
				"PR.IP-3",
				"Req-11.5"
			],
			"description": "Run the following command to generate a new database:\n\n<pre>$ sudo /usr/sbin/aide --init</pre>\n\nBy default, the database will be written to the file\n\n<code>/var/lib/aide/aide.db.new.gz</code>.\n\nStoring the database, the configuration file <code>/etc/aide.conf</code>, and the binary\n<code>/usr/sbin/aide</code>\n(or hashes of these files), in a secure location (such as on read-only media) provides additional assurance about their integrity.\nThe newly-generated database can be installed as follows:\n\n<pre>$ sudo cp /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz</pre>\n\nTo initiate a manual check, run the following command:\n<pre>$ sudo /usr/sbin/aide --check</pre>\nIf this check produces any unexpected output, investigate.",
			"rationale": "For AIDE to be effective, an initial database of &quot;known-good&quot; information about files\nmust be captured and it should be able to be verified against the installed files.",
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-aide_build_database:def:1",
			"remediations": [
				{
					"remediation_id": "aide_build_database",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nif ! rpm -q --quiet \"aide\" ; then\n    dnf install -y \"aide\"\nfi\n\n/usr/sbin/aide --init\n/bin/cp -p /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "aide_build_database",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Ensure AIDE is installed\n  package:\n    name: '{{ item }}'\n    state: present\n  with_items:\n  - aide\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-83438-2\n  - CJIS-5.10.1.3\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-11.5\n  - aide_build_database\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Build and Test AIDE Database\n  command: /usr/sbin/aide --init\n  changed_when: true\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-83438-2\n  - CJIS-5.10.1.3\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-11.5\n  - aide_build_database\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Check whether the stock AIDE Database exists\n  stat:\n    path: /var/lib/aide/aide.db.new.gz\n  register: aide_database_stat\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-83438-2\n  - CJIS-5.10.1.3\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-11.5\n  - aide_build_database\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Stage AIDE Database\n  copy:\n    src: /var/lib/aide/aide.db.new.gz\n    dest: /var/lib/aide/aide.db.gz\n    backup: true\n    remote_src: true\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - (aide_database_stat.stat.exists is defined and aide_database_stat.stat.exists)\n  tags:\n  - CCE-83438-2\n  - CJIS-5.10.1.3\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-11.5\n  - aide_build_database\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_aide_periodic_cron_checking": {
			"rule_id": "xccdf_org.ssgproject.content_rule_aide_periodic_cron_checking",
			"title": "Configure Periodic Execution of AIDE",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83437-4"
			],
			"references": [
				"BP28(R51)",
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"2",
				"3",
				"5",
				"7",
				"8",
				"9",
				"5.10.1.3",
				"APO01.06",
				"BAI01.06",
				"BAI02.01",
				"BAI03.05",
				"BAI06.01",
				"BAI10.01",
				"BAI10.02",
				"BAI10.03",
				"BAI10.05",
				"DSS01.03",
				"DSS03.05",
				"DSS04.07",
				"DSS05.02",
				"DSS05.03",
				"DSS05.05",
				"DSS05.07",
				"DSS06.02",
				"DSS06.06",
				"CCI-001744",
				"CCI-002699",
				"CCI-002702",
				"4.3.4.3.2",
				"4.3.4.3.3",
				"4.3.4.4.4",
				"SR 3.1",
				"SR 3.3",
				"SR 3.4",
				"SR 3.8",
				"SR 4.1",
				"SR 6.2",
				"SR 7.6",
				"A.11.2.4",
				"A.12.1.2",
				"A.12.2.1",
				"A.12.4.1",
				"A.12.5.1",
				"A.12.6.2",
				"A.14.1.2",
				"A.14.1.3",
				"A.14.2.2",
				"A.14.2.3",
				"A.14.2.4",
				"A.14.2.7",
				"A.15.2.1",
				"A.8.2.3",
				"SI-7",
				"SI-7(1)",
				"CM-6(a)",
				"DE.CM-1",
				"DE.CM-7",
				"PR.DS-1",
				"PR.DS-6",
				"PR.DS-8",
				"PR.IP-1",
				"PR.IP-3",
				"Req-11.5",
				"SRG-OS-000363-GPOS-00150",
				"SRG-OS-000446-GPOS-00200",
				"SRG-OS-000447-GPOS-00201"
			],
			"description": "At a minimum, AIDE should be configured to run a weekly scan.\nTo implement a daily execution of AIDE at 4:05am using cron, add the following line to <code>/etc/crontab</code>:\n<pre>05 4 * * * root /usr/sbin/aide --check</pre>\nTo implement a weekly execution of AIDE at 4:05am using cron, add the following line to <code>/etc/crontab</code>:\n<pre>05 4 * * 0 root /usr/sbin/aide --check</pre>\nAIDE can be executed periodically through other means; this is merely one example.\nThe usage of cron&#x27;s special time codes, such as  <code>@daily</code> and\n<code>@weekly</code> is acceptable.",
			"rationale": "By default, AIDE does not install itself for periodic execution. Periodically\nrunning AIDE is necessary to reveal unexpected changes in installed files.\n<br><br>\nUnauthorized changes to the baseline configuration could make the system vulnerable\nto various attacks or allow unauthorized access to the operating system. Changes to\noperating system configurations can have unintended side effects, some of which may\nbe relevant to security.\n<br><br>\nDetecting such changes and providing an automated response can help avoid unintended,\nnegative consequences that could ultimately affect the security state of the operating\nsystem. The operating system&#x27;s Information Management Officer (IMO)/Information System\nSecurity Officer (ISSO) and System Administrators (SAs) must be notified via email and/or\nmonitoring system trap when there is an unauthorized modification of a configuration item.",
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-aide_periodic_cron_checking:def:1",
			"remediations": [
				{
					"remediation_id": "aide_periodic_cron_checking",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nif ! rpm -q --quiet \"aide\" ; then\n    dnf install -y \"aide\"\nfi\n\nif ! grep -q \"/usr/sbin/aide --check\" /etc/crontab ; then\n    echo \"05 4 * * * root /usr/sbin/aide --check\" >> /etc/crontab\nelse\n    sed -i '\\!^.* --check.*$!d' /etc/crontab\n    echo \"05 4 * * * root /usr/sbin/aide --check\" >> /etc/crontab\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "aide_periodic_cron_checking",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Ensure AIDE is installed\n  package:\n    name: '{{ item }}'\n    state: present\n  with_items:\n  - aide\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-83437-4\n  - CJIS-5.10.1.3\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SI-7\n  - NIST-800-53-SI-7(1)\n  - PCI-DSS-Req-11.5\n  - aide_periodic_cron_checking\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set cron package name - RedHat\n  set_fact:\n    cron_pkg_name: cronie\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_os_family == \"RedHat\" or ansible_os_family == \"Suse\"\n  tags:\n  - CCE-83437-4\n  - CJIS-5.10.1.3\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SI-7\n  - NIST-800-53-SI-7(1)\n  - PCI-DSS-Req-11.5\n  - aide_periodic_cron_checking\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set cron package name - Debian\n  set_fact:\n    cron_pkg_name: cron\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_os_family == \"Debian\"\n  tags:\n  - CCE-83437-4\n  - CJIS-5.10.1.3\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SI-7\n  - NIST-800-53-SI-7(1)\n  - PCI-DSS-Req-11.5\n  - aide_periodic_cron_checking\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Install cron\n  package:\n    name: '{{ cron_pkg_name }}'\n    state: present\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-83437-4\n  - CJIS-5.10.1.3\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SI-7\n  - NIST-800-53-SI-7(1)\n  - PCI-DSS-Req-11.5\n  - aide_periodic_cron_checking\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Configure Periodic Execution of AIDE\n  cron:\n    name: run AIDE check\n    minute: 5\n    hour: 4\n    weekday: 0\n    user: root\n    job: /usr/sbin/aide --check\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-83437-4\n  - CJIS-5.10.1.3\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SI-7\n  - NIST-800-53-SI-7(1)\n  - PCI-DSS-Req-11.5\n  - aide_periodic_cron_checking\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_configure_bind_crypto_policy": {
			"rule_id": "xccdf_org.ssgproject.content_rule_configure_bind_crypto_policy",
			"title": "Configure BIND to use System Crypto Policy",
			"result": "pass",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "high",
			"identifiers": [
				"CCE-83451-5"
			],
			"references": [
				"CIP-003-8 R4.2",
				"CIP-007-3 R5.1",
				"SC-13",
				"SC-12(2)",
				"SC-12(3)",
				"SRG-OS-000423-GPOS-00187",
				"SRG-OS-000426-GPOS-00190"
			],
			"description": "Crypto Policies provide a centralized control over crypto algorithms usage of many packages.\nBIND is supported by crypto policy, but the BIND configuration may be\nset up to ignore it.\n\nTo check that Crypto Policies settings are configured correctly, ensure that the <code>/etc/named.conf</code>\nincludes the appropriate configuration:\nIn the <code>options</code> section of <code>/etc/named.conf</code>, make sure that the following line\nis not commented out or superseded by later includes:\n<code>include &quot;/etc/crypto-policies/back-ends/bind.config&quot;;</code>",
			"rationale": "Overriding the system crypto policy makes the behavior of the BIND service violate expectations,\nand makes system configuration more fragmented.",
			"oval_definition_id": "oval:ssg-configure_bind_crypto_policy:def:1",
			"remediations": [
				{
					"remediation_id": "configure_bind_crypto_policy",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "\nfunction remediate_bind_crypto_policy() {\n\tCONFIG_FILE=\"/etc/named.conf\"\n\tif test -f \"$CONFIG_FILE\"; then\n\t\tsed -i 's|options {|&\\n\\tinclude \"/etc/crypto-policies/back-ends/bind.config\";|' \"$CONFIG_FILE\"\n\t\treturn 0\n\telse\n\t\techo \"Aborting remediation as '$CONFIG_FILE' was not even found.\" >&2\n\t\treturn 1\n\tfi\n}\n\nremediate_bind_crypto_policy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_configure_crypto_policy": {
			"rule_id": "xccdf_org.ssgproject.content_rule_configure_crypto_policy",
			"title": "Configure System Cryptography Policy",
			"result": "pass",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "high",
			"identifiers": [
				"CCE-83450-7"
			],
			"references": [
				"164.308(a)(4)(i)",
				"164.308(b)(1)",
				"164.308(b)(3)",
				"164.312(e)(1)",
				"164.312(e)(2)(ii)",
				"1446",
				"CIP-003-8 R4.2",
				"CIP-007-3 R5.1",
				"CIP-007-3 R7.1",
				"AC-17(a)",
				"AC-17(2)",
				"CM-6(a)",
				"MA-4(6)",
				"SC-13",
				"SC-12(2)",
				"SC-12(3)",
				"FCS_COP.1(1)",
				"FCS_COP.1(2)",
				"FCS_COP.1(3)",
				"FCS_COP.1(4)",
				"FCS_CKM.1",
				"FCS_CKM.2",
				"FCS_TLSC_EXT.1",
				"SRG-OS-000396-GPOS-00176",
				"SRG-OS-000393-GPOS-00173",
				"SRG-OS-000394-GPOS-00174"
			],
			"description": "To configure the system cryptography policy to use ciphers only from the <code>DEFAULT</code>\npolicy, run the following command:\n<pre>$ sudo update-crypto-policies --set DEFAULT</pre>\nThe rule checks if settings for selected crypto policy are configured as expected. Configuration files in the <code>/etc/crypto-policies/back-ends</code> are either symlinks to correct files provided by Crypto-policies package or they are regular files in case crypto policy customizations are applied.\nCrypto policies may be customized by crypto policy modules, in which case it is delimited from the base policy using a colon.",
			"rationale": "Centralized cryptographic policies simplify applying secure ciphers across an operating system and\nthe applications that run on that operating system. Use of weak or untested encryption algorithms\nundermines the purposes of utilizing encryption to protect data.",
			"warnings": [
				{
					"text": "The system needs to be rebooted for these changes to take effect.",
					"category": "general"
				},
				{
					"text": "System Crypto Modules must be provided by a vendor that undergoes\nFIPS-140 certifications.\nFIPS-140 is applicable to all Federal agencies that use\ncryptographic-based security systems to protect sensitive information\nin computer and telecommunication systems (including voice systems) as\ndefined in Section 5131 of the Information Technology Management Reform\nAct of 1996, Public Law 104-106. This standard shall be used in\ndesigning and implementing cryptographic modules that Federal\ndepartments and agencies operate or are operated for them under\ncontract. See <b><a href=\"https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf\">https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf</a></b>\nTo meet this, the system has to have cryptographic software provided by\na vendor that has undergone this certification. This means providing\ndocumentation, test results, design information, and independent third\nparty review by an accredited lab. While open source software is\ncapable of meeting this, it does not meet FIPS-140 unless the vendor\nsubmits to this process.",
					"category": "regulatory"
				}
			],
			"oval_definition_id": "oval:ssg-configure_crypto_policy:def:1",
			"remediations": [
				{
					"remediation_id": "configure_crypto_policy",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "\nvar_system_crypto_policy='DEFAULT'\n\n\nstderr_of_call=$(update-crypto-policies --set ${var_system_crypto_policy} 2>&1 > /dev/null)\nrc=$?\n\nif test \"$rc\" = 127; then\n\techo \"$stderr_of_call\" >&2\n\techo \"Make sure that the script is installed on the remediated system.\" >&2\n\techo \"See output of the 'dnf provides update-crypto-policies' command\" >&2\n\techo \"to see what package to (re)install\" >&2\n\n\tfalse  # end with an error code\nelif test \"$rc\" != 0; then\n\techo \"Error invoking the update-crypto-policies script: $stderr_of_call\" >&2\n\tfalse  # end with an error code\nfi\n"
				},
				{
					"remediation_id": "configure_crypto_policy",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: XCCDF Value var_system_crypto_policy # promote to variable\n  set_fact:\n    var_system_crypto_policy: !!str DEFAULT\n  tags:\n    - always\n\n- name: Configure System Cryptography Policy\n  lineinfile:\n    path: /etc/crypto-policies/config\n    regexp: ^(?!#)(\\S+)$\n    line: '{{ var_system_crypto_policy }}'\n    create: true\n  tags:\n  - CCE-83450-7\n  - NIST-800-53-AC-17(2)\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-MA-4(6)\n  - NIST-800-53-SC-12(2)\n  - NIST-800-53-SC-12(3)\n  - NIST-800-53-SC-13\n  - configure_crypto_policy\n  - high_severity\n  - low_complexity\n  - low_disruption\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Verify that Crypto Policy is Set (runtime)\n  command: /usr/bin/update-crypto-policies --set {{ var_system_crypto_policy }}\n  tags:\n  - CCE-83450-7\n  - NIST-800-53-AC-17(2)\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-MA-4(6)\n  - NIST-800-53-SC-12(2)\n  - NIST-800-53-SC-12(3)\n  - NIST-800-53-SC-13\n  - configure_crypto_policy\n  - high_severity\n  - low_complexity\n  - low_disruption\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_configure_kerberos_crypto_policy": {
			"rule_id": "xccdf_org.ssgproject.content_rule_configure_kerberos_crypto_policy",
			"title": "Configure Kerberos to use System Crypto Policy",
			"result": "pass",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "high",
			"identifiers": [
				"CCE-83449-9"
			],
			"references": [
				"0418",
				"1055",
				"1402",
				"CIP-003-8 R4.2",
				"CIP-007-3 R5.1",
				"SC-13",
				"SC-12(2)",
				"SC-12(3)",
				"SRG-OS-000120-GPOS-00061"
			],
			"description": "Crypto Policies provide a centralized control over crypto algorithms usage of many packages.\nKerberos is supported by crypto policy, but it&#x27;s configuration may be\nset up to ignore it.\nTo check that Crypto Policies settings for Kerberos are configured correctly, examine that there is a symlink at\n/etc/krb5.conf.d/crypto-policies targeting /etc/cypto-policies/back-ends/krb5.config.\nIf the symlink exists, Kerberos is configured to use the system-wide crypto policy settings.",
			"rationale": "Overriding the system crypto policy makes the behavior of Kerberos violate expectations,\nand makes system configuration more fragmented.",
			"oval_definition_id": "oval:ssg-configure_kerberos_crypto_policy:def:1",
			"remediations": [
				{
					"remediation_id": "configure_kerberos_crypto_policy",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "\nrm -f /etc/krb5.conf.d/crypto-policies\nln -s /etc/crypto-policies/back-ends/krb5.config /etc/krb5.conf.d/crypto-policies\n"
				},
				{
					"remediation_id": "configure_kerberos_crypto_policy",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "- name: Configure Kerberos to use System Crypto Policy\n  file:\n    src: /etc/crypto-policies/back-ends/krb5.config\n    path: /etc/krb5.conf.d/crypto-policies\n    state: link\n  tags:\n  - CCE-83449-9\n  - NIST-800-53-SC-12(2)\n  - NIST-800-53-SC-12(3)\n  - NIST-800-53-SC-13\n  - configure_kerberos_crypto_policy\n  - configure_strategy\n  - high_severity\n  - low_complexity\n  - low_disruption\n  - reboot_required\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_configure_libreswan_crypto_policy": {
			"rule_id": "xccdf_org.ssgproject.content_rule_configure_libreswan_crypto_policy",
			"title": "Configure Libreswan to use System Crypto Policy",
			"result": "pass",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "high",
			"identifiers": [
				"CCE-83446-5"
			],
			"references": [
				"CIP-003-8 R4.2",
				"CIP-007-3 R5.1",
				"CM-6(a)",
				"MA-4(6)",
				"SC-13",
				"SC-12(2)",
				"SC-12(3)",
				"FCS_IPSEC_EXT.1.4",
				"FCS_IPSEC_EXT.1.6",
				"SRG-OS-000033-GPOS-00014"
			],
			"description": "Crypto Policies provide a centralized control over crypto algorithms usage of many packages.\nLibreswan is supported by system crypto policy, but the Libreswan configuration may be\nset up to ignore it.\n\nTo check that Crypto Policies settings are configured correctly, ensure that the <code>/etc/ipsec.conf</code>\nincludes the appropriate configuration file.\nIn <code>/etc/ipsec.conf</code>, make sure that the following line\nis not commented out or superseded by later includes:\n<code>include /etc/crypto-policies/back-ends/libreswan.config</code>",
			"rationale": "Overriding the system crypto policy makes the behavior of the Libreswan\nservice violate expectations, and makes system configuration more\nfragmented.",
			"oval_definition_id": "oval:ssg-configure_libreswan_crypto_policy:def:1",
			"remediations": [
				{
					"remediation_id": "configure_libreswan_crypto_policy",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "\nfunction remediate_libreswan_crypto_policy() {\n    CONFIG_FILE=\"/etc/ipsec.conf\"\n    if ! grep -qP \"^\\s*include\\s+/etc/crypto-policies/back-ends/libreswan.config\\s*(?:#.*)?$\" \"$CONFIG_FILE\" ; then\n        # the file might not end with a new line\n        echo -e '\\ninclude /etc/crypto-policies/back-ends/libreswan.config' >> \"$CONFIG_FILE\"\n    fi\n    return 0\n}\n\nremediate_libreswan_crypto_policy\n"
				},
				{
					"remediation_id": "configure_libreswan_crypto_policy",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Configure Libreswan to use System Crypto Policy\n  lineinfile:\n    path: /etc/ipsec.conf\n    line: include /etc/crypto-policies/back-ends/libreswan.config\n    create: true\n  tags:\n  - CCE-83446-5\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-MA-4(6)\n  - NIST-800-53-SC-12(2)\n  - NIST-800-53-SC-12(3)\n  - NIST-800-53-SC-13\n  - configure_libreswan_crypto_policy\n  - high_severity\n  - low_complexity\n  - low_disruption\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_configure_openssl_crypto_policy": {
			"rule_id": "xccdf_org.ssgproject.content_rule_configure_openssl_crypto_policy",
			"title": "Configure OpenSSL library to use System Crypto Policy",
			"result": "pass",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83452-3"
			],
			"references": [
				"CCI-001453",
				"CIP-003-8 R4.2",
				"CIP-007-3 R5.1",
				"CIP-007-3 R7.1",
				"AC-17(a)",
				"AC-17(2)",
				"CM-6(a)",
				"MA-4(6)",
				"SC-13",
				"SC-12(2)",
				"SC-12(3)",
				"SRG-OS-000250-GPOS-00093"
			],
			"description": "Crypto Policies provide a centralized control over crypto algorithms usage of many packages.\nOpenSSL is supported by crypto policy, but the OpenSSL configuration may be\nset up to ignore it.\nTo check that Crypto Policies settings are configured correctly, you have to examine the OpenSSL config file\navailable under <code>/etc/pki/tls/openssl.cnf</code>.\nThis file has the <code>ini</code> format, and it enables crypto policy support\nif there is a <code>[ crypto_policy ]</code> section that contains the <code>.include = /etc/crypto-policies/back-ends/opensslcnf.config</code> directive.",
			"rationale": "Overriding the system crypto policy makes the behavior of the Java runtime violates expectations,\nand makes system configuration more fragmented.",
			"oval_definition_id": "oval:ssg-configure_openssl_crypto_policy:def:1",
			"remediations": [
				{
					"remediation_id": "configure_openssl_crypto_policy",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "\nOPENSSL_CRYPTO_POLICY_SECTION='[ crypto_policy ]'\nOPENSSL_CRYPTO_POLICY_SECTION_REGEX='\\[\\s*crypto_policy\\s*\\]'\nOPENSSL_CRYPTO_POLICY_INCLUSION='.include = /etc/crypto-policies/back-ends/opensslcnf.config'\nOPENSSL_CRYPTO_POLICY_INCLUSION_REGEX='^\\s*\\.include\\s*(?:=\\s*)?/etc/crypto-policies/back-ends/opensslcnf.config$'\n\n\n  \n\n\nfunction remediate_openssl_crypto_policy() {\n\tCONFIG_FILE=/etc/pki/tls/openssl.cnf\n\tif test -f \"$CONFIG_FILE\"; then\n\t\tif ! grep -q \"^\\\\s*$OPENSSL_CRYPTO_POLICY_SECTION_REGEX\" \"$CONFIG_FILE\"; then\n\t\t\tprintf '\\n%s\\n\\n%s' \"$OPENSSL_CRYPTO_POLICY_SECTION\" \"$OPENSSL_CRYPTO_POLICY_INCLUSION\" >> \"$CONFIG_FILE\"\n\t\t\treturn 0\n\t\telif ! grep -q \"^\\\\s*$OPENSSL_CRYPTO_POLICY_INCLUSION_REGEX\" \"$CONFIG_FILE\"; then\n\t\t\tsed -i \"s|$OPENSSL_CRYPTO_POLICY_SECTION_REGEX|&\\\\n\\\\n$OPENSSL_CRYPTO_POLICY_INCLUSION\\\\n|\" \"$CONFIG_FILE\"\n\t\t\treturn 0\n\t\tfi\n\telse\n\t\techo \"Aborting remediation as '$CONFIG_FILE' was not even found.\" >&2\n\t\treturn 1\n\tfi\n}\n\nremediate_openssl_crypto_policy\n"
				},
				{
					"remediation_id": "configure_openssl_crypto_policy",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "medium",
					"strategy": "unknown",
					"fix": "- name: Test for crypto_policy group\n  command: grep '^\\s*\\[\\s*crypto_policy\\s*]' /etc/pki/tls/openssl.cnf\n  register: test_crypto_policy_group\n  ignore_errors: true\n  changed_when: false\n  check_mode: false\n  tags:\n  - CCE-83452-3\n  - NIST-800-53-AC-17(2)\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-MA-4(6)\n  - NIST-800-53-SC-12(2)\n  - NIST-800-53-SC-12(3)\n  - NIST-800-53-SC-13\n  - configure_openssl_crypto_policy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n\n- name: Add .include for opensslcnf.config to crypto_policy section\n  lineinfile:\n    create: true\n    insertafter: ^\\s*\\[\\s*crypto_policy\\s*]\\s*\n    line: .include = /etc/crypto-policies/back-ends/opensslcnf.config\n    path: /etc/pki/tls/openssl.cnf\n  when:\n  - test_crypto_policy_group.stdout is defined\n  - test_crypto_policy_group.stdout | length > 0\n  tags:\n  - CCE-83452-3\n  - NIST-800-53-AC-17(2)\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-MA-4(6)\n  - NIST-800-53-SC-12(2)\n  - NIST-800-53-SC-12(3)\n  - NIST-800-53-SC-13\n  - configure_openssl_crypto_policy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n\n- name: Add crypto_policy group and set include opensslcnf.config\n  lineinfile:\n    create: true\n    line: |-\n      [crypto_policy]\n      .include = /etc/crypto-policies/back-ends/opensslcnf.config\n    path: /etc/pki/tls/openssl.cnf\n  when:\n  - test_crypto_policy_group.stdout is defined\n  - test_crypto_policy_group.stdout | length < 1\n  tags:\n  - CCE-83452-3\n  - NIST-800-53-AC-17(2)\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-MA-4(6)\n  - NIST-800-53-SC-12(2)\n  - NIST-800-53-SC-12(3)\n  - NIST-800-53-SC-13\n  - configure_openssl_crypto_policy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_configure_ssh_crypto_policy": {
			"rule_id": "xccdf_org.ssgproject.content_rule_configure_ssh_crypto_policy",
			"title": "Configure SSH to use System Crypto Policy",
			"result": "error",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83445-7"
			],
			"references": [
				"CCI-001453",
				"164.308(a)(4)(i)",
				"164.308(b)(1)",
				"164.308(b)(3)",
				"164.312(e)(1)",
				"164.312(e)(2)(ii)",
				"CIP-003-8 R4.2",
				"CIP-007-3 R5.1",
				"CIP-007-3 R7.1",
				"AC-17(a)",
				"AC-17(2)",
				"CM-6(a)",
				"MA-4(6)",
				"SC-13",
				"FCS_SSH_EXT.1",
				"FCS_SSHS_EXT.1",
				"FCS_SSHC_EXT.1",
				"SRG-OS-000250-GPOS-00093"
			],
			"description": "Crypto Policies provide a centralized control over crypto algorithms usage of many packages.\nSSH is supported by crypto policy, but the SSH configuration may be\nset up to ignore it.\nTo check that Crypto Policies settings are configured correctly, ensure that\nthe <code>CRYPTO_POLICY</code> variable is either commented or not set at all\nin the <code>/etc/sysconfig/sshd</code>.",
			"rationale": "Overriding the system crypto policy makes the behavior of the SSH service violate expectations,\nand makes system configuration more fragmented.",
			"oval_definition_id": "oval:ssg-configure_ssh_crypto_policy:def:1",
			"remediations": [
				{
					"remediation_id": "configure_ssh_crypto_policy",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "\nSSH_CONF=\"/etc/sysconfig/sshd\"\n\nsed -i \"/^\\s*CRYPTO_POLICY.*$/Id\" $SSH_CONF\n"
				},
				{
					"remediation_id": "configure_ssh_crypto_policy",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "medium",
					"strategy": "disable",
					"fix": "- name: Configure SSH to use System Crypto Policy\n  lineinfile:\n    dest: /etc/sysconfig/sshd\n    state: absent\n    regexp: ^\\s*(?i)CRYPTO_POLICY.*$\n  tags:\n  - CCE-83445-7\n  - NIST-800-53-AC-17(2)\n  - NIST-800-53-AC-17(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-MA-4(6)\n  - NIST-800-53-SC-13\n  - configure_ssh_crypto_policy\n  - disable_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - reboot_required\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_install_hids": {
			"rule_id": "xccdf_org.ssgproject.content_rule_install_hids",
			"title": "Install Intrusion Detection Software",
			"result": "pass",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "high",
			"identifiers": [
				"CCE-88837-0"
			],
			"references": [
				"1",
				"12",
				"13",
				"14",
				"15",
				"16",
				"18",
				"7",
				"8",
				"9",
				"APO01.06",
				"APO13.01",
				"DSS01.03",
				"DSS01.05",
				"DSS03.05",
				"DSS05.02",
				"DSS05.04",
				"DSS05.07",
				"DSS06.02",
				"CCI-001263",
				"4.3.3.4",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.10.1.1",
				"A.11.1.4",
				"A.11.1.5",
				"A.11.2.1",
				"A.13.1.1",
				"A.13.1.3",
				"A.13.2.1",
				"A.13.2.3",
				"A.13.2.4",
				"A.14.1.2",
				"A.14.1.3",
				"A.6.1.2",
				"A.7.1.1",
				"A.7.1.2",
				"A.7.3.1",
				"A.8.2.2",
				"A.8.2.3",
				"A.9.1.1",
				"A.9.1.2",
				"A.9.2.3",
				"A.9.4.1",
				"A.9.4.4",
				"A.9.4.5",
				"CM-6(a)",
				"DE.CM-1",
				"PR.AC-5",
				"PR.DS-5",
				"PR.PT-4",
				"Req-11.4"
			],
			"description": "The base Red Hat Enterprise Linux 9 platform already includes a sophisticated auditing system that\ncan detect intruder activity, as well as SELinux, which provides host-based\nintrusion prevention capabilities by confining privileged programs and user\nsessions which may become compromised.",
			"rationale": "Host-based intrusion detection tools provide a system-level defense when an\nintruder gains access to a system or network.",
			"warnings": [
				{
					"text": "In DoD environments, supplemental intrusion detection and antivirus tools,\nsuch as the McAfee Host-based Security System, are available to integrate with\nexisting infrastructure. Per DISA guidance, when these supplemental tools interfere\nwith proper functioning of SELinux, SELinux takes precedence. Should further\nclarification be required, DISA contact information is published publicly at\nhttps://public.cyber.mil/stigs/",
					"category": "general"
				}
			],
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-install_hids:def:1"
		},
		"xccdf_org.ssgproject.content_rule_dconf_db_up_to_date": {
			"rule_id": "xccdf_org.ssgproject.content_rule_dconf_db_up_to_date",
			"title": "Make sure that the dconf databases are up-to-date with regards to respective keyfiles",
			"result": "pass",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "high",
			"identifiers": [
				"CCE-87295-2"
			],
			"references": [
				"164.308(a)(1)(ii)(B)",
				"164.308(a)(5)(ii)(A)",
				"SRG-OS-000480-GPOS-00227"
			],
			"description": "By default, DConf uses a binary database as a data backend.\nThe system-level database is compiled from keyfiles in the /etc/dconf/db/\ndirectory by the <pre>dconf update</pre> command. More specifically, content present\nin the following directories:\n<pre>/etc/dconf/db/distro.d</pre>\n<pre>/etc/dconf/db/local.d</pre>",
			"rationale": "Unlike text-based keyfiles, the binary database is impossible to check by OVAL.\nTherefore, in order to evaluate dconf configuration, both have to be true at the same time -\nconfiguration files have to be compliant, and the database needs to be more recent than those keyfiles,\nwhich gives confidence that it reflects them.",
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-dconf_db_up_to_date:def:1",
			"remediations": [
				{
					"remediation_id": "dconf_db_up_to_date",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q gdm && { [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; }; then\n\ndconf update\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_dconf_gnome_screensaver_idle_activation_enabled": {
			"rule_id": "xccdf_org.ssgproject.content_rule_dconf_gnome_screensaver_idle_activation_enabled",
			"title": "Enable GNOME3 Screensaver Idle Activation",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-87755-5"
			],
			"references": [
				"1",
				"12",
				"15",
				"16",
				"5.5.5",
				"DSS05.04",
				"DSS05.10",
				"DSS06.10",
				"3.1.10",
				"CCI-000057",
				"4.3.3.6.1",
				"4.3.3.6.2",
				"4.3.3.6.3",
				"4.3.3.6.4",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.3.6.9",
				"SR 1.1",
				"SR 1.10",
				"SR 1.2",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"A.18.1.4",
				"A.9.2.1",
				"A.9.2.4",
				"A.9.3.1",
				"A.9.4.2",
				"A.9.4.3",
				"CM-6(a)",
				"AC-11(a)",
				"PR.AC-7",
				"FMT_MOF_EXT.1",
				"Req-8.1.8",
				"SRG-OS-000029-GPOS-00010"
			],
			"description": "To activate the screensaver in the GNOME3 desktop after a period of inactivity,\nadd or set <code>idle-activation-enabled</code> to <code>true</code> in\n<code>/etc/dconf/db/local.d/00-security-settings</code>. For example:\n<pre>[org/gnome/desktop/screensaver]\nidle-activation-enabled=true</pre>\nOnce the setting has been added, add a lock to\n<code>/etc/dconf/db/local.d/locks/00-security-settings-lock</code> to prevent user modification.\nFor example:\n<pre>/org/gnome/desktop/screensaver/idle-activation-enabled</pre>\nAfter the settings have been set, run <code>dconf update</code>.",
			"rationale": "A session time-out lock is a temporary action taken when a user stops work and moves away from the immediate\nphysical vicinity of the information system but does not logout because of the temporary nature of the absence.\nRather than relying on the user to manually lock their operating system session prior to vacating the vicinity,\nGNOME desktops can be configured to identify when a user&#x27;s session has idled and take action to initiate the\nsession lock.\n<br><br>\nEnabling idle activation of the screensaver ensures the screensaver will\nbe activated after the idle delay.  Applications requiring continuous,\nreal-time screen display (such as network management products) require the\nlogin session does not have administrator rights and the display station is located in a\ncontrolled-access area.",
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-dconf_gnome_screensaver_idle_activation_enabled:def:1",
			"remediations": [
				{
					"remediation_id": "dconf_gnome_screensaver_idle_activation_enabled",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q gdm && { [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; }; then\n\n# Check for setting in any of the DConf db directories\n# If files contain ibus or distro, ignore them.\n# The assignment assumes that individual filenames don't contain :\nreadarray -t SETTINGSFILES < <(grep -r \"\\\\[org/gnome/desktop/screensaver\\\\]\" \"/etc/dconf/db/\" | grep -v 'distro\\|ibus' | cut -d\":\" -f1)\nDCONFFILE=\"/etc/dconf/db/local.d/00-security-settings\"\nDBDIR=\"/etc/dconf/db/local.d\"\n\nmkdir -p \"${DBDIR}\"\n\nif [ \"${#SETTINGSFILES[@]}\" -eq 0 ]\nthen\n    [ ! -z ${DCONFFILE} ] || echo \"\" >> ${DCONFFILE}\n    printf '%s\\n' \"[org/gnome/desktop/screensaver]\" >> ${DCONFFILE}\n    printf '%s=%s\\n' \"idle-activation-enabled\" \"true\" >> ${DCONFFILE}\nelse\n    escaped_value=\"$(sed -e 's/\\\\/\\\\\\\\/g' <<< \"true\")\"\n    if grep -q \"^\\\\s*idle-activation-enabled\\\\s*=\" \"${SETTINGSFILES[@]}\"\n    then\n        \n        sed -i \"s/\\\\s*idle-activation-enabled\\\\s*=\\\\s*.*/idle-activation-enabled=${escaped_value}/g\" \"${SETTINGSFILES[@]}\"\n    else\n        sed -i \"\\\\|\\\\[org/gnome/desktop/screensaver\\\\]|a\\\\idle-activation-enabled=${escaped_value}\" \"${SETTINGSFILES[@]}\"\n    fi\nfi\n\ndconf update\n# Check for setting in any of the DConf db directories\nLOCKFILES=$(grep -r \"^/org/gnome/desktop/screensaver/idle-activation-enabled$\" \"/etc/dconf/db/\" | grep -v 'distro\\|ibus' | cut -d\":\" -f1)\nLOCKSFOLDER=\"/etc/dconf/db/local.d/locks\"\n\nmkdir -p \"${LOCKSFOLDER}\"\n\nif [[ -z \"${LOCKFILES}\" ]]\nthen\n    echo \"/org/gnome/desktop/screensaver/idle-activation-enabled\" >> \"/etc/dconf/db/local.d/locks/00-security-settings-lock\"\nfi\n\ndconf update\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "dconf_gnome_screensaver_idle_activation_enabled",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "medium",
					"strategy": "unknown",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-87755-5\n  - CJIS-5.5.5\n  - NIST-800-171-3.1.10\n  - NIST-800-53-AC-11(a)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.8\n  - dconf_gnome_screensaver_idle_activation_enabled\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n\n- name: Enable GNOME3 Screensaver Idle Activation\n  ini_file:\n    dest: /etc/dconf/db/local.d/00-security-settings\n    section: org/gnome/desktop/screensaver\n    option: idle-activation-enabled\n    value: 'true'\n    create: true\n    no_extra_spaces: true\n  when:\n  - '\"gdm\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-87755-5\n  - CJIS-5.5.5\n  - NIST-800-171-3.1.10\n  - NIST-800-53-AC-11(a)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.8\n  - dconf_gnome_screensaver_idle_activation_enabled\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n\n- name: Prevent user modification of GNOME idle-activation-enabled\n  lineinfile:\n    path: /etc/dconf/db/local.d/locks/00-security-settings-lock\n    regexp: ^/org/gnome/desktop/screensaver/idle-activation-enabled$\n    line: /org/gnome/desktop/screensaver/idle-activation-enabled\n    create: true\n  when:\n  - '\"gdm\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-87755-5\n  - CJIS-5.5.5\n  - NIST-800-171-3.1.10\n  - NIST-800-53-AC-11(a)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.8\n  - dconf_gnome_screensaver_idle_activation_enabled\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n\n- name: Dconf Update\n  command: dconf update\n  when:\n  - '\"gdm\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-87755-5\n  - CJIS-5.5.5\n  - NIST-800-171-3.1.10\n  - NIST-800-53-AC-11(a)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.8\n  - dconf_gnome_screensaver_idle_activation_enabled\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_dconf_gnome_screensaver_idle_delay": {
			"rule_id": "xccdf_org.ssgproject.content_rule_dconf_gnome_screensaver_idle_delay",
			"title": "Set GNOME3 Screensaver Inactivity Timeout",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-86510-5"
			],
			"references": [
				"1",
				"12",
				"15",
				"16",
				"5.5.5",
				"DSS05.04",
				"DSS05.10",
				"DSS06.10",
				"3.1.10",
				"CCI-000057",
				"CCI-000060",
				"4.3.3.6.1",
				"4.3.3.6.2",
				"4.3.3.6.3",
				"4.3.3.6.4",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.3.6.9",
				"SR 1.1",
				"SR 1.10",
				"SR 1.2",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"A.18.1.4",
				"A.9.2.1",
				"A.9.2.4",
				"A.9.3.1",
				"A.9.4.2",
				"A.9.4.3",
				"AC-11(a)",
				"CM-6(a)",
				"PR.AC-7",
				"FMT_MOF_EXT.1",
				"Req-8.1.8",
				"SRG-OS-000029-GPOS-00010",
				"SRG-OS-000031-GPOS-00012"
			],
			"description": "The idle time-out value for inactivity in the GNOME3 desktop is configured via the <code>idle-delay</code>\nsetting must be set under an appropriate configuration file(s) in the <code>/etc/dconf/db/local.d</code> directory\nand locked in <code>/etc/dconf/db/local.d/locks</code> directory to prevent user modification.\n<br><br>\nFor example, to configure the system for a 15 minute delay, add the following to\n<code>/etc/dconf/db/local.d/00-security-settings</code>:\n<pre>[org/gnome/desktop/session]\nidle-delay=uint32 900</pre>",
			"rationale": "A session time-out lock is a temporary action taken when a user stops work and moves away from\nthe immediate physical vicinity of the information system but does not logout because of the\ntemporary nature of the absence. Rather than relying on the user to manually lock their operating\nsystem session prior to vacating the vicinity, GNOME3 can be configured to identify when\na user&#x27;s session has idled and take action to initiate a session lock.",
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-dconf_gnome_screensaver_idle_delay:def:1",
			"remediations": [
				{
					"remediation_id": "dconf_gnome_screensaver_idle_delay",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q gdm && { [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; }; then\n\ninactivity_timeout_value='900'\n\n\n# Check for setting in any of the DConf db directories\n# If files contain ibus or distro, ignore them.\n# The assignment assumes that individual filenames don't contain :\nreadarray -t SETTINGSFILES < <(grep -r \"\\\\[org/gnome/desktop/session\\\\]\" \"/etc/dconf/db/\" | grep -v 'distro\\|ibus' | cut -d\":\" -f1)\nDCONFFILE=\"/etc/dconf/db/local.d/00-security-settings\"\nDBDIR=\"/etc/dconf/db/local.d\"\n\nmkdir -p \"${DBDIR}\"\n\nif [ \"${#SETTINGSFILES[@]}\" -eq 0 ]\nthen\n    [ ! -z ${DCONFFILE} ] || echo \"\" >> ${DCONFFILE}\n    printf '%s\\n' \"[org/gnome/desktop/session]\" >> ${DCONFFILE}\n    printf '%s=%s\\n' \"idle-delay\" \"uint32 ${inactivity_timeout_value}\" >> ${DCONFFILE}\nelse\n    escaped_value=\"$(sed -e 's/\\\\/\\\\\\\\/g' <<< \"uint32 ${inactivity_timeout_value}\")\"\n    if grep -q \"^\\\\s*idle-delay\\\\s*=\" \"${SETTINGSFILES[@]}\"\n    then\n        \n        sed -i \"s/\\\\s*idle-delay\\\\s*=\\\\s*.*/idle-delay=${escaped_value}/g\" \"${SETTINGSFILES[@]}\"\n    else\n        sed -i \"\\\\|\\\\[org/gnome/desktop/session\\\\]|a\\\\idle-delay=${escaped_value}\" \"${SETTINGSFILES[@]}\"\n    fi\nfi\n\ndconf update\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "dconf_gnome_screensaver_idle_delay",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "medium",
					"strategy": "unknown",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-86510-5\n  - CJIS-5.5.5\n  - NIST-800-171-3.1.10\n  - NIST-800-53-AC-11(a)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.8\n  - dconf_gnome_screensaver_idle_delay\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n- name: XCCDF Value inactivity_timeout_value # promote to variable\n  set_fact:\n    inactivity_timeout_value: !!str 900\n  tags:\n    - always\n\n- name: Set GNOME3 Screensaver Inactivity Timeout\n  ini_file:\n    dest: /etc/dconf/db/local.d/00-security-settings\n    section: org/gnome/desktop/session\n    option: idle-delay\n    value: uint32 {{ inactivity_timeout_value }}\n    create: true\n    no_extra_spaces: true\n  when:\n  - '\"gdm\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-86510-5\n  - CJIS-5.5.5\n  - NIST-800-171-3.1.10\n  - NIST-800-53-AC-11(a)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.8\n  - dconf_gnome_screensaver_idle_delay\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n\n- name: Dconf Update\n  command: dconf update\n  when:\n  - '\"gdm\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-86510-5\n  - CJIS-5.5.5\n  - NIST-800-171-3.1.10\n  - NIST-800-53-AC-11(a)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.8\n  - dconf_gnome_screensaver_idle_delay\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_dconf_gnome_screensaver_lock_enabled": {
			"rule_id": "xccdf_org.ssgproject.content_rule_dconf_gnome_screensaver_lock_enabled",
			"title": "Enable GNOME3 Screensaver Lock After Idle Period",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-89302-4"
			],
			"references": [
				"1",
				"12",
				"15",
				"16",
				"5.5.5",
				"DSS05.04",
				"DSS05.10",
				"DSS06.10",
				"3.1.10",
				"CCI-000056",
				"CCI-000058",
				"CCI-000060",
				"4.3.3.6.1",
				"4.3.3.6.2",
				"4.3.3.6.3",
				"4.3.3.6.4",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.3.6.9",
				"SR 1.1",
				"SR 1.10",
				"SR 1.2",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"A.18.1.4",
				"A.9.2.1",
				"A.9.2.4",
				"A.9.3.1",
				"A.9.4.2",
				"A.9.4.3",
				"CM-6(a)",
				"PR.AC-7",
				"FMT_MOF_EXT.1",
				"Req-8.1.8",
				"SRG-OS-000028-GPOS-00009",
				"SRG-OS-000030-GPOS-00011"
			],
			"description": "\nTo activate locking of the screensaver in the GNOME3 desktop when it is activated,\nadd or set <code>lock-enabled</code> to <code>true</code> in\n<code>/etc/dconf/db/local.d/00-security-settings</code>. For example:\n<pre>[org/gnome/desktop/screensaver]\nlock-enabled=true\n</pre>\nOnce the settings have been added, add a lock to\n<code>/etc/dconf/db/local.d/locks/00-security-settings-lock</code> to prevent user modification.\nFor example:\n<pre>/org/gnome/desktop/screensaver/lock-enabled</pre>\nAfter the settings have been set, run <code>dconf update</code>.",
			"rationale": "A session lock is a temporary action taken when a user stops work and moves away from the immediate physical vicinity\nof the information system but does not want to logout because of the temporary nature of the absense.",
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-dconf_gnome_screensaver_lock_enabled:def:1",
			"remediations": [
				{
					"remediation_id": "dconf_gnome_screensaver_lock_enabled",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q gdm && { [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; }; then\n\n# Check for setting in any of the DConf db directories\n# If files contain ibus or distro, ignore them.\n# The assignment assumes that individual filenames don't contain :\nreadarray -t SETTINGSFILES < <(grep -r \"\\\\[org/gnome/desktop/screensaver\\\\]\" \"/etc/dconf/db/\" | grep -v 'distro\\|ibus' | cut -d\":\" -f1)\nDCONFFILE=\"/etc/dconf/db/local.d/00-security-settings\"\nDBDIR=\"/etc/dconf/db/local.d\"\n\nmkdir -p \"${DBDIR}\"\n\nif [ \"${#SETTINGSFILES[@]}\" -eq 0 ]\nthen\n    [ ! -z ${DCONFFILE} ] || echo \"\" >> ${DCONFFILE}\n    printf '%s\\n' \"[org/gnome/desktop/screensaver]\" >> ${DCONFFILE}\n    printf '%s=%s\\n' \"lock-enabled\" \"true\" >> ${DCONFFILE}\nelse\n    escaped_value=\"$(sed -e 's/\\\\/\\\\\\\\/g' <<< \"true\")\"\n    if grep -q \"^\\\\s*lock-enabled\\\\s*=\" \"${SETTINGSFILES[@]}\"\n    then\n        \n        sed -i \"s/\\\\s*lock-enabled\\\\s*=\\\\s*.*/lock-enabled=${escaped_value}/g\" \"${SETTINGSFILES[@]}\"\n    else\n        sed -i \"\\\\|\\\\[org/gnome/desktop/screensaver\\\\]|a\\\\lock-enabled=${escaped_value}\" \"${SETTINGSFILES[@]}\"\n    fi\nfi\n\ndconf update\n# Check for setting in any of the DConf db directories\nLOCKFILES=$(grep -r \"^/org/gnome/desktop/screensaver/lock-enabled$\" \"/etc/dconf/db/\" | grep -v 'distro\\|ibus' | cut -d\":\" -f1)\nLOCKSFOLDER=\"/etc/dconf/db/local.d/locks\"\n\nmkdir -p \"${LOCKSFOLDER}\"\n\nif [[ -z \"${LOCKFILES}\" ]]\nthen\n    echo \"/org/gnome/desktop/screensaver/lock-enabled\" >> \"/etc/dconf/db/local.d/locks/00-security-settings-lock\"\nfi\n\ndconf update\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "dconf_gnome_screensaver_lock_enabled",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "medium",
					"strategy": "unknown",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-89302-4\n  - CJIS-5.5.5\n  - NIST-800-171-3.1.10\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.8\n  - dconf_gnome_screensaver_lock_enabled\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n\n- name: Dconf Update\n  command: dconf update\n  when:\n  - '\"gdm\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_distribution == 'SLES'\n  tags:\n  - CCE-89302-4\n  - CJIS-5.5.5\n  - NIST-800-171-3.1.10\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.8\n  - dconf_gnome_screensaver_lock_enabled\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n\n- name: Enable GNOME3 Screensaver Lock After Idle Period\n  ini_file:\n    dest: /etc/dconf/db/local.d/00-security-settings\n    section: org/gnome/desktop/screensaver\n    option: lock-enabled\n    value: 'true'\n    create: true\n    no_extra_spaces: true\n  when:\n  - '\"gdm\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_distribution != 'SLES'\n  tags:\n  - CCE-89302-4\n  - CJIS-5.5.5\n  - NIST-800-171-3.1.10\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.8\n  - dconf_gnome_screensaver_lock_enabled\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n\n- name: Prevent user modification of GNOME lock-enabled\n  lineinfile:\n    path: /etc/dconf/db/local.d/locks/00-security-settings-lock\n    regexp: ^/org/gnome/desktop/screensaver/lock-enabled$\n    line: /org/gnome/desktop/screensaver/lock-enabled\n    create: true\n  when:\n  - '\"gdm\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_distribution != 'SLES'\n  tags:\n  - CCE-89302-4\n  - CJIS-5.5.5\n  - NIST-800-171-3.1.10\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.8\n  - dconf_gnome_screensaver_lock_enabled\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n\n- name: Enable GNOME3 Screensaver Lock After Idle Period\n  ini_file:\n    dest: /etc/dconf/db/local.d/00-security-settings\n    section: org/gnome/desktop/lockdown\n    option: disable-lock-screen\n    value: 'false'\n    create: true\n    no_extra_spaces: true\n  when:\n  - '\"gdm\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_distribution == 'SLES'\n  tags:\n  - CCE-89302-4\n  - CJIS-5.5.5\n  - NIST-800-171-3.1.10\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.8\n  - dconf_gnome_screensaver_lock_enabled\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n\n- name: Prevent user modification of GNOME disable-lock-screen\n  lineinfile:\n    path: /etc/dconf/db/local.d/locks/00-security-settings-lock\n    regexp: ^/org/gnome/desktop/lockdown/disable-lock-screen$\n    line: /org/gnome/desktop/lockdown/disable-lock-screen\n    create: true\n  when:\n  - '\"gdm\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_distribution == 'SLES'\n  tags:\n  - CCE-89302-4\n  - CJIS-5.5.5\n  - NIST-800-171-3.1.10\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.8\n  - dconf_gnome_screensaver_lock_enabled\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n\n- name: Check GNOME3 screenserver disable-lock-screen false\n  command: gsettings get org.gnome.desktop.lockdown disable-lock-screen\n  register: cmd_out\n  when:\n  - '\"gdm\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_distribution == 'SLES'\n  tags:\n  - CCE-89302-4\n  - CJIS-5.5.5\n  - NIST-800-171-3.1.10\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.8\n  - dconf_gnome_screensaver_lock_enabled\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n\n- name: Update GNOME3 screenserver disable-lock-screen false\n  command: gsettings set org.gnome.desktop.lockdown disable-lock-screen false\n  when:\n  - '\"gdm\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - ansible_distribution == 'SLES'\n  tags:\n  - CCE-89302-4\n  - CJIS-5.5.5\n  - NIST-800-171-3.1.10\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.8\n  - dconf_gnome_screensaver_lock_enabled\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n\n- name: Dconf Update\n  command: dconf update\n  when:\n  - '\"gdm\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-89302-4\n  - CJIS-5.5.5\n  - NIST-800-171-3.1.10\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.8\n  - dconf_gnome_screensaver_lock_enabled\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_dconf_gnome_screensaver_mode_blank": {
			"rule_id": "xccdf_org.ssgproject.content_rule_dconf_gnome_screensaver_mode_blank",
			"title": "Implement Blank Screensaver",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-88733-1"
			],
			"references": [
				"1",
				"12",
				"15",
				"16",
				"5.5.5",
				"DSS05.04",
				"DSS05.10",
				"DSS06.10",
				"3.1.10",
				"CCI-000060",
				"4.3.3.6.1",
				"4.3.3.6.2",
				"4.3.3.6.3",
				"4.3.3.6.4",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.3.6.9",
				"SR 1.1",
				"SR 1.10",
				"SR 1.2",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"A.18.1.4",
				"A.9.2.1",
				"A.9.2.4",
				"A.9.3.1",
				"A.9.4.2",
				"A.9.4.3",
				"AC-11(1)",
				"CM-6(a)",
				"AC-11(1).1",
				"PR.AC-7",
				"FMT_MOF_EXT.1",
				"Req-8.1.8",
				"SRG-OS-000031-GPOS-00012"
			],
			"description": "\n\n\nTo set the screensaver mode in the GNOME3 desktop to a blank screen,\nadd or set <code>picture-uri</code> to <code>string &#x27;&#x27;</code> in\n<code>/etc/dconf/db/local.d/00-security-settings</code>. For example:\n<pre>[org/gnome/desktop/screensaver]\npicture-uri=string &#x27;&#x27;\n</pre>\nOnce the settings have been added, add a lock to\n<code>/etc/dconf/db/local.d/locks/00-security-settings-lock</code> to prevent user modification.\nFor example:\n<pre>/org/gnome/desktop/screensaver/picture-uri</pre>\nAfter the settings have been set, run <code>dconf update</code>.",
			"rationale": "Setting the screensaver mode to blank-only conceals the\ncontents of the display from passersby.",
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-dconf_gnome_screensaver_mode_blank:def:1",
			"remediations": [
				{
					"remediation_id": "dconf_gnome_screensaver_mode_blank",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q gdm && { [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; }; then\n\n# Check for setting in any of the DConf db directories\n# If files contain ibus or distro, ignore them.\n# The assignment assumes that individual filenames don't contain :\nreadarray -t SETTINGSFILES < <(grep -r \"\\\\[org/gnome/desktop/screensaver\\\\]\" \"/etc/dconf/db/\" | grep -v 'distro\\|ibus' | cut -d\":\" -f1)\nDCONFFILE=\"/etc/dconf/db/local.d/00-security-settings\"\nDBDIR=\"/etc/dconf/db/local.d\"\n\nmkdir -p \"${DBDIR}\"\n\nif [ \"${#SETTINGSFILES[@]}\" -eq 0 ]\nthen\n    [ ! -z ${DCONFFILE} ] || echo \"\" >> ${DCONFFILE}\n    printf '%s\\n' \"[org/gnome/desktop/screensaver]\" >> ${DCONFFILE}\n    printf '%s=%s\\n' \"picture-uri\" \"string ''\" >> ${DCONFFILE}\nelse\n    escaped_value=\"$(sed -e 's/\\\\/\\\\\\\\/g' <<< \"string ''\")\"\n    if grep -q \"^\\\\s*picture-uri\\\\s*=\" \"${SETTINGSFILES[@]}\"\n    then\n        \n        sed -i \"s/\\\\s*picture-uri\\\\s*=\\\\s*.*/picture-uri=${escaped_value}/g\" \"${SETTINGSFILES[@]}\"\n    else\n        sed -i \"\\\\|\\\\[org/gnome/desktop/screensaver\\\\]|a\\\\picture-uri=${escaped_value}\" \"${SETTINGSFILES[@]}\"\n    fi\nfi\n\ndconf update\n# Check for setting in any of the DConf db directories\nLOCKFILES=$(grep -r \"^/org/gnome/desktop/screensaver/picture-uri$\" \"/etc/dconf/db/\" | grep -v 'distro\\|ibus' | cut -d\":\" -f1)\nLOCKSFOLDER=\"/etc/dconf/db/local.d/locks\"\n\nmkdir -p \"${LOCKSFOLDER}\"\n\nif [[ -z \"${LOCKFILES}\" ]]\nthen\n    echo \"/org/gnome/desktop/screensaver/picture-uri\" >> \"/etc/dconf/db/local.d/locks/00-security-settings-lock\"\nfi\n\ndconf update\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "dconf_gnome_screensaver_mode_blank",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "medium",
					"strategy": "unknown",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-88733-1\n  - CJIS-5.5.5\n  - NIST-800-171-3.1.10\n  - NIST-800-53-AC-11(1)\n  - NIST-800-53-AC-11(1).1\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.8\n  - dconf_gnome_screensaver_mode_blank\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n\n- name: Implement Blank Screensaver\n  ini_file:\n    dest: /etc/dconf/db/local.d/00-security-settings\n    section: org/gnome/desktop/screensaver\n    option: picture-uri\n    value: string ''\n    create: true\n    no_extra_spaces: true\n  when:\n  - '\"gdm\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-88733-1\n  - CJIS-5.5.5\n  - NIST-800-171-3.1.10\n  - NIST-800-53-AC-11(1)\n  - NIST-800-53-AC-11(1).1\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.8\n  - dconf_gnome_screensaver_mode_blank\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n\n- name: Prevent user modification of GNOME picture-uri\n  lineinfile:\n    path: /etc/dconf/db/local.d/locks/00-security-settings-lock\n    regexp: ^/org/gnome/desktop/screensaver/picture-uri$\n    line: /org/gnome/desktop/screensaver/picture-uri\n    create: true\n  when:\n  - '\"gdm\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-88733-1\n  - CJIS-5.5.5\n  - NIST-800-171-3.1.10\n  - NIST-800-53-AC-11(1)\n  - NIST-800-53-AC-11(1).1\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.8\n  - dconf_gnome_screensaver_mode_blank\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n\n- name: Dconf Update\n  command: dconf update\n  when:\n  - '\"gdm\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-88733-1\n  - CJIS-5.5.5\n  - NIST-800-171-3.1.10\n  - NIST-800-53-AC-11(1)\n  - NIST-800-53-AC-11(1).1\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.8\n  - dconf_gnome_screensaver_mode_blank\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_dconf_gnome_session_idle_user_locks": {
			"rule_id": "xccdf_org.ssgproject.content_rule_dconf_gnome_session_idle_user_locks",
			"title": "Ensure Users Cannot Change GNOME3 Session Idle Settings",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-85971-0"
			],
			"references": [
				"1",
				"12",
				"15",
				"16",
				"DSS05.04",
				"DSS05.10",
				"DSS06.10",
				"3.1.10",
				"CCI-000057",
				"CCI-000060",
				"4.3.3.6.1",
				"4.3.3.6.2",
				"4.3.3.6.3",
				"4.3.3.6.4",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.3.6.9",
				"SR 1.1",
				"SR 1.10",
				"SR 1.2",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"A.18.1.4",
				"A.9.2.1",
				"A.9.2.4",
				"A.9.3.1",
				"A.9.4.2",
				"A.9.4.3",
				"CM-6(a)",
				"PR.AC-7",
				"FMT_MOF_EXT.1",
				"SRG-OS-000029-GPOS-00010",
				"SRG-OS-000031-GPOS-00012"
			],
			"description": "If not already configured, ensure that users cannot change GNOME3 session idle settings\nby adding <code>/org/gnome/desktop/session/idle-delay</code>\nto <code>/etc/dconf/db/local.d/locks/00-security-settings-lock</code> to prevent user modification.\nFor example:\n<pre>/org/gnome/desktop/session/idle-delay</pre>\nAfter the settings have been set, run <code>dconf update</code>.",
			"rationale": "A session time-out lock is a temporary action taken when a user stops work and moves away from the immediate\nphysical vicinity of the information system but does not logout because of the temporary nature of the absence.\nRather than relying on the user to manually lock their operating system session prior to vacating the vicinity,\nGNOME desktops can be configured to identify when a user&#x27;s session has idled and take action to initiate the\nsession lock. As such, users should not be allowed to change session settings.",
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-dconf_gnome_session_idle_user_locks:def:1",
			"remediations": [
				{
					"remediation_id": "dconf_gnome_session_idle_user_locks",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q gdm && { [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; }; then\n\n# Check for setting in any of the DConf db directories\nLOCKFILES=$(grep -r \"^/org/gnome/desktop/session/idle-delay$\" \"/etc/dconf/db/\" | grep -v 'distro\\|ibus' | cut -d\":\" -f1)\nLOCKSFOLDER=\"/etc/dconf/db/local.d/locks\"\n\nmkdir -p \"${LOCKSFOLDER}\"\n\nif [[ -z \"${LOCKFILES}\" ]]\nthen\n    echo \"/org/gnome/desktop/session/idle-delay\" >> \"/etc/dconf/db/local.d/locks/00-security-settings-lock\"\nfi\n\ndconf update\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "dconf_gnome_session_idle_user_locks",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "medium",
					"strategy": "unknown",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-85971-0\n  - NIST-800-171-3.1.10\n  - NIST-800-53-CM-6(a)\n  - dconf_gnome_session_idle_user_locks\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n\n- name: Prevent user modification of GNOME Session idle-delay\n  lineinfile:\n    path: /etc/dconf/db/local.d/locks/00-security-settings-lock\n    regexp: ^/org/gnome/desktop/session/idle-delay$\n    line: /org/gnome/desktop/session/idle-delay\n    create: true\n  when:\n  - '\"gdm\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-85971-0\n  - NIST-800-171-3.1.10\n  - NIST-800-53-CM-6(a)\n  - dconf_gnome_session_idle_user_locks\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n\n- name: Dconf Update\n  command: dconf update\n  when:\n  - '\"gdm\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-85971-0\n  - NIST-800-171-3.1.10\n  - NIST-800-53-CM-6(a)\n  - dconf_gnome_session_idle_user_locks\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - unknown_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_ensure_gpgcheck_globally_activated": {
			"rule_id": "xccdf_org.ssgproject.content_rule_ensure_gpgcheck_globally_activated",
			"title": "Ensure gpgcheck Enabled In Main dnf Configuration",
			"result": "pass",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "high",
			"identifiers": [
				"CCE-83457-2"
			],
			"references": [
				"BP28(R15)",
				"11",
				"2",
				"3",
				"9",
				"5.10.4.1",
				"APO01.06",
				"BAI03.05",
				"BAI06.01",
				"BAI10.01",
				"BAI10.02",
				"BAI10.03",
				"BAI10.05",
				"DSS06.02",
				"3.4.8",
				"CCI-001749",
				"164.308(a)(1)(ii)(D)",
				"164.312(b)",
				"164.312(c)(1)",
				"164.312(c)(2)",
				"164.312(e)(2)(i)",
				"4.3.4.3.2",
				"4.3.4.3.3",
				"4.3.4.4.4",
				"SR 3.1",
				"SR 3.3",
				"SR 3.4",
				"SR 3.8",
				"SR 7.6",
				"A.11.2.4",
				"A.12.1.2",
				"A.12.2.1",
				"A.12.5.1",
				"A.12.6.2",
				"A.14.1.2",
				"A.14.1.3",
				"A.14.2.2",
				"A.14.2.3",
				"A.14.2.4",
				"CM-5(3)",
				"SI-7",
				"SC-12",
				"SC-12(3)",
				"CM-6(a)",
				"SA-12",
				"SA-12(10)",
				"CM-11(a)",
				"CM-11(b)",
				"PR.DS-6",
				"PR.DS-8",
				"PR.IP-1",
				"FPT_TUD_EXT.1",
				"FPT_TUD_EXT.2",
				"Req-6.2",
				"SRG-OS-000366-GPOS-00153",
				"SRG-OS-000366-VMM-001430",
				"SRG-OS-000370-VMM-001460",
				"SRG-OS-000404-VMM-001650"
			],
			"description": "The <code>gpgcheck</code> option controls whether\nRPM packages&#x27; signatures are always checked prior to installation.\nTo configure dnf to check package signatures before installing\nthem, ensure the following line appears in <code>/etc/dnf/dnf.conf</code> in\nthe <code>[main]</code> section:\n<pre>gpgcheck=1</pre>",
			"rationale": "Changes to any software components can have significant effects on the\noverall security of the operating system. This requirement ensures the\nsoftware has not been tampered with and that it has been provided by a\ntrusted vendor.\n<br>\nAccordingly, patches, service packs, device drivers, or operating system\ncomponents must be signed with a certificate recognized and approved by the\norganization.\n<br>Verifying the authenticity of the software prior to installation\nvalidates the integrity of the patch or upgrade received from a vendor.\nThis ensures the software has not been tampered with and that it has been\nprovided by a trusted vendor. Self-signed certificates are disallowed by\nthis requirement. Certificates used to verify the software must be from an\napproved Certificate Authority (CA).",
			"platforms": [
				"#yum"
			],
			"oval_definition_id": "oval:ssg-ensure_gpgcheck_globally_activated:def:1",
			"remediations": [
				{
					"remediation_id": "ensure_gpgcheck_globally_activated",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q yum; then\n\n# Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed.\n# Otherwise, regular sed command will do.\nsed_command=('sed' '-i')\nif test -L \"/etc/dnf/dnf.conf\"; then\n    sed_command+=('--follow-symlinks')\nfi\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^gpgcheck\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"1\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^gpgcheck\\\\>\" \"/etc/dnf/dnf.conf\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    \"${sed_command[@]}\" \"s/^gpgcheck\\\\>.*/$escaped_formatted_output/gi\" \"/etc/dnf/dnf.conf\"\nelse\n    # \\n is precaution for case where file ends without trailing newline\n    cce=\"CCE-83457-2\"\n    printf '\\n# Per %s: Set %s in %s\\n' \"$cce\" \"$formatted_output\" \"/etc/dnf/dnf.conf\" >> \"/etc/dnf/dnf.conf\"\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/dnf/dnf.conf\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "ensure_gpgcheck_globally_activated",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "medium",
					"strategy": "configure",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83457-2\n  - CJIS-5.10.4.1\n  - NIST-800-171-3.4.8\n  - NIST-800-53-CM-11(a)\n  - NIST-800-53-CM-11(b)\n  - NIST-800-53-CM-5(3)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SA-12\n  - NIST-800-53-SA-12(10)\n  - NIST-800-53-SC-12\n  - NIST-800-53-SC-12(3)\n  - NIST-800-53-SI-7\n  - PCI-DSS-Req-6.2\n  - configure_strategy\n  - ensure_gpgcheck_globally_activated\n  - high_severity\n  - low_complexity\n  - medium_disruption\n  - no_reboot_needed\n\n- name: Ensure GPG check is globally activated\n  ini_file:\n    dest: /etc/dnf/dnf.conf\n    section: main\n    option: gpgcheck\n    value: 1\n    no_extra_spaces: true\n    create: false\n  when: '\"yum\" in ansible_facts.packages'\n  tags:\n  - CCE-83457-2\n  - CJIS-5.10.4.1\n  - NIST-800-171-3.4.8\n  - NIST-800-53-CM-11(a)\n  - NIST-800-53-CM-11(b)\n  - NIST-800-53-CM-5(3)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SA-12\n  - NIST-800-53-SA-12(10)\n  - NIST-800-53-SC-12\n  - NIST-800-53-SC-12(3)\n  - NIST-800-53-SI-7\n  - PCI-DSS-Req-6.2\n  - configure_strategy\n  - ensure_gpgcheck_globally_activated\n  - high_severity\n  - low_complexity\n  - medium_disruption\n  - no_reboot_needed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_ensure_gpgcheck_never_disabled": {
			"rule_id": "xccdf_org.ssgproject.content_rule_ensure_gpgcheck_never_disabled",
			"title": "Ensure gpgcheck Enabled for All dnf Package Repositories",
			"result": "pass",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "high",
			"identifiers": [
				"CCE-83464-8"
			],
			"references": [
				"BP28(R15)",
				"11",
				"2",
				"3",
				"9",
				"5.10.4.1",
				"APO01.06",
				"BAI03.05",
				"BAI06.01",
				"BAI10.01",
				"BAI10.02",
				"BAI10.03",
				"BAI10.05",
				"DSS06.02",
				"3.4.8",
				"CCI-001749",
				"164.308(a)(1)(ii)(D)",
				"164.312(b)",
				"164.312(c)(1)",
				"164.312(c)(2)",
				"164.312(e)(2)(i)",
				"4.3.4.3.2",
				"4.3.4.3.3",
				"4.3.4.4.4",
				"SR 3.1",
				"SR 3.3",
				"SR 3.4",
				"SR 3.8",
				"SR 7.6",
				"A.11.2.4",
				"A.12.1.2",
				"A.12.2.1",
				"A.12.5.1",
				"A.12.6.2",
				"A.14.1.2",
				"A.14.1.3",
				"A.14.2.2",
				"A.14.2.3",
				"A.14.2.4",
				"CM-5(3)",
				"SI-7",
				"SC-12",
				"SC-12(3)",
				"CM-6(a)",
				"SA-12",
				"SA-12(10)",
				"CM-11(a)",
				"CM-11(b)",
				"PR.DS-6",
				"PR.DS-8",
				"PR.IP-1",
				"FPT_TUD_EXT.1",
				"FPT_TUD_EXT.2",
				"Req-6.2",
				"SRG-OS-000366-GPOS-00153",
				"SRG-OS-000366-VMM-001430",
				"SRG-OS-000370-VMM-001460",
				"SRG-OS-000404-VMM-001650"
			],
			"description": "To ensure signature checking is not disabled for\nany repos, remove any lines from files in <code>/etc/yum.repos.d</code> of the form:\n<pre>gpgcheck=0</pre>",
			"rationale": "Verifying the authenticity of the software prior to installation validates\nthe integrity of the patch or upgrade received from a vendor. This ensures\nthe software has not been tampered with and that it has been provided by a\ntrusted vendor. Self-signed certificates are disallowed by this\nrequirement. Certificates used to verify the software must be from an\napproved Certificate Authority (CA).&quot;",
			"oval_definition_id": "oval:ssg-ensure_gpgcheck_never_disabled:def:1",
			"remediations": [
				{
					"remediation_id": "ensure_gpgcheck_never_disabled",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "\nsed -i 's/gpgcheck\\s*=.*/gpgcheck=1/g' /etc/yum.repos.d/*\n"
				},
				{
					"remediation_id": "ensure_gpgcheck_never_disabled",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "medium",
					"strategy": "enable",
					"fix": "- name: Grep for dnf repo section names\n  shell: |\n    set -o pipefail\n    grep -HEr '^\\[.+\\]' -r /etc/yum.repos.d/\n  register: repo_grep_results\n  ignore_errors: true\n  changed_when: false\n  tags:\n  - CCE-83464-8\n  - CJIS-5.10.4.1\n  - NIST-800-171-3.4.8\n  - NIST-800-53-CM-11(a)\n  - NIST-800-53-CM-11(b)\n  - NIST-800-53-CM-5(3)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SA-12\n  - NIST-800-53-SA-12(10)\n  - NIST-800-53-SC-12\n  - NIST-800-53-SC-12(3)\n  - NIST-800-53-SI-7\n  - PCI-DSS-Req-6.2\n  - enable_strategy\n  - ensure_gpgcheck_never_disabled\n  - high_severity\n  - low_complexity\n  - medium_disruption\n  - no_reboot_needed\n\n- name: Set gpgcheck=1 for each dnf repo\n  ini_file:\n    path: '{{ item[0] }}'\n    section: '{{ item[1] }}'\n    option: gpgcheck\n    value: '1'\n    no_extra_spaces: true\n  loop: '{{ repo_grep_results.stdout | regex_findall( ''(.+\\.repo):\\[(.+)\\]\\n?'' )\n    }}'\n  tags:\n  - CCE-83464-8\n  - CJIS-5.10.4.1\n  - NIST-800-171-3.4.8\n  - NIST-800-53-CM-11(a)\n  - NIST-800-53-CM-11(b)\n  - NIST-800-53-CM-5(3)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SA-12\n  - NIST-800-53-SA-12(10)\n  - NIST-800-53-SC-12\n  - NIST-800-53-SC-12(3)\n  - NIST-800-53-SI-7\n  - PCI-DSS-Req-6.2\n  - enable_strategy\n  - ensure_gpgcheck_never_disabled\n  - high_severity\n  - low_complexity\n  - medium_disruption\n  - no_reboot_needed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_ensure_redhat_gpgkey_installed": {
			"rule_id": "xccdf_org.ssgproject.content_rule_ensure_redhat_gpgkey_installed",
			"title": "Ensure Red Hat GPG Key Installed",
			"result": "pass",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "high",
			"identifiers": [
				"CCE-84180-9"
			],
			"references": [
				"BP28(R15)",
				"11",
				"2",
				"3",
				"9",
				"5.10.4.1",
				"APO01.06",
				"BAI03.05",
				"BAI06.01",
				"BAI10.01",
				"BAI10.02",
				"BAI10.03",
				"BAI10.05",
				"DSS06.02",
				"3.4.8",
				"CCI-001749",
				"164.308(a)(1)(ii)(D)",
				"164.312(b)",
				"164.312(c)(1)",
				"164.312(c)(2)",
				"164.312(e)(2)(i)",
				"4.3.4.3.2",
				"4.3.4.3.3",
				"4.3.4.4.4",
				"SR 3.1",
				"SR 3.3",
				"SR 3.4",
				"SR 3.8",
				"SR 7.6",
				"A.11.2.4",
				"A.12.1.2",
				"A.12.2.1",
				"A.12.5.1",
				"A.12.6.2",
				"A.14.1.2",
				"A.14.1.3",
				"A.14.2.2",
				"A.14.2.3",
				"A.14.2.4",
				"CIP-003-8 R4.2",
				"CIP-003-8 R6",
				"CIP-007-3 R4",
				"CIP-007-3 R4.1",
				"CIP-007-3 R4.2",
				"CIP-007-3 R5.1",
				"CM-5(3)",
				"SI-7",
				"SC-12",
				"SC-12(3)",
				"CM-6(a)",
				"PR.DS-6",
				"PR.DS-8",
				"PR.IP-1",
				"FPT_TUD_EXT.1",
				"FPT_TUD_EXT.2",
				"Req-6.2",
				"SRG-OS-000366-GPOS-00153",
				"SRG-OS-000366-VMM-001430",
				"SRG-OS-000370-VMM-001460",
				"SRG-OS-000404-VMM-001650"
			],
			"description": "To ensure the system can cryptographically verify base software packages\ncome from Red Hat (and to connect to the Red Hat Network to receive them),\nthe Red Hat GPG key must properly be installed. To install the Red Hat GPG\nkey, run:\n<pre>$ sudo subscription-manager register</pre>\n\nIf the system is not connected to the Internet or an RHN Satellite, then\ninstall the Red Hat GPG key from trusted media such as the Red Hat\ninstallation CD-ROM or DVD. Assuming the disc is mounted in\n<code>/media/cdrom</code>, use the following command as the root user to import\nit into the keyring:\n<pre>$ sudo rpm --import /media/cdrom/RPM-GPG-KEY</pre>\n\nAlternatively, the key may be pre-loaded during the RHEL installation. In\nsuch cases, the key can be installed by running the following command:\n<pre>sudo rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release</pre>",
			"rationale": "Changes to software components can have significant effects on the overall\nsecurity of the operating system. This requirement ensures the software has\nnot been tampered with and that it has been provided by a trusted vendor.\nThe Red Hat GPG key is necessary to cryptographically verify packages are\nfrom Red Hat.",
			"oval_definition_id": "oval:ssg-ensure_redhat_gpgkey_installed:def:1",
			"remediations": [
				{
					"remediation_id": "ensure_redhat_gpgkey_installed",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# The two fingerprints below are retrieved from https://access.redhat.com/security/team/key\nreadonly REDHAT_RELEASE_FINGERPRINT=\"567E347AD0044ADE55BA8A5F199E2F91FD431D51\"\nreadonly REDHAT_AUXILIARY_FINGERPRINT=\"7E4624258C406535D56D6F135054E4A45A6340B3\"\n\n# Location of the key we would like to import (once it's integrity verified)\nreadonly REDHAT_RELEASE_KEY=\"/etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release\"\n\nRPM_GPG_DIR_PERMS=$(stat -c %a \"$(dirname \"$REDHAT_RELEASE_KEY\")\")\n\n# Verify /etc/pki/rpm-gpg directory permissions are safe\nif [ \"${RPM_GPG_DIR_PERMS}\" -le \"755\" ]\nthen\n  # If they are safe, try to obtain fingerprints from the key file\n  # (to ensure there won't be e.g. CRC error).\n\n  readarray -t GPG_OUT < <(gpg --show-keys --with-fingerprint --with-colons \"$REDHAT_RELEASE_KEY\" | grep -A1 \"^pub\" | grep \"^fpr\" | cut -d \":\" -f 10)\n\n  GPG_RESULT=$?\n  # No CRC error, safe to proceed\n  if [ \"${GPG_RESULT}\" -eq \"0\" ]\n  then\n    echo \"${GPG_OUT[*]}\" | grep -vE \"${REDHAT_RELEASE_FINGERPRINT}|${REDHAT_AUXILIARY_FINGERPRINT}\" || {\n      # If $REDHAT_RELEASE_KEY file doesn't contain any keys with unknown fingerprint, import it\n      rpm --import \"${REDHAT_RELEASE_KEY}\"\n    }\n  fi\nfi\n"
				},
				{
					"remediation_id": "ensure_redhat_gpgkey_installed",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "medium",
					"disruption": "medium",
					"strategy": "restrict",
					"fix": "- name: Read permission of GPG key directory\n  stat:\n    path: /etc/pki/rpm-gpg/\n  register: gpg_key_directory_permission\n  check_mode: false\n  tags:\n  - CCE-84180-9\n  - CJIS-5.10.4.1\n  - NIST-800-171-3.4.8\n  - NIST-800-53-CM-5(3)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-12\n  - NIST-800-53-SC-12(3)\n  - NIST-800-53-SI-7\n  - PCI-DSS-Req-6.2\n  - ensure_redhat_gpgkey_installed\n  - high_severity\n  - medium_complexity\n  - medium_disruption\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Read signatures in GPG key\n  command: gpg --show-keys --with-fingerprint --with-colons \"/etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release\"\n  args:\n    warn: false\n  changed_when: false\n  register: gpg_fingerprints\n  check_mode: false\n  tags:\n  - CCE-84180-9\n  - CJIS-5.10.4.1\n  - NIST-800-171-3.4.8\n  - NIST-800-53-CM-5(3)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-12\n  - NIST-800-53-SC-12(3)\n  - NIST-800-53-SI-7\n  - PCI-DSS-Req-6.2\n  - ensure_redhat_gpgkey_installed\n  - high_severity\n  - medium_complexity\n  - medium_disruption\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set Fact - Installed GPG Fingerprints\n  set_fact:\n    gpg_installed_fingerprints: |-\n      {{ gpg_fingerprints.stdout | regex_findall('^pub.*\n      (?:^fpr[:]*)([0-9A-Fa-f]*)', '\\1') | list }}\n  tags:\n  - CCE-84180-9\n  - CJIS-5.10.4.1\n  - NIST-800-171-3.4.8\n  - NIST-800-53-CM-5(3)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-12\n  - NIST-800-53-SC-12(3)\n  - NIST-800-53-SI-7\n  - PCI-DSS-Req-6.2\n  - ensure_redhat_gpgkey_installed\n  - high_severity\n  - medium_complexity\n  - medium_disruption\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set Fact - Valid fingerprints\n  set_fact:\n    gpg_valid_fingerprints: (\"567E347AD0044ADE55BA8A5F199E2F91FD431D51\" \"7E4624258C406535D56D6F135054E4A45A6340B3\")\n  tags:\n  - CCE-84180-9\n  - CJIS-5.10.4.1\n  - NIST-800-171-3.4.8\n  - NIST-800-53-CM-5(3)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-12\n  - NIST-800-53-SC-12(3)\n  - NIST-800-53-SI-7\n  - PCI-DSS-Req-6.2\n  - ensure_redhat_gpgkey_installed\n  - high_severity\n  - medium_complexity\n  - medium_disruption\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Import RedHat GPG key\n  rpm_key:\n    state: present\n    key: /etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release\n  when:\n  - gpg_key_directory_permission.stat.mode <= '0755'\n  - (gpg_installed_fingerprints | difference(gpg_valid_fingerprints)) | length ==\n    0\n  - gpg_installed_fingerprints | length > 0\n  - ansible_distribution == \"RedHat\"\n  tags:\n  - CCE-84180-9\n  - CJIS-5.10.4.1\n  - NIST-800-171-3.4.8\n  - NIST-800-53-CM-5(3)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SC-12\n  - NIST-800-53-SC-12(3)\n  - NIST-800-53-SI-7\n  - PCI-DSS-Req-6.2\n  - ensure_redhat_gpgkey_installed\n  - high_severity\n  - medium_complexity\n  - medium_disruption\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_security_patches_up_to_date": {
			"rule_id": "xccdf_org.ssgproject.content_rule_security_patches_up_to_date",
			"title": "Ensure Software Patches Installed",
			"result": "notchecked",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-84185-8"
			],
			"references": [
				"BP28(R08)",
				"18",
				"20",
				"4",
				"5.10.4.1",
				"APO12.01",
				"APO12.02",
				"APO12.03",
				"APO12.04",
				"BAI03.10",
				"DSS05.01",
				"DSS05.02",
				"CCI-000366",
				"CCI-001227",
				"4.2.3",
				"4.2.3.12",
				"4.2.3.7",
				"4.2.3.9",
				"A.12.6.1",
				"A.14.2.3",
				"A.16.1.3",
				"A.18.2.2",
				"A.18.2.3",
				"SI-2(5)",
				"SI-2(c)",
				"CM-6(a)",
				"ID.RA-1",
				"PR.IP-12",
				"FMT_MOF_EXT.1",
				"Req-6.2",
				"SRG-OS-000480-GPOS-00227",
				"SRG-OS-000480-VMM-002000"
			],
			"description": "<br><br>\nNOTE: U.S. Defense systems are required to be patched within 30 days or sooner as local policy\ndictates.",
			"rationale": "Installing software updates is a fundamental mitigation against\nthe exploitation of publicly-known vulnerabilities. If the most\nrecent security patches and updates are not installed, unauthorized\nusers may take advantage of weaknesses in the unpatched software. The\nlack of prompt attention to patching could result in a system compromise.",
			"warnings": [
				{
					"text": "The OVAL feed of Red Hat Enterprise Linux 9 is not a XML file, which may not be understood by all scanners.",
					"category": "general"
				}
			],
			"messages": [
				"None of the check-content-ref elements was resolvable."
			],
			"remediations": [
				{
					"remediation_id": "security_patches_up_to_date",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "high",
					"strategy": "patch",
					"fix": "\n\nyum -y update\n"
				},
				{
					"remediation_id": "security_patches_up_to_date",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "high",
					"strategy": "patch",
					"fix": "- name: Security patches are up to date\n  package:\n    name: '*'\n    state: latest\n  tags:\n  - CCE-84185-8\n  - CJIS-5.10.4.1\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SI-2(5)\n  - NIST-800-53-SI-2(c)\n  - PCI-DSS-Req-6.2\n  - high_disruption\n  - low_complexity\n  - medium_severity\n  - patch_strategy\n  - reboot_required\n  - security_patches_up_to_date\n  - skip_ansible_lint\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_enable_authselect": {
			"rule_id": "xccdf_org.ssgproject.content_rule_enable_authselect",
			"title": "Enable authselect",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-89732-2"
			],
			"references": [
				"BP28(R5)",
				"CCI-000213",
				"164.308(a)(1)(ii)(B)",
				"164.308(a)(7)(i)",
				"164.308(a)(7)(ii)(A)",
				"164.310(a)(1)",
				"164.310(a)(2)(i)",
				"164.310(a)(2)(ii)",
				"164.310(a)(2)(iii)",
				"164.310(b)",
				"164.310(c)",
				"164.310(d)(1)",
				"164.310(d)(2)(iii)",
				"AC-3",
				"FIA_UAU.1",
				"FIA_AFL.1",
				"SRG-OS-000480-GPOS-00227"
			],
			"description": "Configure user authentication setup to use the <code>authselect</code> tool.\n\nIf authselect profile is selected, the rule will enable the sssd profile.",
			"rationale": "Authselect is a successor to authconfig.\nIt is a tool to select system authentication and identity sources from a list of supported profiles\ninstead of letting the administrator build the PAM stack with a tool.\n\nThat way, it avoids potential breakage of configuration,\nas it ships several tested profiles that are well tested and supported and that each solve a use-case.",
			"oval_definition_id": "oval:ssg-enable_authselect:def:1",
			"remediations": [
				{
					"remediation_id": "enable_authselect",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "\nvar_authselect_profile='sssd'\n\n\nauthselect select \"$var_authselect_profile\"\n\nif test \"$?\" -ne 0; then\n    if rpm --quiet --verify pam; then\n        authselect select --force \"$var_authselect_profile\"\n    else\n\techo \"Files in the 'pam' package have been altered, so the authselect configuration won't be forced\" >&2\n    fi\nfi\n"
				},
				{
					"remediation_id": "enable_authselect",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "medium",
					"strategy": "configure",
					"fix": "- name: XCCDF Value var_authselect_profile # promote to variable\n  set_fact:\n    var_authselect_profile: !!str sssd\n  tags:\n    - always\n\n- name: Select authselect profile\n  ansible.builtin.command:\n    cmd: authselect select \"{{ var_authselect_profile }}\"\n  ignore_errors: true\n  register: result_authselect_select\n  tags:\n  - CCE-89732-2\n  - NIST-800-53-AC-3\n  - configure_strategy\n  - enable_authselect\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Verify if PAM has been altered\n  ansible.builtin.command:\n    cmd: rpm -qV pam\n  register: result_altered_authselect\n  ignore_errors: true\n  args:\n    warn: false\n  when: result_authselect_select is failed\n  tags:\n  - CCE-89732-2\n  - NIST-800-53-AC-3\n  - configure_strategy\n  - enable_authselect\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Informative message based on the authselect integrity check\n  ansible.builtin.assert:\n    that:\n    - result_altered_authselect is success\n    fail_msg:\n    - Files in the 'pam' package have been altered, so the authselect configuration\n      won't be forced.\n  tags:\n  - CCE-89732-2\n  - NIST-800-53-AC-3\n  - configure_strategy\n  - enable_authselect\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Force authselect profile select\n  ansible.builtin.command:\n    cmd: authselect select --force \"{{ var_authselect_profile }}\"\n  when:\n  - result_altered_authselect is success\n  - result_authselect_select is failed\n  tags:\n  - CCE-89732-2\n  - NIST-800-53-AC-3\n  - configure_strategy\n  - enable_authselect\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_display_login_attempts": {
			"rule_id": "xccdf_org.ssgproject.content_rule_display_login_attempts",
			"title": "Ensure PAM Displays Last Logon/Access Notification",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "low",
			"identifiers": [
				"CCE-83560-3"
			],
			"references": [
				"1",
				"12",
				"15",
				"16",
				"5.5.2",
				"DSS05.04",
				"DSS05.10",
				"DSS06.10",
				"CCI-000366",
				"4.3.3.6.1",
				"4.3.3.6.2",
				"4.3.3.6.3",
				"4.3.3.6.4",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.3.6.9",
				"SR 1.1",
				"SR 1.10",
				"SR 1.2",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"0582",
				"0584",
				"05885",
				"0586",
				"0846",
				"0957",
				"A.18.1.4",
				"A.9.2.1",
				"A.9.2.4",
				"A.9.3.1",
				"A.9.4.2",
				"A.9.4.3",
				"AC-9(1)",
				"CM-6(a)",
				"PR.AC-7",
				"Req-10.2.4",
				"SRG-OS-000480-GPOS-00227"
			],
			"description": "To configure the system to notify users of last logon/access\nusing <code>pam_lastlog</code>, add or correct the <code>pam_lastlog</code>\nsettings in\n<code>/etc/pam.d/postlogin</code> to read as follows:\n<pre>session     required pam_lastlog.so showfailed</pre>\nAnd make sure that the <code>silent</code> option is not set for\n<code>pam_lastlog</code> module.",
			"rationale": "Users need to be aware of activity that occurs regarding\ntheir account. Providing users with information regarding the number\nof unsuccessful attempts that were made to login to their account\nallows the user to determine if any unauthorized activity has occurred\nand gives them an opportunity to notify administrators.",
			"platforms": [
				"#pam"
			],
			"oval_definition_id": "oval:ssg-display_login_attempts:def:1",
			"remediations": [
				{
					"remediation_id": "display_login_attempts",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q pam; then\n\nif [ -e \"/etc/pam.d/postlogin\" ] ; then\n    PAM_FILE_PATH=\"/etc/pam.d/postlogin\"\n    if [ -f /usr/bin/authselect ]; then\n        if ! authselect check; then\n        echo \"\n        authselect integrity check failed. Remediation aborted!\n        This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\n        It is not recommended to manually edit the PAM files when authselect tool is available.\n        In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\n        exit 1\n        fi\n        CURRENT_PROFILE=$(authselect current -r | awk '{ print $1 }')\n        # If not already in use, a custom profile is created preserving the enabled features.\n        if [[ ! $CURRENT_PROFILE == custom/* ]]; then\n            ENABLED_FEATURES=$(authselect current | tail -n+3 | awk '{ print $2 }')\n            authselect create-profile hardening -b $CURRENT_PROFILE\n            CURRENT_PROFILE=\"custom/hardening\"\n            \n            authselect apply-changes -b --backup=before-hardening-custom-profile\n            authselect select $CURRENT_PROFILE\n            for feature in $ENABLED_FEATURES; do\n                authselect enable-feature $feature;\n            done\n            \n            authselect apply-changes -b --backup=after-hardening-custom-profile\n        fi\n        PAM_FILE_NAME=$(basename \"/etc/pam.d/postlogin\")\n        PAM_FILE_PATH=\"/etc/authselect/$CURRENT_PROFILE/$PAM_FILE_NAME\"\n        \n        authselect apply-changes -b\n    fi\n    if ! grep -qP '^\\s*session\\s+'\"required\"'\\s+pam_lastlog.so\\s*.*' \"$PAM_FILE_PATH\"; then\n            # Line matching group + control + module was not found. Check group + module.\n            if [ \"$(grep -cP '^\\s*session\\s+.*\\s+pam_lastlog.so\\s*' \"$PAM_FILE_PATH\")\" -eq 1 ]; then\n                # The control is updated only if one single line matches.\n                sed -i -E --follow-symlinks 's/^(\\s*session\\s+).*(\\bpam_lastlog.so.*)/\\1'\"required\"' \\2/' \"$PAM_FILE_PATH\"\n            else\n                sed -i --follow-symlinks '1i session     '\"required\"'    pam_lastlog.so' \"$PAM_FILE_PATH\"\n            fi\n        fi\n        # Check the option\n        if ! grep -qP '^\\s*session\\s+'\"required\"'\\s+pam_lastlog.so\\s*.*\\sshowfailed\\b' \"$PAM_FILE_PATH\"; then\n            sed -i -E --follow-symlinks '/\\s*session\\s+'\"required\"'\\s+pam_lastlog.so.*/ s/$/ showfailed/' \"$PAM_FILE_PATH\"\n        fi\n    if [ -f /usr/bin/authselect ]; then\n        \n        authselect apply-changes -b\n    fi\nelse\n    echo \"/etc/pam.d/postlogin was not found\" >&2\nfi\nif [ -e \"/etc/pam.d/postlogin\" ] ; then\n    PAM_FILE_PATH=\"/etc/pam.d/postlogin\"\n    if [ -f /usr/bin/authselect ]; then\n        if ! authselect check; then\n            echo \"\n            authselect integrity check failed. Remediation aborted!\n            This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\n            It is not recommended to manually edit the PAM files when authselect tool is available.\n            In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\n            exit 1\n            fi\n        CURRENT_PROFILE=$(authselect current -r | awk '{ print $1 }')\n        # If not already in use, a custom profile is created preserving the enabled features.\n        if [[ ! $CURRENT_PROFILE == custom/* ]]; then\n            ENABLED_FEATURES=$(authselect current | tail -n+3 | awk '{ print $2 }')\n            authselect create-profile hardening -b $CURRENT_PROFILE\n            CURRENT_PROFILE=\"custom/hardening\"\n            \n            authselect apply-changes -b --backup=before-hardening-custom-profile\n            authselect select $CURRENT_PROFILE\n            for feature in $ENABLED_FEATURES; do\n                authselect enable-feature $feature;\n            done\n            \n            authselect apply-changes -b --backup=after-hardening-custom-profile\n        fi\n        PAM_FILE_NAME=$(basename \"/etc/pam.d/postlogin\")\n        PAM_FILE_PATH=\"/etc/authselect/$CURRENT_PROFILE/$PAM_FILE_NAME\"\n        \n        authselect apply-changes -b\n    fi\n    \nif grep -qP '^\\s*session\\s.*\\bpam_lastlog.so\\s.*\\bsilent\\b' \"$PAM_FILE_PATH\"; then\n    sed -i -E --follow-symlinks 's/(.*session.*pam_lastlog.so.*)\\bsilent\\b=?[[:alnum:]]*(.*)/\\1\\2/g' \"$PAM_FILE_PATH\"\nfi\n    if [ -f /usr/bin/authselect ]; then\n        \n        authselect apply-changes -b\n    fi\nelse\n    echo \"/etc/pam.d/postlogin was not found\" >&2\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "display_login_attempts",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83560-3\n  - CJIS-5.5.2\n  - NIST-800-53-AC-9(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.4\n  - configure_strategy\n  - display_login_attempts\n  - low_complexity\n  - low_disruption\n  - low_severity\n  - no_reboot_needed\n\n- name: Ensure PAM Displays Last Logon/Access Notification - Check if /etc/pam.d/postlogin\n    file is present\n  ansible.builtin.stat:\n    path: /etc/pam.d/postlogin\n  register: result_pam_file_present\n  when: '\"pam\" in ansible_facts.packages'\n  tags:\n  - CCE-83560-3\n  - CJIS-5.5.2\n  - NIST-800-53-AC-9(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.4\n  - configure_strategy\n  - display_login_attempts\n  - low_complexity\n  - low_disruption\n  - low_severity\n  - no_reboot_needed\n\n- name: Ensure PAM Displays Last Logon/Access Notification - Check the proper remediation\n    for the system\n  block:\n\n  - name: Ensure PAM Displays Last Logon/Access Notification - Define the PAM file\n      to be edited as a local fact\n    ansible.builtin.set_fact:\n      pam_file_path: /etc/pam.d/postlogin\n\n  - name: Ensure PAM Displays Last Logon/Access Notification - Check if system relies\n      on authselect\n    ansible.builtin.stat:\n      path: /usr/bin/authselect\n    register: result_authselect_present\n\n  - name: Ensure PAM Displays Last Logon/Access Notification - Remediate using authselect\n    block:\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Check integrity of\n        authselect current profile\n      ansible.builtin.command:\n        cmd: authselect check\n      register: result_authselect_check_cmd\n      changed_when: false\n      ignore_errors: true\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Informative message\n        based on the authselect integrity check result\n      ansible.builtin.assert:\n        that:\n        - result_authselect_check_cmd is success\n        fail_msg:\n        - authselect integrity check failed. Remediation aborted!\n        - This remediation could not be applied because an authselect profile was\n          not selected or the selected profile is not intact.\n        - It is not recommended to manually edit the PAM files when authselect tool\n          is available.\n        - In cases where the default authselect profile does not cover a specific\n          demand, a custom authselect profile is recommended.\n        success_msg:\n        - authselect integrity check passed\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Get authselect current\n        profile\n      ansible.builtin.shell:\n        cmd: authselect current -r | awk '{ print $1 }'\n      register: result_authselect_profile\n      changed_when: false\n      when:\n      - result_authselect_check_cmd is success\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Define the current\n        authselect profile as a local fact\n      ansible.builtin.set_fact:\n        authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n        authselect_custom_profile: '{{ result_authselect_profile.stdout }}'\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_profile.stdout is match(\"custom/\")\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Define the new authselect\n        custom profile as a local fact\n      ansible.builtin.set_fact:\n        authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n        authselect_custom_profile: custom/hardening\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_profile.stdout is not match(\"custom/\")\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Get authselect current\n        features to also enable them in the custom profile\n      ansible.builtin.shell:\n        cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n      register: result_authselect_features\n      changed_when: false\n      when:\n      - result_authselect_profile is not skipped\n      - authselect_current_profile is not match(\"custom/\")\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Check if any custom\n        profile with the same name was already created\n      ansible.builtin.stat:\n        path: /etc/authselect/{{ authselect_custom_profile }}\n      register: result_authselect_custom_profile_present\n      changed_when: false\n      when:\n      - authselect_current_profile is not match(\"custom/\")\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Create an authselect\n        custom profile based on the current profile\n      ansible.builtin.command:\n        cmd: authselect create-profile hardening -b {{ authselect_current_profile\n          }}\n      when:\n      - result_authselect_check_cmd is success\n      - authselect_current_profile is not match(\"custom/\")\n      - not result_authselect_custom_profile_present.stat.exists\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Ensure authselect\n        changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b --backup=before-hardening-custom-profile\n      when:\n      - result_authselect_check_cmd is success\n      - result_authselect_profile is not skipped\n      - authselect_current_profile is not match(\"custom/\")\n      - authselect_custom_profile is not match(authselect_current_profile)\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Ensure the authselect\n        custom profile is selected\n      ansible.builtin.command:\n        cmd: authselect select {{ authselect_custom_profile }}\n      register: result_pam_authselect_select_profile\n      when:\n      - result_authselect_check_cmd is success\n      - result_authselect_profile is not skipped\n      - authselect_current_profile is not match(\"custom/\")\n      - authselect_custom_profile is not match(authselect_current_profile)\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Restore the authselect\n        features in the custom profile\n      ansible.builtin.command:\n        cmd: authselect enable-feature {{ item }}\n      loop: '{{ result_authselect_features.stdout_lines }}'\n      register: result_pam_authselect_restore_features\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_features is not skipped\n      - result_pam_authselect_select_profile is not skipped\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Ensure authselect\n        changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b --backup=after-hardening-custom-profile\n      when:\n      - result_authselect_check_cmd is success\n      - result_authselect_profile is not skipped\n      - result_pam_authselect_restore_features is not skipped\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Change the PAM file\n        to be edited according to the custom authselect profile\n      ansible.builtin.set_fact:\n        pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path\n          | basename }}\n    when:\n    - result_authselect_present.stat.exists\n\n  - name: Ensure PAM Displays Last Logon/Access Notification - Check if expected PAM\n      module line is present in {{ pam_file_path }}\n    ansible.builtin.lineinfile:\n      path: '{{ pam_file_path }}'\n      regexp: ^\\s*session\\s+required\\s+pam_lastlog.so\\s*.*\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_line_present\n\n  - name: Ensure PAM Displays Last Logon/Access Notification - Include or update the\n      PAM module line in {{ pam_file_path }}\n    block:\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Check if required\n        PAM module line is present in {{ pam_file_path }} with different control\n      ansible.builtin.lineinfile:\n        path: '{{ pam_file_path }}'\n        regexp: ^\\s*session\\s+.*\\s+pam_lastlog.so\\s*\n        state: absent\n      check_mode: true\n      changed_when: false\n      register: result_pam_line_other_control_present\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Ensure the correct\n        control for the required PAM module line in {{ pam_file_path }}\n      ansible.builtin.replace:\n        dest: '{{ pam_file_path }}'\n        regexp: ^(\\s*session\\s+).*(\\bpam_lastlog.so.*)\n        replace: \\1required \\2\n      register: result_pam_module_edit\n      when:\n      - result_pam_line_other_control_present.found == 1\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Ensure the required\n        PAM module line is included in {{ pam_file_path }}\n      ansible.builtin.lineinfile:\n        dest: '{{ pam_file_path }}'\n        insertafter: BOF\n        line: session    required    pam_lastlog.so\n      register: result_pam_module_add\n      when:\n      - result_pam_line_other_control_present.found == 0 or result_pam_line_other_control_present.found\n        > 1\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Ensure authselect\n        changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b\n      when:\n      - result_authselect_present.stat.exists\n      - (result_pam_module_add is defined and result_pam_module_add.changed) or (result_pam_module_edit\n        is defined and result_pam_module_edit.changed)\n    when:\n    - result_pam_line_present.found is defined\n    - result_pam_line_present.found == 0\n\n  - name: Ensure PAM Displays Last Logon/Access Notification - Check if the required\n      PAM module option is present in {{ pam_file_path }}\n    ansible.builtin.lineinfile:\n      path: '{{ pam_file_path }}'\n      regexp: ^\\s*session\\s+required\\s+pam_lastlog.so\\s*.*\\sshowfailed\\b\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_module_showfailed_option_present\n\n  - name: Ensure PAM Displays Last Logon/Access Notification - Ensure the \"showfailed\"\n      PAM option for \"pam_lastlog.so\" is included in {{ pam_file_path }}\n    ansible.builtin.lineinfile:\n      path: '{{ pam_file_path }}'\n      backrefs: true\n      regexp: ^(\\s*session\\s+required\\s+pam_lastlog.so.*)\n      line: \\1 showfailed\n      state: present\n    register: result_pam_showfailed_add\n    when:\n    - result_pam_module_showfailed_option_present.found == 0\n\n  - name: Ensure PAM Displays Last Logon/Access Notification - Ensure authselect changes\n      are applied\n    ansible.builtin.command:\n      cmd: authselect apply-changes -b\n    when:\n    - result_authselect_present.stat.exists\n    - (result_pam_showfailed_add is defined and result_pam_showfailed_add.changed)\n      or (result_pam_showfailed_edit is defined and result_pam_showfailed_edit.changed)\n  when:\n  - '\"pam\" in ansible_facts.packages'\n  - result_pam_file_present.stat.exists\n  tags:\n  - CCE-83560-3\n  - CJIS-5.5.2\n  - NIST-800-53-AC-9(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.4\n  - configure_strategy\n  - display_login_attempts\n  - low_complexity\n  - low_disruption\n  - low_severity\n  - no_reboot_needed\n\n- name: Ensure PAM Displays Last Logon/Access Notification - Check if /etc/pam.d/postlogin\n    file is present\n  ansible.builtin.stat:\n    path: /etc/pam.d/postlogin\n  register: result_pam_file_present\n  when: '\"pam\" in ansible_facts.packages'\n  tags:\n  - CCE-83560-3\n  - CJIS-5.5.2\n  - NIST-800-53-AC-9(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.4\n  - configure_strategy\n  - display_login_attempts\n  - low_complexity\n  - low_disruption\n  - low_severity\n  - no_reboot_needed\n\n- name: Ensure PAM Displays Last Logon/Access Notification - Check the proper remediation\n    for the system\n  block:\n\n  - name: Ensure PAM Displays Last Logon/Access Notification - Define the PAM file\n      to be edited as a local fact\n    ansible.builtin.set_fact:\n      pam_file_path: /etc/pam.d/postlogin\n\n  - name: Ensure PAM Displays Last Logon/Access Notification - Check if system relies\n      on authselect\n    ansible.builtin.stat:\n      path: /usr/bin/authselect\n    register: result_authselect_present\n\n  - name: Ensure PAM Displays Last Logon/Access Notification - Remediate using authselect\n    block:\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Check integrity of\n        authselect current profile\n      ansible.builtin.command:\n        cmd: authselect check\n      register: result_authselect_check_cmd\n      changed_when: false\n      ignore_errors: true\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Informative message\n        based on the authselect integrity check result\n      ansible.builtin.assert:\n        that:\n        - result_authselect_check_cmd is success\n        fail_msg:\n        - authselect integrity check failed. Remediation aborted!\n        - This remediation could not be applied because an authselect profile was\n          not selected or the selected profile is not intact.\n        - It is not recommended to manually edit the PAM files when authselect tool\n          is available.\n        - In cases where the default authselect profile does not cover a specific\n          demand, a custom authselect profile is recommended.\n        success_msg:\n        - authselect integrity check passed\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Get authselect current\n        profile\n      ansible.builtin.shell:\n        cmd: authselect current -r | awk '{ print $1 }'\n      register: result_authselect_profile\n      changed_when: false\n      when:\n      - result_authselect_check_cmd is success\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Define the current\n        authselect profile as a local fact\n      ansible.builtin.set_fact:\n        authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n        authselect_custom_profile: '{{ result_authselect_profile.stdout }}'\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_profile.stdout is match(\"custom/\")\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Define the new authselect\n        custom profile as a local fact\n      ansible.builtin.set_fact:\n        authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n        authselect_custom_profile: custom/hardening\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_profile.stdout is not match(\"custom/\")\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Get authselect current\n        features to also enable them in the custom profile\n      ansible.builtin.shell:\n        cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n      register: result_authselect_features\n      changed_when: false\n      when:\n      - result_authselect_profile is not skipped\n      - authselect_current_profile is not match(\"custom/\")\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Check if any custom\n        profile with the same name was already created\n      ansible.builtin.stat:\n        path: /etc/authselect/{{ authselect_custom_profile }}\n      register: result_authselect_custom_profile_present\n      changed_when: false\n      when:\n      - authselect_current_profile is not match(\"custom/\")\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Create an authselect\n        custom profile based on the current profile\n      ansible.builtin.command:\n        cmd: authselect create-profile hardening -b {{ authselect_current_profile\n          }}\n      when:\n      - result_authselect_check_cmd is success\n      - authselect_current_profile is not match(\"custom/\")\n      - not result_authselect_custom_profile_present.stat.exists\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Ensure authselect\n        changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b --backup=before-hardening-custom-profile\n      when:\n      - result_authselect_check_cmd is success\n      - result_authselect_profile is not skipped\n      - authselect_current_profile is not match(\"custom/\")\n      - authselect_custom_profile is not match(authselect_current_profile)\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Ensure the authselect\n        custom profile is selected\n      ansible.builtin.command:\n        cmd: authselect select {{ authselect_custom_profile }}\n      register: result_pam_authselect_select_profile\n      when:\n      - result_authselect_check_cmd is success\n      - result_authselect_profile is not skipped\n      - authselect_current_profile is not match(\"custom/\")\n      - authselect_custom_profile is not match(authselect_current_profile)\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Restore the authselect\n        features in the custom profile\n      ansible.builtin.command:\n        cmd: authselect enable-feature {{ item }}\n      loop: '{{ result_authselect_features.stdout_lines }}'\n      register: result_pam_authselect_restore_features\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_features is not skipped\n      - result_pam_authselect_select_profile is not skipped\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Ensure authselect\n        changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b --backup=after-hardening-custom-profile\n      when:\n      - result_authselect_check_cmd is success\n      - result_authselect_profile is not skipped\n      - result_pam_authselect_restore_features is not skipped\n\n    - name: Ensure PAM Displays Last Logon/Access Notification - Change the PAM file\n        to be edited according to the custom authselect profile\n      ansible.builtin.set_fact:\n        pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path\n          | basename }}\n    when:\n    - result_authselect_present.stat.exists\n\n  - name: Ensure PAM Displays Last Logon/Access Notification - Ensure the \"silent\"\n      option from \"pam_lastlog.so\" is not present in {{ pam_file_path }}\n    ansible.builtin.replace:\n      dest: '{{ pam_file_path }}'\n      regexp: (.*session.*pam_lastlog.so.*)\\bsilent\\b=?[0-9a-zA-Z]*(.*)\n      replace: \\1\\2\n    register: result_pam_option_removal\n\n  - name: Ensure PAM Displays Last Logon/Access Notification - Ensure authselect changes\n      are applied\n    ansible.builtin.command:\n      cmd: authselect apply-changes -b\n    when:\n    - result_authselect_present.stat.exists\n    - result_pam_option_removal is changed\n  when:\n  - '\"pam\" in ansible_facts.packages'\n  - result_pam_file_present.stat.exists\n  tags:\n  - CCE-83560-3\n  - CJIS-5.5.2\n  - NIST-800-53-AC-9(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.4\n  - configure_strategy\n  - display_login_attempts\n  - low_complexity\n  - low_disruption\n  - low_severity\n  - no_reboot_needed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_accounts_password_pam_unix_remember": {
			"rule_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_unix_remember",
			"title": "Limit Password Reuse",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83584-3"
			],
			"references": [
				"BP28(R18)",
				"1",
				"12",
				"15",
				"16",
				"5",
				"5.6.2.1.1",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"DSS05.10",
				"DSS06.03",
				"DSS06.10",
				"3.5.8",
				"CCI-000200",
				"4.3.3.2.2",
				"4.3.3.5.1",
				"4.3.3.5.2",
				"4.3.3.6.1",
				"4.3.3.6.2",
				"4.3.3.6.3",
				"4.3.3.6.4",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.3.6.9",
				"4.3.3.7.2",
				"4.3.3.7.4",
				"SR 1.1",
				"SR 1.10",
				"SR 1.2",
				"SR 1.3",
				"SR 1.4",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"SR 2.1",
				"A.18.1.4",
				"A.7.1.1",
				"A.9.2.1",
				"A.9.2.2",
				"A.9.2.3",
				"A.9.2.4",
				"A.9.2.6",
				"A.9.3.1",
				"A.9.4.2",
				"A.9.4.3",
				"IA-5(f)",
				"IA-5(1)(e)",
				"PR.AC-1",
				"PR.AC-6",
				"PR.AC-7",
				"Req-8.2.5",
				"SRG-OS-000077-GPOS-00045",
				"SRG-OS-000077-VMM-000440"
			],
			"description": "Do not allow users to reuse recent passwords. This can be accomplished by using the\n<code>remember</code> option for the <code>pam_unix</code> or <code>pam_pwhistory</code> PAM modules.",
			"rationale": "Preventing re-use of previous passwords helps ensure that a compromised password is not re-used by a user.",
			"warnings": [
				{
					"text": "If the system relies on <code>authselect</code> tool to manage PAM settings, the remediation\nwill also use <code>authselect</code> tool. However, if any manual modification was made in\nPAM files, the <code>authselect</code> integrity check will fail and the remediation will be\naborted in order to preserve intentional changes. In this case, an informative message will\nbe shown in the remediation report.",
					"category": "general"
				}
			],
			"platforms": [
				"#pam"
			],
			"oval_definition_id": "oval:ssg-accounts_password_pam_unix_remember:def:1",
			"remediations": [
				{
					"remediation_id": "accounts_password_pam_unix_remember",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q pam; then\n\nvar_password_pam_unix_remember='4'\n\n\n\nif [ -e \"/etc/pam.d/system-auth\" ] ; then\n    PAM_FILE_PATH=\"/etc/pam.d/system-auth\"\n    if [ -f /usr/bin/authselect ]; then\n        if ! authselect check; then\n        echo \"\n        authselect integrity check failed. Remediation aborted!\n        This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\n        It is not recommended to manually edit the PAM files when authselect tool is available.\n        In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\n        exit 1\n        fi\n        CURRENT_PROFILE=$(authselect current -r | awk '{ print $1 }')\n        # If not already in use, a custom profile is created preserving the enabled features.\n        if [[ ! $CURRENT_PROFILE == custom/* ]]; then\n            ENABLED_FEATURES=$(authselect current | tail -n+3 | awk '{ print $2 }')\n            authselect create-profile hardening -b $CURRENT_PROFILE\n            CURRENT_PROFILE=\"custom/hardening\"\n            \n            authselect apply-changes -b --backup=before-hardening-custom-profile\n            authselect select $CURRENT_PROFILE\n            for feature in $ENABLED_FEATURES; do\n                authselect enable-feature $feature;\n            done\n            \n            authselect apply-changes -b --backup=after-hardening-custom-profile\n        fi\n        PAM_FILE_NAME=$(basename \"/etc/pam.d/system-auth\")\n        PAM_FILE_PATH=\"/etc/authselect/$CURRENT_PROFILE/$PAM_FILE_NAME\"\n        \n        authselect apply-changes -b\n    fi\n    if ! grep -qP '^\\s*password\\s+'\"requisite\"'\\s+pam_pwhistory.so\\s*.*' \"$PAM_FILE_PATH\"; then\n            # Line matching group + control + module was not found. Check group + module.\n            if [ \"$(grep -cP '^\\s*password\\s+.*\\s+pam_pwhistory.so\\s*' \"$PAM_FILE_PATH\")\" -eq 1 ]; then\n                # The control is updated only if one single line matches.\n                sed -i -E --follow-symlinks 's/^(\\s*password\\s+).*(\\bpam_pwhistory.so.*)/\\1'\"requisite\"' \\2/' \"$PAM_FILE_PATH\"\n            else\n                sed -i --follow-symlinks '/^password.*requisite.*pam_pwquality.so/a password     '\"requisite\"'    pam_pwhistory.so' \"$PAM_FILE_PATH\"\n            fi\n        fi\n        # Check the option\n        if ! grep -qP '^\\s*password\\s+'\"requisite\"'\\s+pam_pwhistory.so\\s*.*\\sremember\\b' \"$PAM_FILE_PATH\"; then\n            sed -i -E --follow-symlinks '/\\s*password\\s+'\"requisite\"'\\s+pam_pwhistory.so.*/ s/$/ remember='\"$var_password_pam_unix_remember\"'/' \"$PAM_FILE_PATH\"\n        else\n            sed -i -E --follow-symlinks 's/(\\s*password\\s+'\"requisite\"'\\s+pam_pwhistory.so\\s+.*)('\"remember\"'=)[[:alnum:]]+\\s*(.*)/\\1\\2'\"$var_password_pam_unix_remember\"' \\3/' \"$PAM_FILE_PATH\"\n        fi\n    if [ -f /usr/bin/authselect ]; then\n        \n        authselect apply-changes -b\n    fi\nelse\n    echo \"/etc/pam.d/system-auth was not found\" >&2\nfi\n\nif [ -e \"/etc/pam.d/password-auth\" ] ; then\n    PAM_FILE_PATH=\"/etc/pam.d/password-auth\"\n    if [ -f /usr/bin/authselect ]; then\n        if ! authselect check; then\n        echo \"\n        authselect integrity check failed. Remediation aborted!\n        This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\n        It is not recommended to manually edit the PAM files when authselect tool is available.\n        In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\n        exit 1\n        fi\n        CURRENT_PROFILE=$(authselect current -r | awk '{ print $1 }')\n        # If not already in use, a custom profile is created preserving the enabled features.\n        if [[ ! $CURRENT_PROFILE == custom/* ]]; then\n            ENABLED_FEATURES=$(authselect current | tail -n+3 | awk '{ print $2 }')\n            authselect create-profile hardening -b $CURRENT_PROFILE\n            CURRENT_PROFILE=\"custom/hardening\"\n            \n            authselect apply-changes -b --backup=before-hardening-custom-profile\n            authselect select $CURRENT_PROFILE\n            for feature in $ENABLED_FEATURES; do\n                authselect enable-feature $feature;\n            done\n            \n            authselect apply-changes -b --backup=after-hardening-custom-profile\n        fi\n        PAM_FILE_NAME=$(basename \"/etc/pam.d/password-auth\")\n        PAM_FILE_PATH=\"/etc/authselect/$CURRENT_PROFILE/$PAM_FILE_NAME\"\n        \n        authselect apply-changes -b\n    fi\n    if ! grep -qP '^\\s*password\\s+'\"requisite\"'\\s+pam_pwhistory.so\\s*.*' \"$PAM_FILE_PATH\"; then\n            # Line matching group + control + module was not found. Check group + module.\n            if [ \"$(grep -cP '^\\s*password\\s+.*\\s+pam_pwhistory.so\\s*' \"$PAM_FILE_PATH\")\" -eq 1 ]; then\n                # The control is updated only if one single line matches.\n                sed -i -E --follow-symlinks 's/^(\\s*password\\s+).*(\\bpam_pwhistory.so.*)/\\1'\"requisite\"' \\2/' \"$PAM_FILE_PATH\"\n            else\n                sed -i --follow-symlinks '/^password.*requisite.*pam_pwquality.so/a password     '\"requisite\"'    pam_pwhistory.so' \"$PAM_FILE_PATH\"\n            fi\n        fi\n        # Check the option\n        if ! grep -qP '^\\s*password\\s+'\"requisite\"'\\s+pam_pwhistory.so\\s*.*\\sremember\\b' \"$PAM_FILE_PATH\"; then\n            sed -i -E --follow-symlinks '/\\s*password\\s+'\"requisite\"'\\s+pam_pwhistory.so.*/ s/$/ remember='\"$var_password_pam_unix_remember\"'/' \"$PAM_FILE_PATH\"\n        else\n            sed -i -E --follow-symlinks 's/(\\s*password\\s+'\"requisite\"'\\s+pam_pwhistory.so\\s+.*)('\"remember\"'=)[[:alnum:]]+\\s*(.*)/\\1\\2'\"$var_password_pam_unix_remember\"' \\3/' \"$PAM_FILE_PATH\"\n        fi\n    if [ -f /usr/bin/authselect ]; then\n        \n        authselect apply-changes -b\n    fi\nelse\n    echo \"/etc/pam.d/password-auth was not found\" >&2\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "accounts_password_pam_unix_remember",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "medium",
					"strategy": "configure",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83584-3\n  - CJIS-5.6.2.1.1\n  - NIST-800-171-3.5.8\n  - NIST-800-53-IA-5(1)(e)\n  - NIST-800-53-IA-5(f)\n  - PCI-DSS-Req-8.2.5\n  - accounts_password_pam_unix_remember\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n- name: XCCDF Value var_password_pam_unix_remember # promote to variable\n  set_fact:\n    var_password_pam_unix_remember: !!str 4\n  tags:\n    - always\n\n- name: Limit Password Reuse - Check if /etc/pam.d/system-auth file is present\n  ansible.builtin.stat:\n    path: /etc/pam.d/system-auth\n  register: result_pam_file_present\n  when: '\"pam\" in ansible_facts.packages'\n  tags:\n  - CCE-83584-3\n  - CJIS-5.6.2.1.1\n  - NIST-800-171-3.5.8\n  - NIST-800-53-IA-5(1)(e)\n  - NIST-800-53-IA-5(f)\n  - PCI-DSS-Req-8.2.5\n  - accounts_password_pam_unix_remember\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Limit Password Reuse - Check the proper remediation for the system\n  block:\n\n  - name: Limit Password Reuse - Define the PAM file to be edited as a local fact\n    ansible.builtin.set_fact:\n      pam_file_path: /etc/pam.d/system-auth\n\n  - name: Limit Password Reuse - Check if system relies on authselect\n    ansible.builtin.stat:\n      path: /usr/bin/authselect\n    register: result_authselect_present\n\n  - name: Limit Password Reuse - Remediate using authselect\n    block:\n\n    - name: Limit Password Reuse - Check integrity of authselect current profile\n      ansible.builtin.command:\n        cmd: authselect check\n      register: result_authselect_check_cmd\n      changed_when: false\n      ignore_errors: true\n\n    - name: Limit Password Reuse - Informative message based on the authselect integrity\n        check result\n      ansible.builtin.assert:\n        that:\n        - result_authselect_check_cmd is success\n        fail_msg:\n        - authselect integrity check failed. Remediation aborted!\n        - This remediation could not be applied because an authselect profile was\n          not selected or the selected profile is not intact.\n        - It is not recommended to manually edit the PAM files when authselect tool\n          is available.\n        - In cases where the default authselect profile does not cover a specific\n          demand, a custom authselect profile is recommended.\n        success_msg:\n        - authselect integrity check passed\n\n    - name: Limit Password Reuse - Get authselect current profile\n      ansible.builtin.shell:\n        cmd: authselect current -r | awk '{ print $1 }'\n      register: result_authselect_profile\n      changed_when: false\n      when:\n      - result_authselect_check_cmd is success\n\n    - name: Limit Password Reuse - Define the current authselect profile as a local\n        fact\n      ansible.builtin.set_fact:\n        authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n        authselect_custom_profile: '{{ result_authselect_profile.stdout }}'\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_profile.stdout is match(\"custom/\")\n\n    - name: Limit Password Reuse - Define the new authselect custom profile as a local\n        fact\n      ansible.builtin.set_fact:\n        authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n        authselect_custom_profile: custom/hardening\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_profile.stdout is not match(\"custom/\")\n\n    - name: Limit Password Reuse - Get authselect current features to also enable\n        them in the custom profile\n      ansible.builtin.shell:\n        cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n      register: result_authselect_features\n      changed_when: false\n      when:\n      - result_authselect_profile is not skipped\n      - authselect_current_profile is not match(\"custom/\")\n\n    - name: Limit Password Reuse - Check if any custom profile with the same name\n        was already created\n      ansible.builtin.stat:\n        path: /etc/authselect/{{ authselect_custom_profile }}\n      register: result_authselect_custom_profile_present\n      changed_when: false\n      when:\n      - authselect_current_profile is not match(\"custom/\")\n\n    - name: Limit Password Reuse - Create an authselect custom profile based on the\n        current profile\n      ansible.builtin.command:\n        cmd: authselect create-profile hardening -b {{ authselect_current_profile\n          }}\n      when:\n      - result_authselect_check_cmd is success\n      - authselect_current_profile is not match(\"custom/\")\n      - not result_authselect_custom_profile_present.stat.exists\n\n    - name: Limit Password Reuse - Ensure authselect changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b --backup=before-hardening-custom-profile\n      when:\n      - result_authselect_check_cmd is success\n      - result_authselect_profile is not skipped\n      - authselect_current_profile is not match(\"custom/\")\n      - authselect_custom_profile is not match(authselect_current_profile)\n\n    - name: Limit Password Reuse - Ensure the authselect custom profile is selected\n      ansible.builtin.command:\n        cmd: authselect select {{ authselect_custom_profile }}\n      register: result_pam_authselect_select_profile\n      when:\n      - result_authselect_check_cmd is success\n      - result_authselect_profile is not skipped\n      - authselect_current_profile is not match(\"custom/\")\n      - authselect_custom_profile is not match(authselect_current_profile)\n\n    - name: Limit Password Reuse - Restore the authselect features in the custom profile\n      ansible.builtin.command:\n        cmd: authselect enable-feature {{ item }}\n      loop: '{{ result_authselect_features.stdout_lines }}'\n      register: result_pam_authselect_restore_features\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_features is not skipped\n      - result_pam_authselect_select_profile is not skipped\n\n    - name: Limit Password Reuse - Ensure authselect changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b --backup=after-hardening-custom-profile\n      when:\n      - result_authselect_check_cmd is success\n      - result_authselect_profile is not skipped\n      - result_pam_authselect_restore_features is not skipped\n\n    - name: Limit Password Reuse - Change the PAM file to be edited according to the\n        custom authselect profile\n      ansible.builtin.set_fact:\n        pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path\n          | basename }}\n    when:\n    - result_authselect_present.stat.exists\n\n  - name: Limit Password Reuse - Check if expected PAM module line is present in {{\n      pam_file_path }}\n    ansible.builtin.lineinfile:\n      path: '{{ pam_file_path }}'\n      regexp: ^\\s*password\\s+requisite\\s+pam_pwhistory.so\\s*.*\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_line_present\n\n  - name: Limit Password Reuse - Include or update the PAM module line in {{ pam_file_path\n      }}\n    block:\n\n    - name: Limit Password Reuse - Check if required PAM module line is present in\n        {{ pam_file_path }} with different control\n      ansible.builtin.lineinfile:\n        path: '{{ pam_file_path }}'\n        regexp: ^\\s*password\\s+.*\\s+pam_pwhistory.so\\s*\n        state: absent\n      check_mode: true\n      changed_when: false\n      register: result_pam_line_other_control_present\n\n    - name: Limit Password Reuse - Ensure the correct control for the required PAM\n        module line in {{ pam_file_path }}\n      ansible.builtin.replace:\n        dest: '{{ pam_file_path }}'\n        regexp: ^(\\s*password\\s+).*(\\bpam_pwhistory.so.*)\n        replace: \\1requisite \\2\n      register: result_pam_module_edit\n      when:\n      - result_pam_line_other_control_present.found == 1\n\n    - name: Limit Password Reuse - Ensure the required PAM module line is included\n        in {{ pam_file_path }}\n      ansible.builtin.lineinfile:\n        dest: '{{ pam_file_path }}'\n        insertafter: ^password.*requisite.*pam_pwquality.so\n        line: password    requisite    pam_pwhistory.so\n      register: result_pam_module_add\n      when:\n      - result_pam_line_other_control_present.found == 0 or result_pam_line_other_control_present.found\n        > 1\n\n    - name: Limit Password Reuse - Ensure authselect changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b\n      when:\n      - result_authselect_present.stat.exists\n      - (result_pam_module_add is defined and result_pam_module_add.changed) or (result_pam_module_edit\n        is defined and result_pam_module_edit.changed)\n    when:\n    - result_pam_line_present.found is defined\n    - result_pam_line_present.found == 0\n\n  - name: Limit Password Reuse - Check if the required PAM module option is present\n      in {{ pam_file_path }}\n    ansible.builtin.lineinfile:\n      path: '{{ pam_file_path }}'\n      regexp: ^\\s*password\\s+requisite\\s+pam_pwhistory.so\\s*.*\\sremember\\b\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_module_remember_option_present\n\n  - name: Limit Password Reuse - Ensure the \"remember\" PAM option for \"pam_pwhistory.so\"\n      is included in {{ pam_file_path }}\n    ansible.builtin.lineinfile:\n      path: '{{ pam_file_path }}'\n      backrefs: true\n      regexp: ^(\\s*password\\s+requisite\\s+pam_pwhistory.so.*)\n      line: \\1 remember={{ var_password_pam_unix_remember }}\n      state: present\n    register: result_pam_remember_add\n    when:\n    - result_pam_module_remember_option_present.found == 0\n\n  - name: Limit Password Reuse - Ensure the required value for \"remember\" PAM option\n      from \"pam_pwhistory.so\" in {{ pam_file_path }}\n    ansible.builtin.lineinfile:\n      path: '{{ pam_file_path }}'\n      backrefs: true\n      regexp: ^(\\s*password\\s+requisite\\s+pam_pwhistory.so\\s+.*)(remember)=[0-9a-zA-Z]+\\s*(.*)\n      line: \\1\\2={{ var_password_pam_unix_remember }} \\3\n    register: result_pam_remember_edit\n    when:\n    - result_pam_module_remember_option_present.found > 0\n\n  - name: Limit Password Reuse - Ensure authselect changes are applied\n    ansible.builtin.command:\n      cmd: authselect apply-changes -b\n    when:\n    - result_authselect_present.stat.exists\n    - (result_pam_remember_add is defined and result_pam_remember_add.changed) or\n      (result_pam_remember_edit is defined and result_pam_remember_edit.changed)\n  when:\n  - '\"pam\" in ansible_facts.packages'\n  - result_pam_file_present.stat.exists\n  tags:\n  - CCE-83584-3\n  - CJIS-5.6.2.1.1\n  - NIST-800-171-3.5.8\n  - NIST-800-53-IA-5(1)(e)\n  - NIST-800-53-IA-5(f)\n  - PCI-DSS-Req-8.2.5\n  - accounts_password_pam_unix_remember\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Limit Password Reuse - Check if /etc/pam.d/password-auth file is present\n  ansible.builtin.stat:\n    path: /etc/pam.d/password-auth\n  register: result_pam_file_present\n  when: '\"pam\" in ansible_facts.packages'\n  tags:\n  - CCE-83584-3\n  - CJIS-5.6.2.1.1\n  - NIST-800-171-3.5.8\n  - NIST-800-53-IA-5(1)(e)\n  - NIST-800-53-IA-5(f)\n  - PCI-DSS-Req-8.2.5\n  - accounts_password_pam_unix_remember\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Limit Password Reuse - Check the proper remediation for the system\n  block:\n\n  - name: Limit Password Reuse - Define the PAM file to be edited as a local fact\n    ansible.builtin.set_fact:\n      pam_file_path: /etc/pam.d/password-auth\n\n  - name: Limit Password Reuse - Check if system relies on authselect\n    ansible.builtin.stat:\n      path: /usr/bin/authselect\n    register: result_authselect_present\n\n  - name: Limit Password Reuse - Remediate using authselect\n    block:\n\n    - name: Limit Password Reuse - Check integrity of authselect current profile\n      ansible.builtin.command:\n        cmd: authselect check\n      register: result_authselect_check_cmd\n      changed_when: false\n      ignore_errors: true\n\n    - name: Limit Password Reuse - Informative message based on the authselect integrity\n        check result\n      ansible.builtin.assert:\n        that:\n        - result_authselect_check_cmd is success\n        fail_msg:\n        - authselect integrity check failed. Remediation aborted!\n        - This remediation could not be applied because an authselect profile was\n          not selected or the selected profile is not intact.\n        - It is not recommended to manually edit the PAM files when authselect tool\n          is available.\n        - In cases where the default authselect profile does not cover a specific\n          demand, a custom authselect profile is recommended.\n        success_msg:\n        - authselect integrity check passed\n\n    - name: Limit Password Reuse - Get authselect current profile\n      ansible.builtin.shell:\n        cmd: authselect current -r | awk '{ print $1 }'\n      register: result_authselect_profile\n      changed_when: false\n      when:\n      - result_authselect_check_cmd is success\n\n    - name: Limit Password Reuse - Define the current authselect profile as a local\n        fact\n      ansible.builtin.set_fact:\n        authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n        authselect_custom_profile: '{{ result_authselect_profile.stdout }}'\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_profile.stdout is match(\"custom/\")\n\n    - name: Limit Password Reuse - Define the new authselect custom profile as a local\n        fact\n      ansible.builtin.set_fact:\n        authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n        authselect_custom_profile: custom/hardening\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_profile.stdout is not match(\"custom/\")\n\n    - name: Limit Password Reuse - Get authselect current features to also enable\n        them in the custom profile\n      ansible.builtin.shell:\n        cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n      register: result_authselect_features\n      changed_when: false\n      when:\n      - result_authselect_profile is not skipped\n      - authselect_current_profile is not match(\"custom/\")\n\n    - name: Limit Password Reuse - Check if any custom profile with the same name\n        was already created\n      ansible.builtin.stat:\n        path: /etc/authselect/{{ authselect_custom_profile }}\n      register: result_authselect_custom_profile_present\n      changed_when: false\n      when:\n      - authselect_current_profile is not match(\"custom/\")\n\n    - name: Limit Password Reuse - Create an authselect custom profile based on the\n        current profile\n      ansible.builtin.command:\n        cmd: authselect create-profile hardening -b {{ authselect_current_profile\n          }}\n      when:\n      - result_authselect_check_cmd is success\n      - authselect_current_profile is not match(\"custom/\")\n      - not result_authselect_custom_profile_present.stat.exists\n\n    - name: Limit Password Reuse - Ensure authselect changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b --backup=before-hardening-custom-profile\n      when:\n      - result_authselect_check_cmd is success\n      - result_authselect_profile is not skipped\n      - authselect_current_profile is not match(\"custom/\")\n      - authselect_custom_profile is not match(authselect_current_profile)\n\n    - name: Limit Password Reuse - Ensure the authselect custom profile is selected\n      ansible.builtin.command:\n        cmd: authselect select {{ authselect_custom_profile }}\n      register: result_pam_authselect_select_profile\n      when:\n      - result_authselect_check_cmd is success\n      - result_authselect_profile is not skipped\n      - authselect_current_profile is not match(\"custom/\")\n      - authselect_custom_profile is not match(authselect_current_profile)\n\n    - name: Limit Password Reuse - Restore the authselect features in the custom profile\n      ansible.builtin.command:\n        cmd: authselect enable-feature {{ item }}\n      loop: '{{ result_authselect_features.stdout_lines }}'\n      register: result_pam_authselect_restore_features\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_features is not skipped\n      - result_pam_authselect_select_profile is not skipped\n\n    - name: Limit Password Reuse - Ensure authselect changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b --backup=after-hardening-custom-profile\n      when:\n      - result_authselect_check_cmd is success\n      - result_authselect_profile is not skipped\n      - result_pam_authselect_restore_features is not skipped\n\n    - name: Limit Password Reuse - Change the PAM file to be edited according to the\n        custom authselect profile\n      ansible.builtin.set_fact:\n        pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path\n          | basename }}\n    when:\n    - result_authselect_present.stat.exists\n\n  - name: Limit Password Reuse - Check if expected PAM module line is present in {{\n      pam_file_path }}\n    ansible.builtin.lineinfile:\n      path: '{{ pam_file_path }}'\n      regexp: ^\\s*password\\s+requisite\\s+pam_pwhistory.so\\s*.*\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_line_present\n\n  - name: Limit Password Reuse - Include or update the PAM module line in {{ pam_file_path\n      }}\n    block:\n\n    - name: Limit Password Reuse - Check if required PAM module line is present in\n        {{ pam_file_path }} with different control\n      ansible.builtin.lineinfile:\n        path: '{{ pam_file_path }}'\n        regexp: ^\\s*password\\s+.*\\s+pam_pwhistory.so\\s*\n        state: absent\n      check_mode: true\n      changed_when: false\n      register: result_pam_line_other_control_present\n\n    - name: Limit Password Reuse - Ensure the correct control for the required PAM\n        module line in {{ pam_file_path }}\n      ansible.builtin.replace:\n        dest: '{{ pam_file_path }}'\n        regexp: ^(\\s*password\\s+).*(\\bpam_pwhistory.so.*)\n        replace: \\1requisite \\2\n      register: result_pam_module_edit\n      when:\n      - result_pam_line_other_control_present.found == 1\n\n    - name: Limit Password Reuse - Ensure the required PAM module line is included\n        in {{ pam_file_path }}\n      ansible.builtin.lineinfile:\n        dest: '{{ pam_file_path }}'\n        insertafter: ^password.*requisite.*pam_pwquality.so\n        line: password    requisite    pam_pwhistory.so\n      register: result_pam_module_add\n      when:\n      - result_pam_line_other_control_present.found == 0 or result_pam_line_other_control_present.found\n        > 1\n\n    - name: Limit Password Reuse - Ensure authselect changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b\n      when:\n      - result_authselect_present.stat.exists\n      - (result_pam_module_add is defined and result_pam_module_add.changed) or (result_pam_module_edit\n        is defined and result_pam_module_edit.changed)\n    when:\n    - result_pam_line_present.found is defined\n    - result_pam_line_present.found == 0\n\n  - name: Limit Password Reuse - Check if the required PAM module option is present\n      in {{ pam_file_path }}\n    ansible.builtin.lineinfile:\n      path: '{{ pam_file_path }}'\n      regexp: ^\\s*password\\s+requisite\\s+pam_pwhistory.so\\s*.*\\sremember\\b\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_module_remember_option_present\n\n  - name: Limit Password Reuse - Ensure the \"remember\" PAM option for \"pam_pwhistory.so\"\n      is included in {{ pam_file_path }}\n    ansible.builtin.lineinfile:\n      path: '{{ pam_file_path }}'\n      backrefs: true\n      regexp: ^(\\s*password\\s+requisite\\s+pam_pwhistory.so.*)\n      line: \\1 remember={{ var_password_pam_unix_remember }}\n      state: present\n    register: result_pam_remember_add\n    when:\n    - result_pam_module_remember_option_present.found == 0\n\n  - name: Limit Password Reuse - Ensure the required value for \"remember\" PAM option\n      from \"pam_pwhistory.so\" in {{ pam_file_path }}\n    ansible.builtin.lineinfile:\n      path: '{{ pam_file_path }}'\n      backrefs: true\n      regexp: ^(\\s*password\\s+requisite\\s+pam_pwhistory.so\\s+.*)(remember)=[0-9a-zA-Z]+\\s*(.*)\n      line: \\1\\2={{ var_password_pam_unix_remember }} \\3\n    register: result_pam_remember_edit\n    when:\n    - result_pam_module_remember_option_present.found > 0\n\n  - name: Limit Password Reuse - Ensure authselect changes are applied\n    ansible.builtin.command:\n      cmd: authselect apply-changes -b\n    when:\n    - result_authselect_present.stat.exists\n    - (result_pam_remember_add is defined and result_pam_remember_add.changed) or\n      (result_pam_remember_edit is defined and result_pam_remember_edit.changed)\n  when:\n  - '\"pam\" in ansible_facts.packages'\n  - result_pam_file_present.stat.exists\n  tags:\n  - CCE-83584-3\n  - CJIS-5.6.2.1.1\n  - NIST-800-171-3.5.8\n  - NIST-800-53-IA-5(1)(e)\n  - NIST-800-53-IA-5(f)\n  - PCI-DSS-Req-8.2.5\n  - accounts_password_pam_unix_remember\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_deny": {
			"rule_id": "xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_deny",
			"title": "Lock Accounts After Failed Password Attempts",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83587-6"
			],
			"references": [
				"BP28(R18)",
				"1",
				"12",
				"15",
				"16",
				"5.5.3",
				"DSS05.04",
				"DSS05.10",
				"DSS06.10",
				"3.1.8",
				"CCI-000044",
				"CCI-002236",
				"CCI-002237",
				"CCI-002238",
				"4.3.3.6.1",
				"4.3.3.6.2",
				"4.3.3.6.3",
				"4.3.3.6.4",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.3.6.9",
				"SR 1.1",
				"SR 1.10",
				"SR 1.2",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"0421",
				"0422",
				"0431",
				"0974",
				"1173",
				"1401",
				"1504",
				"1505",
				"1546",
				"1557",
				"1558",
				"1559",
				"1560",
				"1561",
				"A.18.1.4",
				"A.9.2.1",
				"A.9.2.4",
				"A.9.3.1",
				"A.9.4.2",
				"A.9.4.3",
				"CM-6(a)",
				"AC-7(a)",
				"PR.AC-7",
				"FIA_AFL.1",
				"Req-8.1.6",
				"SRG-OS-000329-GPOS-00128",
				"SRG-OS-000021-GPOS-00005",
				"SRG-OS-000021-VMM-000050"
			],
			"description": "This rule configures the system to lock out accounts after a number of incorrect login attempts\nusing <code>pam_faillock.so</code>.\n\npam_faillock.so module requires multiple entries in pam files. These entries must be carefully\ndefined to work as expected. In order to avoid errors when manually editing these files, it is\nrecommended to use the appropriate tools, such as <code>authselect</code> or <code>authconfig</code>,\ndepending on the OS version.",
			"rationale": "Locking out user accounts after a number of incorrect attempts prevents direct password\nguessing attacks. In combination with the <code>silent</code> option, user enumeration attacks\nare also mitigated.",
			"warnings": [
				{
					"text": "If the system relies on <code>authselect</code> tool to manage PAM settings, the remediation\nwill also use <code>authselect</code> tool. However, if any manual modification was made in\nPAM files, the <code>authselect</code> integrity check will fail and the remediation will be\naborted in order to preserve intentional changes. In this case, an informative message will\nbe shown in the remediation report.\nIf the system supports the <code>/etc/security/faillock.conf</code> file, the pam_faillock\nparameters should be defined in <code>faillock.conf</code> file.",
					"category": "general"
				}
			],
			"platforms": [
				"#pam"
			],
			"oval_definition_id": "oval:ssg-accounts_passwords_pam_faillock_deny:def:1",
			"remediations": [
				{
					"remediation_id": "accounts_passwords_pam_faillock_deny",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q pam; then\n\nvar_accounts_passwords_pam_faillock_deny='6'\n\n\nif [ -f /usr/bin/authselect ]; then\n    if ! authselect check; then\necho \"\nauthselect integrity check failed. Remediation aborted!\nThis remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\nIt is not recommended to manually edit the PAM files when authselect tool is available.\nIn cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\nexit 1\nfi\nauthselect enable-feature with-faillock\n\nauthselect apply-changes -b\nelse\n    AUTH_FILES=(\"/etc/pam.d/system-auth\" \"/etc/pam.d/password-auth\")\nfor pam_file in \"${AUTH_FILES[@]}\"\ndo\n    if ! grep -qE '^\\s*auth\\s+required\\s+pam_faillock\\.so\\s+(preauth silent|authfail).*$' \"$pam_file\" ; then\n        sed -i --follow-symlinks '/^auth.*sufficient.*pam_unix.so.*/i auth        required      pam_faillock.so preauth silent' \"$pam_file\"\n        sed -i --follow-symlinks '/^auth.*required.*pam_deny.so.*/i auth        required      pam_faillock.so authfail' \"$pam_file\"\n        sed -i --follow-symlinks '/^account.*required.*pam_unix.so.*/i account     required      pam_faillock.so' \"$pam_file\"\n    fi\n    sed -Ei 's/(auth.*)(\\[default=die\\])(.*pam_faillock.so)/\\1required     \\3/g' \"$pam_file\"\ndone\nfi\nAUTH_FILES=(\"/etc/pam.d/system-auth\" \"/etc/pam.d/password-auth\")\nFAILLOCK_CONF=\"/etc/security/faillock.conf\"\nif [ -f $FAILLOCK_CONF ]; then\n    regex=\"^\\s*deny\\s*=\"\n    line=\"deny = $var_accounts_passwords_pam_faillock_deny\"\n    if ! grep -q $regex $FAILLOCK_CONF; then\n        echo $line >> $FAILLOCK_CONF\n    else\n        sed -i --follow-symlinks 's|^\\s*\\(deny\\s*=\\s*\\)\\(\\S\\+\\)|\\1'\"$var_accounts_passwords_pam_faillock_deny\"'|g' $FAILLOCK_CONF\n    fi\n    for pam_file in \"${AUTH_FILES[@]}\"\n    do\n        if [ -e \"$pam_file\" ] ; then\n            PAM_FILE_PATH=\"$pam_file\"\n            if [ -f /usr/bin/authselect ]; then\n                if ! authselect check; then\n                    echo \"\n                    authselect integrity check failed. Remediation aborted!\n                    This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\n                    It is not recommended to manually edit the PAM files when authselect tool is available.\n                    In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\n                    exit 1\n                    fi\n                CURRENT_PROFILE=$(authselect current -r | awk '{ print $1 }')\n                # If not already in use, a custom profile is created preserving the enabled features.\n                if [[ ! $CURRENT_PROFILE == custom/* ]]; then\n                    ENABLED_FEATURES=$(authselect current | tail -n+3 | awk '{ print $2 }')\n                    authselect create-profile hardening -b $CURRENT_PROFILE\n                    CURRENT_PROFILE=\"custom/hardening\"\n                    \n                    authselect apply-changes -b --backup=before-hardening-custom-profile\n                    authselect select $CURRENT_PROFILE\n                    for feature in $ENABLED_FEATURES; do\n                        authselect enable-feature $feature;\n                    done\n                    \n                    authselect apply-changes -b --backup=after-hardening-custom-profile\n                fi\n                PAM_FILE_NAME=$(basename \"$pam_file\")\n                PAM_FILE_PATH=\"/etc/authselect/$CURRENT_PROFILE/$PAM_FILE_NAME\"\n                \n                authselect apply-changes -b\n            fi\n            \n        if grep -qP '^\\s*auth\\s.*\\bpam_faillock.so\\s.*\\bdeny\\b' \"$PAM_FILE_PATH\"; then\n            sed -i -E --follow-symlinks 's/(.*auth.*pam_faillock.so.*)\\bdeny\\b=?[[:alnum:]]*(.*)/\\1\\2/g' \"$PAM_FILE_PATH\"\n        fi\n            if [ -f /usr/bin/authselect ]; then\n                \n                authselect apply-changes -b\n            fi\n        else\n            echo \"$pam_file was not found\" >&2\n        fi\n    done\nelse\n    for pam_file in \"${AUTH_FILES[@]}\"\n    do\n        if ! grep -qE '^\\s*auth.*pam_faillock.so (preauth|authfail).*deny' \"$pam_file\"; then\n            sed -i --follow-symlinks '/^auth.*required.*pam_faillock.so.*preauth.*silent.*/ s/$/ deny='\"$var_accounts_passwords_pam_faillock_deny\"'/' \"$pam_file\"\n            sed -i --follow-symlinks '/^auth.*required.*pam_faillock.so.*authfail.*/ s/$/ deny='\"$var_accounts_passwords_pam_faillock_deny\"'/' \"$pam_file\"\n        else\n            sed -i --follow-symlinks 's/\\(^auth.*required.*pam_faillock.so.*preauth.*silent.*\\)\\('\"deny\"'=\\)[0-9]\\+\\(.*\\)/\\1\\2'\"$var_accounts_passwords_pam_faillock_deny\"'\\3/' \"$pam_file\"\n            sed -i --follow-symlinks 's/\\(^auth.*required.*pam_faillock.so.*authfail.*\\)\\('\"deny\"'=\\)[0-9]\\+\\(.*\\)/\\1\\2'\"$var_accounts_passwords_pam_faillock_deny\"'\\3/' \"$pam_file\"\n        fi\n    done\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "accounts_passwords_pam_faillock_deny",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83587-6\n  - CJIS-5.5.3\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.6\n  - accounts_passwords_pam_faillock_deny\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Lock Accounts After Failed Password Attempts - Check if system relies on authselect\n    tool\n  ansible.builtin.stat:\n    path: /usr/bin/authselect\n  register: result_authselect_present\n  when: '\"pam\" in ansible_facts.packages'\n  tags:\n  - CCE-83587-6\n  - CJIS-5.5.3\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.6\n  - accounts_passwords_pam_faillock_deny\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Lock Accounts After Failed Password Attempts - Remediation where authselect\n    tool is present\n  block:\n\n  - name: Lock Accounts After Failed Password Attempts - Check integrity of authselect\n      current profile\n    ansible.builtin.command:\n      cmd: authselect check\n    register: result_authselect_check_cmd\n    changed_when: false\n    ignore_errors: true\n\n  - name: Lock Accounts After Failed Password Attempts - Informative message based\n      on the authselect integrity check result\n    ansible.builtin.assert:\n      that:\n      - result_authselect_check_cmd is success\n      fail_msg:\n      - authselect integrity check failed. Remediation aborted!\n      - This remediation could not be applied because an authselect profile was not\n        selected or the selected profile is not intact.\n      - It is not recommended to manually edit the PAM files when authselect tool\n        is available.\n      - In cases where the default authselect profile does not cover a specific demand,\n        a custom authselect profile is recommended.\n      success_msg:\n      - authselect integrity check passed\n\n  - name: Lock Accounts After Failed Password Attempts - Get authselect current features\n    ansible.builtin.shell:\n      cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n    register: result_authselect_features\n    changed_when: false\n    when:\n    - result_authselect_check_cmd is success\n\n  - name: Lock Accounts After Failed Password Attempts - Ensure \"with-faillock\" feature\n      is enabled using authselect tool\n    ansible.builtin.command:\n      cmd: authselect enable-feature with-faillock\n    register: result_authselect_enable_feature_cmd\n    when:\n    - result_authselect_check_cmd is success\n    - result_authselect_features.stdout is not search(\"with-faillock\")\n\n  - name: Lock Accounts After Failed Password Attempts - Ensure authselect changes\n      are applied\n    ansible.builtin.command:\n      cmd: authselect apply-changes -b\n    when:\n    - result_authselect_enable_feature_cmd is not skipped\n    - result_authselect_enable_feature_cmd is success\n  when:\n  - '\"pam\" in ansible_facts.packages'\n  - result_authselect_present.stat.exists\n  tags:\n  - CCE-83587-6\n  - CJIS-5.5.3\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.6\n  - accounts_passwords_pam_faillock_deny\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Lock Accounts After Failed Password Attempts - Remediation where authselect\n    tool is not present\n  block:\n\n  - name: Lock Accounts After Failed Password Attempts - Check if pam_faillock.so\n      is already enabled\n    ansible.builtin.lineinfile:\n      path: /etc/pam.d/system-auth\n      regexp: .*auth.*pam_faillock.so (preauth|authfail)\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_faillock_is_enabled\n\n  - name: Lock Accounts After Failed Password Attempts - Enable pam_faillock.so preauth\n      editing PAM files\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      line: auth        required      pam_faillock.so preauth\n      insertbefore: ^auth.*sufficient.*pam_unix.so.*\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_is_enabled.found == 0\n\n  - name: Lock Accounts After Failed Password Attempts - Enable pam_faillock.so authfail\n      editing PAM files\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      line: auth        required      pam_faillock.so authfail\n      insertbefore: ^auth.*required.*pam_deny.so.*\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_is_enabled.found == 0\n\n  - name: Lock Accounts After Failed Password Attempts - Enable pam_faillock.so account\n      section editing PAM files\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      line: account     required      pam_faillock.so\n      insertbefore: ^account.*required.*pam_unix.so.*\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_is_enabled.found == 0\n  when:\n  - '\"pam\" in ansible_facts.packages'\n  - not result_authselect_present.stat.exists\n  tags:\n  - CCE-83587-6\n  - CJIS-5.5.3\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.6\n  - accounts_passwords_pam_faillock_deny\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_accounts_passwords_pam_faillock_deny # promote to variable\n  set_fact:\n    var_accounts_passwords_pam_faillock_deny: !!str 6\n  tags:\n    - always\n\n- name: Lock Accounts After Failed Password Attempts - Check the presence of /etc/security/faillock.conf\n    file\n  ansible.builtin.stat:\n    path: /etc/security/faillock.conf\n  register: result_faillock_conf_check\n  when: '\"pam\" in ansible_facts.packages'\n  tags:\n  - CCE-83587-6\n  - CJIS-5.5.3\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.6\n  - accounts_passwords_pam_faillock_deny\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Lock Accounts After Failed Password Attempts - Ensure the pam_faillock.so\n    deny parameter in /etc/security/faillock.conf\n  ansible.builtin.lineinfile:\n    path: /etc/security/faillock.conf\n    regexp: ^\\s*deny\\s*=\n    line: deny = {{ var_accounts_passwords_pam_faillock_deny }}\n    state: present\n  when:\n  - '\"pam\" in ansible_facts.packages'\n  - result_faillock_conf_check.stat.exists\n  tags:\n  - CCE-83587-6\n  - CJIS-5.5.3\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.6\n  - accounts_passwords_pam_faillock_deny\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Lock Accounts After Failed Password Attempts - Ensure the pam_faillock.so\n    deny parameter not in PAM files\n  block:\n\n  - name: Lock Accounts After Failed Password Attempts - Check if /etc/pam.d/system-auth\n      file is present\n    ansible.builtin.stat:\n      path: /etc/pam.d/system-auth\n    register: result_pam_file_present\n\n  - name: Lock Accounts After Failed Password Attempts - Check the proper remediation\n      for the system\n    block:\n\n    - name: Lock Accounts After Failed Password Attempts - Define the PAM file to\n        be edited as a local fact\n      ansible.builtin.set_fact:\n        pam_file_path: /etc/pam.d/system-auth\n\n    - name: Lock Accounts After Failed Password Attempts - Check if system relies\n        on authselect\n      ansible.builtin.stat:\n        path: /usr/bin/authselect\n      register: result_authselect_present\n\n    - name: Lock Accounts After Failed Password Attempts - Remediate using authselect\n      block:\n\n      - name: Lock Accounts After Failed Password Attempts - Check integrity of authselect\n          current profile\n        ansible.builtin.command:\n          cmd: authselect check\n        register: result_authselect_check_cmd\n        changed_when: false\n        ignore_errors: true\n\n      - name: Lock Accounts After Failed Password Attempts - Informative message based\n          on the authselect integrity check result\n        ansible.builtin.assert:\n          that:\n          - result_authselect_check_cmd is success\n          fail_msg:\n          - authselect integrity check failed. Remediation aborted!\n          - This remediation could not be applied because an authselect profile was\n            not selected or the selected profile is not intact.\n          - It is not recommended to manually edit the PAM files when authselect tool\n            is available.\n          - In cases where the default authselect profile does not cover a specific\n            demand, a custom authselect profile is recommended.\n          success_msg:\n          - authselect integrity check passed\n\n      - name: Lock Accounts After Failed Password Attempts - Get authselect current\n          profile\n        ansible.builtin.shell:\n          cmd: authselect current -r | awk '{ print $1 }'\n        register: result_authselect_profile\n        changed_when: false\n        when:\n        - result_authselect_check_cmd is success\n\n      - name: Lock Accounts After Failed Password Attempts - Define the current authselect\n          profile as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: '{{ result_authselect_profile.stdout }}'\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is match(\"custom/\")\n\n      - name: Lock Accounts After Failed Password Attempts - Define the new authselect\n          custom profile as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: custom/hardening\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is not match(\"custom/\")\n\n      - name: Lock Accounts After Failed Password Attempts - Get authselect current\n          features to also enable them in the custom profile\n        ansible.builtin.shell:\n          cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n        register: result_authselect_features\n        changed_when: false\n        when:\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Lock Accounts After Failed Password Attempts - Check if any custom profile\n          with the same name was already created\n        ansible.builtin.stat:\n          path: /etc/authselect/{{ authselect_custom_profile }}\n        register: result_authselect_custom_profile_present\n        changed_when: false\n        when:\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Lock Accounts After Failed Password Attempts - Create an authselect\n          custom profile based on the current profile\n        ansible.builtin.command:\n          cmd: authselect create-profile hardening -b {{ authselect_current_profile\n            }}\n        when:\n        - result_authselect_check_cmd is success\n        - authselect_current_profile is not match(\"custom/\")\n        - not result_authselect_custom_profile_present.stat.exists\n\n      - name: Lock Accounts After Failed Password Attempts - Ensure authselect changes\n          are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=before-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Lock Accounts After Failed Password Attempts - Ensure the authselect\n          custom profile is selected\n        ansible.builtin.command:\n          cmd: authselect select {{ authselect_custom_profile }}\n        register: result_pam_authselect_select_profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Lock Accounts After Failed Password Attempts - Restore the authselect\n          features in the custom profile\n        ansible.builtin.command:\n          cmd: authselect enable-feature {{ item }}\n        loop: '{{ result_authselect_features.stdout_lines }}'\n        register: result_pam_authselect_restore_features\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_features is not skipped\n        - result_pam_authselect_select_profile is not skipped\n\n      - name: Lock Accounts After Failed Password Attempts - Ensure authselect changes\n          are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=after-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - result_pam_authselect_restore_features is not skipped\n\n      - name: Lock Accounts After Failed Password Attempts - Change the PAM file to\n          be edited according to the custom authselect profile\n        ansible.builtin.set_fact:\n          pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path\n            | basename }}\n      when:\n      - result_authselect_present.stat.exists\n\n    - name: Lock Accounts After Failed Password Attempts - Ensure the \"deny\" option\n        from \"pam_faillock.so\" is not present in {{ pam_file_path }}\n      ansible.builtin.replace:\n        dest: '{{ pam_file_path }}'\n        regexp: (.*auth.*pam_faillock.so.*)\\bdeny\\b=?[0-9a-zA-Z]*(.*)\n        replace: \\1\\2\n      register: result_pam_option_removal\n\n    - name: Lock Accounts After Failed Password Attempts - Ensure authselect changes\n        are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b\n      when:\n      - result_authselect_present.stat.exists\n      - result_pam_option_removal is changed\n    when:\n    - result_pam_file_present.stat.exists\n\n  - name: Lock Accounts After Failed Password Attempts - Check if /etc/pam.d/password-auth\n      file is present\n    ansible.builtin.stat:\n      path: /etc/pam.d/password-auth\n    register: result_pam_file_present\n\n  - name: Lock Accounts After Failed Password Attempts - Check the proper remediation\n      for the system\n    block:\n\n    - name: Lock Accounts After Failed Password Attempts - Define the PAM file to\n        be edited as a local fact\n      ansible.builtin.set_fact:\n        pam_file_path: /etc/pam.d/password-auth\n\n    - name: Lock Accounts After Failed Password Attempts - Check if system relies\n        on authselect\n      ansible.builtin.stat:\n        path: /usr/bin/authselect\n      register: result_authselect_present\n\n    - name: Lock Accounts After Failed Password Attempts - Remediate using authselect\n      block:\n\n      - name: Lock Accounts After Failed Password Attempts - Check integrity of authselect\n          current profile\n        ansible.builtin.command:\n          cmd: authselect check\n        register: result_authselect_check_cmd\n        changed_when: false\n        ignore_errors: true\n\n      - name: Lock Accounts After Failed Password Attempts - Informative message based\n          on the authselect integrity check result\n        ansible.builtin.assert:\n          that:\n          - result_authselect_check_cmd is success\n          fail_msg:\n          - authselect integrity check failed. Remediation aborted!\n          - This remediation could not be applied because an authselect profile was\n            not selected or the selected profile is not intact.\n          - It is not recommended to manually edit the PAM files when authselect tool\n            is available.\n          - In cases where the default authselect profile does not cover a specific\n            demand, a custom authselect profile is recommended.\n          success_msg:\n          - authselect integrity check passed\n\n      - name: Lock Accounts After Failed Password Attempts - Get authselect current\n          profile\n        ansible.builtin.shell:\n          cmd: authselect current -r | awk '{ print $1 }'\n        register: result_authselect_profile\n        changed_when: false\n        when:\n        - result_authselect_check_cmd is success\n\n      - name: Lock Accounts After Failed Password Attempts - Define the current authselect\n          profile as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: '{{ result_authselect_profile.stdout }}'\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is match(\"custom/\")\n\n      - name: Lock Accounts After Failed Password Attempts - Define the new authselect\n          custom profile as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: custom/hardening\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is not match(\"custom/\")\n\n      - name: Lock Accounts After Failed Password Attempts - Get authselect current\n          features to also enable them in the custom profile\n        ansible.builtin.shell:\n          cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n        register: result_authselect_features\n        changed_when: false\n        when:\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Lock Accounts After Failed Password Attempts - Check if any custom profile\n          with the same name was already created\n        ansible.builtin.stat:\n          path: /etc/authselect/{{ authselect_custom_profile }}\n        register: result_authselect_custom_profile_present\n        changed_when: false\n        when:\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Lock Accounts After Failed Password Attempts - Create an authselect\n          custom profile based on the current profile\n        ansible.builtin.command:\n          cmd: authselect create-profile hardening -b {{ authselect_current_profile\n            }}\n        when:\n        - result_authselect_check_cmd is success\n        - authselect_current_profile is not match(\"custom/\")\n        - not result_authselect_custom_profile_present.stat.exists\n\n      - name: Lock Accounts After Failed Password Attempts - Ensure authselect changes\n          are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=before-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Lock Accounts After Failed Password Attempts - Ensure the authselect\n          custom profile is selected\n        ansible.builtin.command:\n          cmd: authselect select {{ authselect_custom_profile }}\n        register: result_pam_authselect_select_profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Lock Accounts After Failed Password Attempts - Restore the authselect\n          features in the custom profile\n        ansible.builtin.command:\n          cmd: authselect enable-feature {{ item }}\n        loop: '{{ result_authselect_features.stdout_lines }}'\n        register: result_pam_authselect_restore_features\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_features is not skipped\n        - result_pam_authselect_select_profile is not skipped\n\n      - name: Lock Accounts After Failed Password Attempts - Ensure authselect changes\n          are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=after-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - result_pam_authselect_restore_features is not skipped\n\n      - name: Lock Accounts After Failed Password Attempts - Change the PAM file to\n          be edited according to the custom authselect profile\n        ansible.builtin.set_fact:\n          pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path\n            | basename }}\n      when:\n      - result_authselect_present.stat.exists\n\n    - name: Lock Accounts After Failed Password Attempts - Ensure the \"deny\" option\n        from \"pam_faillock.so\" is not present in {{ pam_file_path }}\n      ansible.builtin.replace:\n        dest: '{{ pam_file_path }}'\n        regexp: (.*auth.*pam_faillock.so.*)\\bdeny\\b=?[0-9a-zA-Z]*(.*)\n        replace: \\1\\2\n      register: result_pam_option_removal\n\n    - name: Lock Accounts After Failed Password Attempts - Ensure authselect changes\n        are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b\n      when:\n      - result_authselect_present.stat.exists\n      - result_pam_option_removal is changed\n    when:\n    - result_pam_file_present.stat.exists\n  when:\n  - '\"pam\" in ansible_facts.packages'\n  - result_faillock_conf_check.stat.exists\n  tags:\n  - CCE-83587-6\n  - CJIS-5.5.3\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.6\n  - accounts_passwords_pam_faillock_deny\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Lock Accounts After Failed Password Attempts - Ensure the pam_faillock.so\n    deny parameter in PAM files\n  block:\n\n  - name: Lock Accounts After Failed Password Attempts - Check if pam_faillock.so\n      deny parameter is already enabled in pam files\n    ansible.builtin.lineinfile:\n      path: /etc/pam.d/system-auth\n      regexp: .*auth.*pam_faillock.so (preauth|authfail).*deny\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_faillock_deny_parameter_is_present\n\n  - name: Lock Accounts After Failed Password Attempts - Ensure the inclusion of pam_faillock.so\n      preauth deny parameter in auth section\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      backrefs: true\n      regexp: (^\\s*auth\\s+)([\\w\\[].*\\b)(\\s+pam_faillock.so preauth.*)\n      line: \\1required\\3 deny={{ var_accounts_passwords_pam_faillock_deny }}\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_deny_parameter_is_present.found == 0\n\n  - name: Lock Accounts After Failed Password Attempts - Ensure the inclusion of pam_faillock.so\n      authfail deny parameter in auth section\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      backrefs: true\n      regexp: (^\\s*auth\\s+)([\\w\\[].*\\b)(\\s+pam_faillock.so authfail.*)\n      line: \\1required\\3 deny={{ var_accounts_passwords_pam_faillock_deny }}\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_deny_parameter_is_present.found == 0\n\n  - name: Lock Accounts After Failed Password Attempts - Ensure the desired value\n      for pam_faillock.so preauth deny parameter in auth section\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      backrefs: true\n      regexp: (^\\s*auth\\s+)([\\w\\[].*\\b)(\\s+pam_faillock.so preauth.*)(deny)=[0-9]+(.*)\n      line: \\1required\\3\\4={{ var_accounts_passwords_pam_faillock_deny }}\\5\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_deny_parameter_is_present.found > 0\n\n  - name: Lock Accounts After Failed Password Attempts - Ensure the desired value\n      for pam_faillock.so authfail deny parameter in auth section\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      backrefs: true\n      regexp: (^\\s*auth\\s+)([\\w\\[].*\\b)(\\s+pam_faillock.so authfail.*)(deny)=[0-9]+(.*)\n      line: \\1required\\3\\4={{ var_accounts_passwords_pam_faillock_deny }}\\5\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_deny_parameter_is_present.found > 0\n  when:\n  - '\"pam\" in ansible_facts.packages'\n  - not result_faillock_conf_check.stat.exists\n  tags:\n  - CCE-83587-6\n  - CJIS-5.5.3\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(a)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.6\n  - accounts_passwords_pam_faillock_deny\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_unlock_time": {
			"rule_id": "xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_unlock_time",
			"title": "Set Lockout Time for Failed Password Attempts",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83588-4"
			],
			"references": [
				"BP28(R18)",
				"1",
				"12",
				"15",
				"16",
				"5.5.3",
				"DSS05.04",
				"DSS05.10",
				"DSS06.10",
				"3.1.8",
				"CCI-000044",
				"CCI-002236",
				"CCI-002237",
				"CCI-002238",
				"4.3.3.6.1",
				"4.3.3.6.2",
				"4.3.3.6.3",
				"4.3.3.6.4",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.3.6.9",
				"SR 1.1",
				"SR 1.10",
				"SR 1.2",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"0421",
				"0422",
				"0431",
				"0974",
				"1173",
				"1401",
				"1504",
				"1505",
				"1546",
				"1557",
				"1558",
				"1559",
				"1560",
				"1561",
				"A.18.1.4",
				"A.9.2.1",
				"A.9.2.4",
				"A.9.3.1",
				"A.9.4.2",
				"A.9.4.3",
				"CM-6(a)",
				"AC-7(b)",
				"PR.AC-7",
				"FIA_AFL.1",
				"Req-8.1.7",
				"SRG-OS-000329-GPOS-00128",
				"SRG-OS-000021-GPOS-00005",
				"SRG-OS-000329-VMM-001180"
			],
			"description": "This rule configures the system to lock out accounts during a specified time period after a\nnumber of incorrect login attempts using <code>pam_faillock.so</code>.\n\npam_faillock.so module requires multiple entries in pam files. These entries must be carefully\ndefined to work as expected. In order to avoid any errors when manually editing these files,\nit is recommended to use the appropriate tools, such as <code>authselect</code> or <code>authconfig</code>,\ndepending on the OS version.",
			"rationale": "Locking out user accounts after a number of incorrect attempts prevents direct password\nguessing attacks. Ensuring that an administrator is involved in unlocking locked accounts\ndraws appropriate attention to such situations.",
			"warnings": [
				{
					"text": "If the system supports the new <code>/etc/security/faillock.conf</code> file but the\npam_faillock.so parameters are defined directly in <code>/etc/pam.d/system-auth</code> and\n<code>/etc/pam.d/password-auth</code>, the remediation will migrate the <code>unlock_time</code> parameter\nto <code>/etc/security/faillock.conf</code> to ensure compatibility with <code>authselect</code> tool.\nThe parameters <code>deny</code> and <code>fail_interval</code>, if used, also have to be migrated\nby their respective remediation.",
					"category": "general"
				},
				{
					"text": "If the system relies on <code>authselect</code> tool to manage PAM settings, the remediation\nwill also use <code>authselect</code> tool. However, if any manual modification was made in\nPAM files, the <code>authselect</code> integrity check will fail and the remediation will be\naborted in order to preserve intentional changes. In this case, an informative message will\nbe shown in the remediation report.\nIf the system supports the <code>/etc/security/faillock.conf</code> file, the pam_faillock\nparameters should be defined in <code>faillock.conf</code> file.",
					"category": "general"
				}
			],
			"platforms": [
				"#pam"
			],
			"oval_definition_id": "oval:ssg-accounts_passwords_pam_faillock_unlock_time:def:1",
			"remediations": [
				{
					"remediation_id": "accounts_passwords_pam_faillock_unlock_time",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q pam; then\n\nvar_accounts_passwords_pam_faillock_unlock_time='1800'\n\n\nif [ -f /usr/bin/authselect ]; then\n    if ! authselect check; then\necho \"\nauthselect integrity check failed. Remediation aborted!\nThis remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\nIt is not recommended to manually edit the PAM files when authselect tool is available.\nIn cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\nexit 1\nfi\nauthselect enable-feature with-faillock\n\nauthselect apply-changes -b\nelse\n    AUTH_FILES=(\"/etc/pam.d/system-auth\" \"/etc/pam.d/password-auth\")\nfor pam_file in \"${AUTH_FILES[@]}\"\ndo\n    if ! grep -qE '^\\s*auth\\s+required\\s+pam_faillock\\.so\\s+(preauth silent|authfail).*$' \"$pam_file\" ; then\n        sed -i --follow-symlinks '/^auth.*sufficient.*pam_unix.so.*/i auth        required      pam_faillock.so preauth silent' \"$pam_file\"\n        sed -i --follow-symlinks '/^auth.*required.*pam_deny.so.*/i auth        required      pam_faillock.so authfail' \"$pam_file\"\n        sed -i --follow-symlinks '/^account.*required.*pam_unix.so.*/i account     required      pam_faillock.so' \"$pam_file\"\n    fi\n    sed -Ei 's/(auth.*)(\\[default=die\\])(.*pam_faillock.so)/\\1required     \\3/g' \"$pam_file\"\ndone\nfi\nAUTH_FILES=(\"/etc/pam.d/system-auth\" \"/etc/pam.d/password-auth\")\nFAILLOCK_CONF=\"/etc/security/faillock.conf\"\nif [ -f $FAILLOCK_CONF ]; then\n    regex=\"^\\s*unlock_time\\s*=\"\n    line=\"unlock_time = $var_accounts_passwords_pam_faillock_unlock_time\"\n    if ! grep -q $regex $FAILLOCK_CONF; then\n        echo $line >> $FAILLOCK_CONF\n    else\n        sed -i --follow-symlinks 's|^\\s*\\(unlock_time\\s*=\\s*\\)\\(\\S\\+\\)|\\1'\"$var_accounts_passwords_pam_faillock_unlock_time\"'|g' $FAILLOCK_CONF\n    fi\n    for pam_file in \"${AUTH_FILES[@]}\"\n    do\n        if [ -e \"$pam_file\" ] ; then\n            PAM_FILE_PATH=\"$pam_file\"\n            if [ -f /usr/bin/authselect ]; then\n                if ! authselect check; then\n                    echo \"\n                    authselect integrity check failed. Remediation aborted!\n                    This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\n                    It is not recommended to manually edit the PAM files when authselect tool is available.\n                    In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\n                    exit 1\n                    fi\n                CURRENT_PROFILE=$(authselect current -r | awk '{ print $1 }')\n                # If not already in use, a custom profile is created preserving the enabled features.\n                if [[ ! $CURRENT_PROFILE == custom/* ]]; then\n                    ENABLED_FEATURES=$(authselect current | tail -n+3 | awk '{ print $2 }')\n                    authselect create-profile hardening -b $CURRENT_PROFILE\n                    CURRENT_PROFILE=\"custom/hardening\"\n                    \n                    authselect apply-changes -b --backup=before-hardening-custom-profile\n                    authselect select $CURRENT_PROFILE\n                    for feature in $ENABLED_FEATURES; do\n                        authselect enable-feature $feature;\n                    done\n                    \n                    authselect apply-changes -b --backup=after-hardening-custom-profile\n                fi\n                PAM_FILE_NAME=$(basename \"$pam_file\")\n                PAM_FILE_PATH=\"/etc/authselect/$CURRENT_PROFILE/$PAM_FILE_NAME\"\n                \n                authselect apply-changes -b\n            fi\n            \n        if grep -qP '^\\s*auth\\s.*\\bpam_faillock.so\\s.*\\bunlock_time\\b' \"$PAM_FILE_PATH\"; then\n            sed -i -E --follow-symlinks 's/(.*auth.*pam_faillock.so.*)\\bunlock_time\\b=?[[:alnum:]]*(.*)/\\1\\2/g' \"$PAM_FILE_PATH\"\n        fi\n            if [ -f /usr/bin/authselect ]; then\n                \n                authselect apply-changes -b\n            fi\n        else\n            echo \"$pam_file was not found\" >&2\n        fi\n    done\nelse\n    for pam_file in \"${AUTH_FILES[@]}\"\n    do\n        if ! grep -qE '^\\s*auth.*pam_faillock.so (preauth|authfail).*unlock_time' \"$pam_file\"; then\n            sed -i --follow-symlinks '/^auth.*required.*pam_faillock.so.*preauth.*silent.*/ s/$/ unlock_time='\"$var_accounts_passwords_pam_faillock_unlock_time\"'/' \"$pam_file\"\n            sed -i --follow-symlinks '/^auth.*required.*pam_faillock.so.*authfail.*/ s/$/ unlock_time='\"$var_accounts_passwords_pam_faillock_unlock_time\"'/' \"$pam_file\"\n        else\n            sed -i --follow-symlinks 's/\\(^auth.*required.*pam_faillock.so.*preauth.*silent.*\\)\\('\"unlock_time\"'=\\)[0-9]\\+\\(.*\\)/\\1\\2'\"$var_accounts_passwords_pam_faillock_unlock_time\"'\\3/' \"$pam_file\"\n            sed -i --follow-symlinks 's/\\(^auth.*required.*pam_faillock.so.*authfail.*\\)\\('\"unlock_time\"'=\\)[0-9]\\+\\(.*\\)/\\1\\2'\"$var_accounts_passwords_pam_faillock_unlock_time\"'\\3/' \"$pam_file\"\n        fi\n    done\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "accounts_passwords_pam_faillock_unlock_time",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83588-4\n  - CJIS-5.5.3\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(b)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.7\n  - accounts_passwords_pam_faillock_unlock_time\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set Lockout Time for Failed Password Attempts - Check if system relies on\n    authselect tool\n  ansible.builtin.stat:\n    path: /usr/bin/authselect\n  register: result_authselect_present\n  when: '\"pam\" in ansible_facts.packages'\n  tags:\n  - CCE-83588-4\n  - CJIS-5.5.3\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(b)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.7\n  - accounts_passwords_pam_faillock_unlock_time\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set Lockout Time for Failed Password Attempts - Remediation where authselect\n    tool is present\n  block:\n\n  - name: Set Lockout Time for Failed Password Attempts - Check integrity of authselect\n      current profile\n    ansible.builtin.command:\n      cmd: authselect check\n    register: result_authselect_check_cmd\n    changed_when: false\n    ignore_errors: true\n\n  - name: Set Lockout Time for Failed Password Attempts - Informative message based\n      on the authselect integrity check result\n    ansible.builtin.assert:\n      that:\n      - result_authselect_check_cmd is success\n      fail_msg:\n      - authselect integrity check failed. Remediation aborted!\n      - This remediation could not be applied because an authselect profile was not\n        selected or the selected profile is not intact.\n      - It is not recommended to manually edit the PAM files when authselect tool\n        is available.\n      - In cases where the default authselect profile does not cover a specific demand,\n        a custom authselect profile is recommended.\n      success_msg:\n      - authselect integrity check passed\n\n  - name: Set Lockout Time for Failed Password Attempts - Get authselect current features\n    ansible.builtin.shell:\n      cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n    register: result_authselect_features\n    changed_when: false\n    when:\n    - result_authselect_check_cmd is success\n\n  - name: Set Lockout Time for Failed Password Attempts - Ensure \"with-faillock\" feature\n      is enabled using authselect tool\n    ansible.builtin.command:\n      cmd: authselect enable-feature with-faillock\n    register: result_authselect_enable_feature_cmd\n    when:\n    - result_authselect_check_cmd is success\n    - result_authselect_features.stdout is not search(\"with-faillock\")\n\n  - name: Set Lockout Time for Failed Password Attempts - Ensure authselect changes\n      are applied\n    ansible.builtin.command:\n      cmd: authselect apply-changes -b\n    when:\n    - result_authselect_enable_feature_cmd is not skipped\n    - result_authselect_enable_feature_cmd is success\n  when:\n  - '\"pam\" in ansible_facts.packages'\n  - result_authselect_present.stat.exists\n  tags:\n  - CCE-83588-4\n  - CJIS-5.5.3\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(b)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.7\n  - accounts_passwords_pam_faillock_unlock_time\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set Lockout Time for Failed Password Attempts - Remediation where authselect\n    tool is not present\n  block:\n\n  - name: Set Lockout Time for Failed Password Attempts - Check if pam_faillock.so\n      is already enabled\n    ansible.builtin.lineinfile:\n      path: /etc/pam.d/system-auth\n      regexp: .*auth.*pam_faillock.so (preauth|authfail)\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_faillock_is_enabled\n\n  - name: Set Lockout Time for Failed Password Attempts - Enable pam_faillock.so preauth\n      editing PAM files\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      line: auth        required      pam_faillock.so preauth\n      insertbefore: ^auth.*sufficient.*pam_unix.so.*\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_is_enabled.found == 0\n\n  - name: Set Lockout Time for Failed Password Attempts - Enable pam_faillock.so authfail\n      editing PAM files\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      line: auth        required      pam_faillock.so authfail\n      insertbefore: ^auth.*required.*pam_deny.so.*\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_is_enabled.found == 0\n\n  - name: Set Lockout Time for Failed Password Attempts - Enable pam_faillock.so account\n      section editing PAM files\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      line: account     required      pam_faillock.so\n      insertbefore: ^account.*required.*pam_unix.so.*\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_is_enabled.found == 0\n  when:\n  - '\"pam\" in ansible_facts.packages'\n  - not result_authselect_present.stat.exists\n  tags:\n  - CCE-83588-4\n  - CJIS-5.5.3\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(b)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.7\n  - accounts_passwords_pam_faillock_unlock_time\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_accounts_passwords_pam_faillock_unlock_time # promote to variable\n  set_fact:\n    var_accounts_passwords_pam_faillock_unlock_time: !!str 1800\n  tags:\n    - always\n\n- name: Set Lockout Time for Failed Password Attempts - Check the presence of /etc/security/faillock.conf\n    file\n  ansible.builtin.stat:\n    path: /etc/security/faillock.conf\n  register: result_faillock_conf_check\n  when: '\"pam\" in ansible_facts.packages'\n  tags:\n  - CCE-83588-4\n  - CJIS-5.5.3\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(b)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.7\n  - accounts_passwords_pam_faillock_unlock_time\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set Lockout Time for Failed Password Attempts - Ensure the pam_faillock.so\n    unlock_time parameter in /etc/security/faillock.conf\n  ansible.builtin.lineinfile:\n    path: /etc/security/faillock.conf\n    regexp: ^\\s*unlock_time\\s*=\n    line: unlock_time = {{ var_accounts_passwords_pam_faillock_unlock_time }}\n    state: present\n  when:\n  - '\"pam\" in ansible_facts.packages'\n  - result_faillock_conf_check.stat.exists\n  tags:\n  - CCE-83588-4\n  - CJIS-5.5.3\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(b)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.7\n  - accounts_passwords_pam_faillock_unlock_time\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set Lockout Time for Failed Password Attempts - Ensure the pam_faillock.so\n    unlock_time parameter not in PAM files\n  block:\n\n  - name: Set Lockout Time for Failed Password Attempts - Check if /etc/pam.d/system-auth\n      file is present\n    ansible.builtin.stat:\n      path: /etc/pam.d/system-auth\n    register: result_pam_file_present\n\n  - name: Set Lockout Time for Failed Password Attempts - Check the proper remediation\n      for the system\n    block:\n\n    - name: Set Lockout Time for Failed Password Attempts - Define the PAM file to\n        be edited as a local fact\n      ansible.builtin.set_fact:\n        pam_file_path: /etc/pam.d/system-auth\n\n    - name: Set Lockout Time for Failed Password Attempts - Check if system relies\n        on authselect\n      ansible.builtin.stat:\n        path: /usr/bin/authselect\n      register: result_authselect_present\n\n    - name: Set Lockout Time for Failed Password Attempts - Remediate using authselect\n      block:\n\n      - name: Set Lockout Time for Failed Password Attempts - Check integrity of authselect\n          current profile\n        ansible.builtin.command:\n          cmd: authselect check\n        register: result_authselect_check_cmd\n        changed_when: false\n        ignore_errors: true\n\n      - name: Set Lockout Time for Failed Password Attempts - Informative message\n          based on the authselect integrity check result\n        ansible.builtin.assert:\n          that:\n          - result_authselect_check_cmd is success\n          fail_msg:\n          - authselect integrity check failed. Remediation aborted!\n          - This remediation could not be applied because an authselect profile was\n            not selected or the selected profile is not intact.\n          - It is not recommended to manually edit the PAM files when authselect tool\n            is available.\n          - In cases where the default authselect profile does not cover a specific\n            demand, a custom authselect profile is recommended.\n          success_msg:\n          - authselect integrity check passed\n\n      - name: Set Lockout Time for Failed Password Attempts - Get authselect current\n          profile\n        ansible.builtin.shell:\n          cmd: authselect current -r | awk '{ print $1 }'\n        register: result_authselect_profile\n        changed_when: false\n        when:\n        - result_authselect_check_cmd is success\n\n      - name: Set Lockout Time for Failed Password Attempts - Define the current authselect\n          profile as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: '{{ result_authselect_profile.stdout }}'\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is match(\"custom/\")\n\n      - name: Set Lockout Time for Failed Password Attempts - Define the new authselect\n          custom profile as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: custom/hardening\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is not match(\"custom/\")\n\n      - name: Set Lockout Time for Failed Password Attempts - Get authselect current\n          features to also enable them in the custom profile\n        ansible.builtin.shell:\n          cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n        register: result_authselect_features\n        changed_when: false\n        when:\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Set Lockout Time for Failed Password Attempts - Check if any custom\n          profile with the same name was already created\n        ansible.builtin.stat:\n          path: /etc/authselect/{{ authselect_custom_profile }}\n        register: result_authselect_custom_profile_present\n        changed_when: false\n        when:\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Set Lockout Time for Failed Password Attempts - Create an authselect\n          custom profile based on the current profile\n        ansible.builtin.command:\n          cmd: authselect create-profile hardening -b {{ authselect_current_profile\n            }}\n        when:\n        - result_authselect_check_cmd is success\n        - authselect_current_profile is not match(\"custom/\")\n        - not result_authselect_custom_profile_present.stat.exists\n\n      - name: Set Lockout Time for Failed Password Attempts - Ensure authselect changes\n          are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=before-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Set Lockout Time for Failed Password Attempts - Ensure the authselect\n          custom profile is selected\n        ansible.builtin.command:\n          cmd: authselect select {{ authselect_custom_profile }}\n        register: result_pam_authselect_select_profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Set Lockout Time for Failed Password Attempts - Restore the authselect\n          features in the custom profile\n        ansible.builtin.command:\n          cmd: authselect enable-feature {{ item }}\n        loop: '{{ result_authselect_features.stdout_lines }}'\n        register: result_pam_authselect_restore_features\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_features is not skipped\n        - result_pam_authselect_select_profile is not skipped\n\n      - name: Set Lockout Time for Failed Password Attempts - Ensure authselect changes\n          are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=after-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - result_pam_authselect_restore_features is not skipped\n\n      - name: Set Lockout Time for Failed Password Attempts - Change the PAM file\n          to be edited according to the custom authselect profile\n        ansible.builtin.set_fact:\n          pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path\n            | basename }}\n      when:\n      - result_authselect_present.stat.exists\n\n    - name: Set Lockout Time for Failed Password Attempts - Ensure the \"unlock_time\"\n        option from \"pam_faillock.so\" is not present in {{ pam_file_path }}\n      ansible.builtin.replace:\n        dest: '{{ pam_file_path }}'\n        regexp: (.*auth.*pam_faillock.so.*)\\bunlock_time\\b=?[0-9a-zA-Z]*(.*)\n        replace: \\1\\2\n      register: result_pam_option_removal\n\n    - name: Set Lockout Time for Failed Password Attempts - Ensure authselect changes\n        are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b\n      when:\n      - result_authselect_present.stat.exists\n      - result_pam_option_removal is changed\n    when:\n    - result_pam_file_present.stat.exists\n\n  - name: Set Lockout Time for Failed Password Attempts - Check if /etc/pam.d/password-auth\n      file is present\n    ansible.builtin.stat:\n      path: /etc/pam.d/password-auth\n    register: result_pam_file_present\n\n  - name: Set Lockout Time for Failed Password Attempts - Check the proper remediation\n      for the system\n    block:\n\n    - name: Set Lockout Time for Failed Password Attempts - Define the PAM file to\n        be edited as a local fact\n      ansible.builtin.set_fact:\n        pam_file_path: /etc/pam.d/password-auth\n\n    - name: Set Lockout Time for Failed Password Attempts - Check if system relies\n        on authselect\n      ansible.builtin.stat:\n        path: /usr/bin/authselect\n      register: result_authselect_present\n\n    - name: Set Lockout Time for Failed Password Attempts - Remediate using authselect\n      block:\n\n      - name: Set Lockout Time for Failed Password Attempts - Check integrity of authselect\n          current profile\n        ansible.builtin.command:\n          cmd: authselect check\n        register: result_authselect_check_cmd\n        changed_when: false\n        ignore_errors: true\n\n      - name: Set Lockout Time for Failed Password Attempts - Informative message\n          based on the authselect integrity check result\n        ansible.builtin.assert:\n          that:\n          - result_authselect_check_cmd is success\n          fail_msg:\n          - authselect integrity check failed. Remediation aborted!\n          - This remediation could not be applied because an authselect profile was\n            not selected or the selected profile is not intact.\n          - It is not recommended to manually edit the PAM files when authselect tool\n            is available.\n          - In cases where the default authselect profile does not cover a specific\n            demand, a custom authselect profile is recommended.\n          success_msg:\n          - authselect integrity check passed\n\n      - name: Set Lockout Time for Failed Password Attempts - Get authselect current\n          profile\n        ansible.builtin.shell:\n          cmd: authselect current -r | awk '{ print $1 }'\n        register: result_authselect_profile\n        changed_when: false\n        when:\n        - result_authselect_check_cmd is success\n\n      - name: Set Lockout Time for Failed Password Attempts - Define the current authselect\n          profile as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: '{{ result_authselect_profile.stdout }}'\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is match(\"custom/\")\n\n      - name: Set Lockout Time for Failed Password Attempts - Define the new authselect\n          custom profile as a local fact\n        ansible.builtin.set_fact:\n          authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n          authselect_custom_profile: custom/hardening\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_profile.stdout is not match(\"custom/\")\n\n      - name: Set Lockout Time for Failed Password Attempts - Get authselect current\n          features to also enable them in the custom profile\n        ansible.builtin.shell:\n          cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n        register: result_authselect_features\n        changed_when: false\n        when:\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Set Lockout Time for Failed Password Attempts - Check if any custom\n          profile with the same name was already created\n        ansible.builtin.stat:\n          path: /etc/authselect/{{ authselect_custom_profile }}\n        register: result_authselect_custom_profile_present\n        changed_when: false\n        when:\n        - authselect_current_profile is not match(\"custom/\")\n\n      - name: Set Lockout Time for Failed Password Attempts - Create an authselect\n          custom profile based on the current profile\n        ansible.builtin.command:\n          cmd: authselect create-profile hardening -b {{ authselect_current_profile\n            }}\n        when:\n        - result_authselect_check_cmd is success\n        - authselect_current_profile is not match(\"custom/\")\n        - not result_authselect_custom_profile_present.stat.exists\n\n      - name: Set Lockout Time for Failed Password Attempts - Ensure authselect changes\n          are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=before-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Set Lockout Time for Failed Password Attempts - Ensure the authselect\n          custom profile is selected\n        ansible.builtin.command:\n          cmd: authselect select {{ authselect_custom_profile }}\n        register: result_pam_authselect_select_profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - authselect_current_profile is not match(\"custom/\")\n        - authselect_custom_profile is not match(authselect_current_profile)\n\n      - name: Set Lockout Time for Failed Password Attempts - Restore the authselect\n          features in the custom profile\n        ansible.builtin.command:\n          cmd: authselect enable-feature {{ item }}\n        loop: '{{ result_authselect_features.stdout_lines }}'\n        register: result_pam_authselect_restore_features\n        when:\n        - result_authselect_profile is not skipped\n        - result_authselect_features is not skipped\n        - result_pam_authselect_select_profile is not skipped\n\n      - name: Set Lockout Time for Failed Password Attempts - Ensure authselect changes\n          are applied\n        ansible.builtin.command:\n          cmd: authselect apply-changes -b --backup=after-hardening-custom-profile\n        when:\n        - result_authselect_check_cmd is success\n        - result_authselect_profile is not skipped\n        - result_pam_authselect_restore_features is not skipped\n\n      - name: Set Lockout Time for Failed Password Attempts - Change the PAM file\n          to be edited according to the custom authselect profile\n        ansible.builtin.set_fact:\n          pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path\n            | basename }}\n      when:\n      - result_authselect_present.stat.exists\n\n    - name: Set Lockout Time for Failed Password Attempts - Ensure the \"unlock_time\"\n        option from \"pam_faillock.so\" is not present in {{ pam_file_path }}\n      ansible.builtin.replace:\n        dest: '{{ pam_file_path }}'\n        regexp: (.*auth.*pam_faillock.so.*)\\bunlock_time\\b=?[0-9a-zA-Z]*(.*)\n        replace: \\1\\2\n      register: result_pam_option_removal\n\n    - name: Set Lockout Time for Failed Password Attempts - Ensure authselect changes\n        are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b\n      when:\n      - result_authselect_present.stat.exists\n      - result_pam_option_removal is changed\n    when:\n    - result_pam_file_present.stat.exists\n  when:\n  - '\"pam\" in ansible_facts.packages'\n  - result_faillock_conf_check.stat.exists\n  tags:\n  - CCE-83588-4\n  - CJIS-5.5.3\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(b)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.7\n  - accounts_passwords_pam_faillock_unlock_time\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set Lockout Time for Failed Password Attempts - Ensure the pam_faillock.so\n    unlock_time parameter in PAM files\n  block:\n\n  - name: Set Lockout Time for Failed Password Attempts - Check if pam_faillock.so\n      unlock_time parameter is already enabled in pam files\n    ansible.builtin.lineinfile:\n      path: /etc/pam.d/system-auth\n      regexp: .*auth.*pam_faillock.so (preauth|authfail).*unlock_time\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_faillock_unlock_time_parameter_is_present\n\n  - name: Set Lockout Time for Failed Password Attempts - Ensure the inclusion of\n      pam_faillock.so preauth unlock_time parameter in auth section\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      backrefs: true\n      regexp: (^\\s*auth\\s+)([\\w\\[].*\\b)(\\s+pam_faillock.so preauth.*)\n      line: \\1required\\3 unlock_time={{ var_accounts_passwords_pam_faillock_unlock_time\n        }}\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_unlock_time_parameter_is_present.found == 0\n\n  - name: Set Lockout Time for Failed Password Attempts - Ensure the inclusion of\n      pam_faillock.so authfail unlock_time parameter in auth section\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      backrefs: true\n      regexp: (^\\s*auth\\s+)([\\w\\[].*\\b)(\\s+pam_faillock.so authfail.*)\n      line: \\1required\\3 unlock_time={{ var_accounts_passwords_pam_faillock_unlock_time\n        }}\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_unlock_time_parameter_is_present.found == 0\n\n  - name: Set Lockout Time for Failed Password Attempts - Ensure the desired value\n      for pam_faillock.so preauth unlock_time parameter in auth section\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      backrefs: true\n      regexp: (^\\s*auth\\s+)([\\w\\[].*\\b)(\\s+pam_faillock.so preauth.*)(unlock_time)=[0-9]+(.*)\n      line: \\1required\\3\\4={{ var_accounts_passwords_pam_faillock_unlock_time }}\\5\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_unlock_time_parameter_is_present.found > 0\n\n  - name: Set Lockout Time for Failed Password Attempts - Ensure the desired value\n      for pam_faillock.so authfail unlock_time parameter in auth section\n    ansible.builtin.lineinfile:\n      path: '{{ item }}'\n      backrefs: true\n      regexp: (^\\s*auth\\s+)([\\w\\[].*\\b)(\\s+pam_faillock.so authfail.*)(unlock_time)=[0-9]+(.*)\n      line: \\1required\\3\\4={{ var_accounts_passwords_pam_faillock_unlock_time }}\\5\n      state: present\n    loop:\n    - /etc/pam.d/system-auth\n    - /etc/pam.d/password-auth\n    when:\n    - result_pam_faillock_unlock_time_parameter_is_present.found > 0\n  when:\n  - '\"pam\" in ansible_facts.packages'\n  - not result_faillock_conf_check.stat.exists\n  tags:\n  - CCE-83588-4\n  - CJIS-5.5.3\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AC-7(b)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.1.7\n  - accounts_passwords_pam_faillock_unlock_time\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_accounts_password_pam_dcredit": {
			"rule_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_dcredit",
			"title": "Ensure PAM Enforces Password Requirements - Minimum Digit Characters",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83566-0"
			],
			"references": [
				"BP28(R18)",
				"1",
				"12",
				"15",
				"16",
				"5",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"DSS05.10",
				"DSS06.03",
				"DSS06.10",
				"CCI-000194",
				"4.3.3.2.2",
				"4.3.3.5.1",
				"4.3.3.5.2",
				"4.3.3.6.1",
				"4.3.3.6.2",
				"4.3.3.6.3",
				"4.3.3.6.4",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.3.6.9",
				"4.3.3.7.2",
				"4.3.3.7.4",
				"SR 1.1",
				"SR 1.10",
				"SR 1.2",
				"SR 1.3",
				"SR 1.4",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"SR 2.1",
				"0421",
				"0422",
				"0431",
				"0974",
				"1173",
				"1401",
				"1504",
				"1505",
				"1546",
				"1557",
				"1558",
				"1559",
				"1560",
				"1561",
				"A.18.1.4",
				"A.7.1.1",
				"A.9.2.1",
				"A.9.2.2",
				"A.9.2.3",
				"A.9.2.4",
				"A.9.2.6",
				"A.9.3.1",
				"A.9.4.2",
				"A.9.4.3",
				"IA-5(c)",
				"IA-5(1)(a)",
				"CM-6(a)",
				"IA-5(4)",
				"PR.AC-1",
				"PR.AC-6",
				"PR.AC-7",
				"FMT_MOF_EXT.1",
				"Req-8.2.3",
				"SRG-OS-000071-GPOS-00039",
				"SRG-OS-000071-VMM-000380"
			],
			"description": "The pam_pwquality module&#x27;s <code>dcredit</code> parameter controls requirements for\nusage of digits in a password. When set to a negative number, any password will be required to\ncontain that many digits. When set to a positive number, pam_pwquality will grant +1 additional\nlength credit for each digit. Modify the <code>dcredit</code> setting in\n<code>/etc/security/pwquality.conf</code> to require the use of a digit in passwords.",
			"rationale": "Use of a complex password helps to increase the time and resources required\nto compromise the password. Password complexity, or strength, is a measure of\nthe effectiveness of a password in resisting attempts at guessing and brute-force\nattacks.\n<br><br>\nPassword complexity is one factor of several that determines how long it takes\nto crack a password. The more complex the password, the greater the number of\npossible combinations that need to be tested before the password is compromised.\nRequiring digits makes password guessing attacks more difficult by ensuring a larger\nsearch space.",
			"platforms": [
				"#pam"
			],
			"oval_definition_id": "oval:ssg-accounts_password_pam_dcredit:def:1",
			"remediations": [
				{
					"remediation_id": "accounts_password_pam_dcredit",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q pam; then\n\nvar_password_pam_dcredit='-1'\n\n\n# Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed.\n# Otherwise, regular sed command will do.\nsed_command=('sed' '-i')\nif test -L \"/etc/security/pwquality.conf\"; then\n    sed_command+=('--follow-symlinks')\nfi\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^dcredit\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_dcredit\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^dcredit\\\\>\" \"/etc/security/pwquality.conf\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    \"${sed_command[@]}\" \"s/^dcredit\\\\>.*/$escaped_formatted_output/gi\" \"/etc/security/pwquality.conf\"\nelse\n    # \\n is precaution for case where file ends without trailing newline\n    cce=\"CCE-83566-0\"\n    printf '\\n# Per %s: Set %s in %s\\n' \"$cce\" \"$formatted_output\" \"/etc/security/pwquality.conf\" >> \"/etc/security/pwquality.conf\"\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/security/pwquality.conf\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "accounts_password_pam_dcredit",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83566-0\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - accounts_password_pam_dcredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_password_pam_dcredit # promote to variable\n  set_fact:\n    var_password_pam_dcredit: !!str -1\n  tags:\n    - always\n\n- name: Ensure PAM variable dcredit is set accordingly\n  lineinfile:\n    create: true\n    dest: /etc/security/pwquality.conf\n    regexp: ^#?\\s*dcredit\n    line: dcredit = {{ var_password_pam_dcredit }}\n  when: '\"pam\" in ansible_facts.packages'\n  tags:\n  - CCE-83566-0\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - accounts_password_pam_dcredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_accounts_password_pam_lcredit": {
			"rule_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_lcredit",
			"title": "Ensure PAM Enforces Password Requirements - Minimum Lowercase Characters",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83570-2"
			],
			"references": [
				"BP28(R18)",
				"1",
				"12",
				"15",
				"16",
				"5",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"DSS05.10",
				"DSS06.03",
				"DSS06.10",
				"CCI-000193",
				"4.3.3.2.2",
				"4.3.3.5.1",
				"4.3.3.5.2",
				"4.3.3.6.1",
				"4.3.3.6.2",
				"4.3.3.6.3",
				"4.3.3.6.4",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.3.6.9",
				"4.3.3.7.2",
				"4.3.3.7.4",
				"SR 1.1",
				"SR 1.10",
				"SR 1.2",
				"SR 1.3",
				"SR 1.4",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"SR 2.1",
				"0421",
				"0422",
				"0431",
				"0974",
				"1173",
				"1401",
				"1504",
				"1505",
				"1546",
				"1557",
				"1558",
				"1559",
				"1560",
				"1561",
				"A.18.1.4",
				"A.7.1.1",
				"A.9.2.1",
				"A.9.2.2",
				"A.9.2.3",
				"A.9.2.4",
				"A.9.2.6",
				"A.9.3.1",
				"A.9.4.2",
				"A.9.4.3",
				"IA-5(c)",
				"IA-5(1)(a)",
				"CM-6(a)",
				"IA-5(4)",
				"PR.AC-1",
				"PR.AC-6",
				"PR.AC-7",
				"FMT_MOF_EXT.1",
				"Req-8.2.3",
				"SRG-OS-000070-GPOS-00038",
				"SRG-OS-000070-VMM-000370"
			],
			"description": "The pam_pwquality module&#x27;s <code>lcredit</code> parameter controls requirements for\nusage of lowercase letters in a password. When set to a negative number, any password will be required to\ncontain that many lowercase characters. When set to a positive number, pam_pwquality will grant +1 additional\nlength credit for each lowercase character. Modify the <code>lcredit</code> setting in\n<code>/etc/security/pwquality.conf</code> to require the use of a lowercase character in passwords.",
			"rationale": "Use of a complex password helps to increase the time and resources required\nto compromise the password. Password complexity, or strength, is a measure of\nthe effectiveness of a password in resisting attempts at guessing and brute-force\nattacks.\n<br>\nPassword complexity is one factor of several that determines how long it takes\nto crack a password. The more complex the password, the greater the number of\npossble combinations that need to be tested before the password is compromised.\nRequiring a minimum number of lowercase characters makes password guessing attacks\nmore difficult by ensuring a larger search space.",
			"platforms": [
				"#pam"
			],
			"oval_definition_id": "oval:ssg-accounts_password_pam_lcredit:def:1",
			"remediations": [
				{
					"remediation_id": "accounts_password_pam_lcredit",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q pam; then\n\nvar_password_pam_lcredit='-1'\n\n\n# Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed.\n# Otherwise, regular sed command will do.\nsed_command=('sed' '-i')\nif test -L \"/etc/security/pwquality.conf\"; then\n    sed_command+=('--follow-symlinks')\nfi\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^lcredit\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_lcredit\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^lcredit\\\\>\" \"/etc/security/pwquality.conf\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    \"${sed_command[@]}\" \"s/^lcredit\\\\>.*/$escaped_formatted_output/gi\" \"/etc/security/pwquality.conf\"\nelse\n    # \\n is precaution for case where file ends without trailing newline\n    cce=\"CCE-83570-2\"\n    printf '\\n# Per %s: Set %s in %s\\n' \"$cce\" \"$formatted_output\" \"/etc/security/pwquality.conf\" >> \"/etc/security/pwquality.conf\"\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/security/pwquality.conf\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "accounts_password_pam_lcredit",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83570-2\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - accounts_password_pam_lcredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_password_pam_lcredit # promote to variable\n  set_fact:\n    var_password_pam_lcredit: !!str -1\n  tags:\n    - always\n\n- name: Ensure PAM variable lcredit is set accordingly\n  lineinfile:\n    create: true\n    dest: /etc/security/pwquality.conf\n    regexp: ^#?\\s*lcredit\n    line: lcredit = {{ var_password_pam_lcredit }}\n  when: '\"pam\" in ansible_facts.packages'\n  tags:\n  - CCE-83570-2\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - accounts_password_pam_lcredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_accounts_password_pam_minlen": {
			"rule_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_minlen",
			"title": "Ensure PAM Enforces Password Requirements - Minimum Length",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83579-3"
			],
			"references": [
				"BP28(R18)",
				"1",
				"12",
				"15",
				"16",
				"5",
				"5.6.2.1.1",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"DSS05.10",
				"DSS06.03",
				"DSS06.10",
				"CCI-000205",
				"4.3.3.2.2",
				"4.3.3.5.1",
				"4.3.3.5.2",
				"4.3.3.6.1",
				"4.3.3.6.2",
				"4.3.3.6.3",
				"4.3.3.6.4",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.3.6.9",
				"4.3.3.7.2",
				"4.3.3.7.4",
				"SR 1.1",
				"SR 1.10",
				"SR 1.2",
				"SR 1.3",
				"SR 1.4",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"SR 2.1",
				"0421",
				"0422",
				"0431",
				"0974",
				"1173",
				"1401",
				"1504",
				"1505",
				"1546",
				"1557",
				"1558",
				"1559",
				"1560",
				"1561",
				"A.18.1.4",
				"A.7.1.1",
				"A.9.2.1",
				"A.9.2.2",
				"A.9.2.3",
				"A.9.2.4",
				"A.9.2.6",
				"A.9.3.1",
				"A.9.4.2",
				"A.9.4.3",
				"IA-5(c)",
				"IA-5(1)(a)",
				"CM-6(a)",
				"IA-5(4)",
				"PR.AC-1",
				"PR.AC-6",
				"PR.AC-7",
				"FMT_MOF_EXT.1",
				"Req-8.2.3",
				"SRG-OS-000078-GPOS-00046",
				"SRG-OS-000072-VMM-000390",
				"SRG-OS-000078-VMM-000450"
			],
			"description": "The pam_pwquality module&#x27;s <code>minlen</code> parameter controls requirements for\nminimum characters required in a password. Add <code>minlen=7</code>\nafter pam_pwquality to set minimum password length requirements.",
			"rationale": "The shorter the password, the lower the number of possible combinations\nthat need to be tested before the password is compromised.\n<br>\nPassword complexity, or strength, is a measure of the effectiveness of a\npassword in resisting attempts at guessing and brute-force attacks.\nPassword length is one factor of several that helps to determine strength\nand how long it takes to crack a password. Use of more characters in a password\nhelps to exponentially increase the time and/or resources required to\ncompromise the password.",
			"platforms": [
				"#pam"
			],
			"oval_definition_id": "oval:ssg-accounts_password_pam_minlen:def:1",
			"remediations": [
				{
					"remediation_id": "accounts_password_pam_minlen",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q pam; then\n\nvar_password_pam_minlen='7'\n\n\n# Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed.\n# Otherwise, regular sed command will do.\nsed_command=('sed' '-i')\nif test -L \"/etc/security/pwquality.conf\"; then\n    sed_command+=('--follow-symlinks')\nfi\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^minlen\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_minlen\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^minlen\\\\>\" \"/etc/security/pwquality.conf\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    \"${sed_command[@]}\" \"s/^minlen\\\\>.*/$escaped_formatted_output/gi\" \"/etc/security/pwquality.conf\"\nelse\n    # \\n is precaution for case where file ends without trailing newline\n    cce=\"CCE-83579-3\"\n    printf '\\n# Per %s: Set %s in %s\\n' \"$cce\" \"$formatted_output\" \"/etc/security/pwquality.conf\" >> \"/etc/security/pwquality.conf\"\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/security/pwquality.conf\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "accounts_password_pam_minlen",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83579-3\n  - CJIS-5.6.2.1.1\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - accounts_password_pam_minlen\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_password_pam_minlen # promote to variable\n  set_fact:\n    var_password_pam_minlen: !!str 7\n  tags:\n    - always\n\n- name: Ensure PAM variable minlen is set accordingly\n  lineinfile:\n    create: true\n    dest: /etc/security/pwquality.conf\n    regexp: ^#?\\s*minlen\n    line: minlen = {{ var_password_pam_minlen }}\n  when: '\"pam\" in ansible_facts.packages'\n  tags:\n  - CCE-83579-3\n  - CJIS-5.6.2.1.1\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - accounts_password_pam_minlen\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_accounts_password_pam_ucredit": {
			"rule_id": "xccdf_org.ssgproject.content_rule_accounts_password_pam_ucredit",
			"title": "Ensure PAM Enforces Password Requirements - Minimum Uppercase Characters",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83568-6"
			],
			"references": [
				"BP28(R18)",
				"1",
				"12",
				"15",
				"16",
				"5",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"DSS05.10",
				"DSS06.03",
				"DSS06.10",
				"CCI-000192",
				"CCI-000193",
				"4.3.3.2.2",
				"4.3.3.5.1",
				"4.3.3.5.2",
				"4.3.3.6.1",
				"4.3.3.6.2",
				"4.3.3.6.3",
				"4.3.3.6.4",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.3.6.9",
				"4.3.3.7.2",
				"4.3.3.7.4",
				"SR 1.1",
				"SR 1.10",
				"SR 1.2",
				"SR 1.3",
				"SR 1.4",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"SR 2.1",
				"0421",
				"0422",
				"0431",
				"0974",
				"1173",
				"1401",
				"1504",
				"1505",
				"1546",
				"1557",
				"1558",
				"1559",
				"1560",
				"1561",
				"A.18.1.4",
				"A.7.1.1",
				"A.9.2.1",
				"A.9.2.2",
				"A.9.2.3",
				"A.9.2.4",
				"A.9.2.6",
				"A.9.3.1",
				"A.9.4.2",
				"A.9.4.3",
				"IA-5(c)",
				"IA-5(1)(a)",
				"CM-6(a)",
				"IA-5(4)",
				"PR.AC-1",
				"PR.AC-6",
				"PR.AC-7",
				"FMT_MOF_EXT.1",
				"Req-8.2.3",
				"SRG-OS-000069-GPOS-00037",
				"SRG-OS-000070-GPOS-00038",
				"SRG-OS-000069-VMM-000360"
			],
			"description": "The pam_pwquality module&#x27;s <code>ucredit=</code> parameter controls requirements for\nusage of uppercase letters in a password. When set to a negative number, any password will be required to\ncontain that many uppercase characters. When set to a positive number, pam_pwquality will grant +1 additional\nlength credit for each uppercase character. Modify the <code>ucredit</code> setting in\n<code>/etc/security/pwquality.conf</code> to require the use of an uppercase character in passwords.",
			"rationale": "Use of a complex password helps to increase the time and resources required to compromise the password.\nPassword complexity, or strength, is a measure of the effectiveness of a password in resisting attempts\nat guessing and brute-force attacks.\n<br><br>\nPassword complexity is one factor of several that determines how long it takes to crack a password. The more\ncomplex the password, the greater the number of possible combinations that need to be tested before\nthe password is compromised.",
			"platforms": [
				"#pam"
			],
			"oval_definition_id": "oval:ssg-accounts_password_pam_ucredit:def:1",
			"remediations": [
				{
					"remediation_id": "accounts_password_pam_ucredit",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q pam; then\n\nvar_password_pam_ucredit='-1'\n\n\n# Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed.\n# Otherwise, regular sed command will do.\nsed_command=('sed' '-i')\nif test -L \"/etc/security/pwquality.conf\"; then\n    sed_command+=('--follow-symlinks')\nfi\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^ucredit\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_ucredit\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^ucredit\\\\>\" \"/etc/security/pwquality.conf\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    \"${sed_command[@]}\" \"s/^ucredit\\\\>.*/$escaped_formatted_output/gi\" \"/etc/security/pwquality.conf\"\nelse\n    # \\n is precaution for case where file ends without trailing newline\n    cce=\"CCE-83568-6\"\n    printf '\\n# Per %s: Set %s in %s\\n' \"$cce\" \"$formatted_output\" \"/etc/security/pwquality.conf\" >> \"/etc/security/pwquality.conf\"\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/security/pwquality.conf\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "accounts_password_pam_ucredit",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83568-6\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - accounts_password_pam_ucredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_password_pam_ucredit # promote to variable\n  set_fact:\n    var_password_pam_ucredit: !!str -1\n  tags:\n    - always\n\n- name: Ensure PAM variable ucredit is set accordingly\n  lineinfile:\n    create: true\n    dest: /etc/security/pwquality.conf\n    regexp: ^#?\\s*ucredit\n    line: ucredit = {{ var_password_pam_ucredit }}\n  when: '\"pam\" in ansible_facts.packages'\n  tags:\n  - CCE-83568-6\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(4)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - accounts_password_pam_ucredit\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_set_password_hashing_algorithm_libuserconf": {
			"rule_id": "xccdf_org.ssgproject.content_rule_set_password_hashing_algorithm_libuserconf",
			"title": "Set Password Hashing Algorithm in /etc/libuser.conf",
			"result": "pass",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-88865-1"
			],
			"references": [
				"1",
				"12",
				"15",
				"16",
				"5",
				"5.6.2.2",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"DSS05.10",
				"DSS06.03",
				"DSS06.10",
				"3.13.11",
				"CCI-000196",
				"4.3.3.2.2",
				"4.3.3.5.1",
				"4.3.3.5.2",
				"4.3.3.6.1",
				"4.3.3.6.2",
				"4.3.3.6.3",
				"4.3.3.6.4",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.3.6.9",
				"4.3.3.7.2",
				"4.3.3.7.4",
				"SR 1.1",
				"SR 1.10",
				"SR 1.2",
				"SR 1.3",
				"SR 1.4",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"SR 2.1",
				"0418",
				"1055",
				"1402",
				"A.18.1.4",
				"A.7.1.1",
				"A.9.2.1",
				"A.9.2.2",
				"A.9.2.3",
				"A.9.2.4",
				"A.9.2.6",
				"A.9.3.1",
				"A.9.4.2",
				"A.9.4.3",
				"IA-5(c)",
				"IA-5(1)(c)",
				"CM-6(a)",
				"PR.AC-1",
				"PR.AC-6",
				"PR.AC-7",
				"Req-8.2.1",
				"SRG-OS-000073-GPOS-00041",
				"SRG-OS-000480-VMM-002000"
			],
			"description": "In <code>/etc/libuser.conf</code>, add or correct the following line in its\n<code>[defaults]</code> section to ensure the system will use the SHA-512\nalgorithm for password hashing:\n<pre>crypt_style = sha512</pre>",
			"rationale": "Passwords need to be protected at all times, and encryption is the standard\nmethod for protecting passwords. If passwords are not encrypted, they can\nbe plainly read (i.e., clear text) and easily compromised. Passwords that\nare encrypted with a weak algorithm are no more protected than if they are\nkepy in plain text.\n<br><br>\nThis setting ensures user and group account administration utilities are\nconfigured to store only encrypted representations of passwords.\nAdditionally, the <code>crypt_style</code> configuration option ensures the use\nof a strong hashing algorithm that makes password cracking attacks more\ndifficult.",
			"platforms": [
				"#libuser"
			],
			"oval_definition_id": "oval:ssg-set_password_hashing_algorithm_libuserconf:def:1",
			"remediations": [
				{
					"remediation_id": "set_password_hashing_algorithm_libuserconf",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q libuser; then\n\nLIBUSER_CONF=\"/etc/libuser.conf\"\nCRYPT_STYLE_REGEX='[[:space:]]*\\[defaults](.*(\\n)+)+?[[:space:]]*crypt_style[[:space:]]*'\n\n# Try find crypt_style in [defaults] section. If it is here, then change algorithm to sha512.\n# If it isn't here, then add it to [defaults] section.\nif grep -qzosP $CRYPT_STYLE_REGEX $LIBUSER_CONF ; then\n        sed -i \"s/\\(crypt_style[[:space:]]*=[[:space:]]*\\).*/\\1sha512/g\" $LIBUSER_CONF\nelif grep -qs \"\\[defaults]\" $LIBUSER_CONF ; then\n        sed -i \"/[[:space:]]*\\[defaults]/a crypt_style = sha512\" $LIBUSER_CONF\nelse\n        echo -e \"[defaults]\\ncrypt_style = sha512\" >> $LIBUSER_CONF\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "set_password_hashing_algorithm_libuserconf",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-88865-1\n  - CJIS-5.6.2.2\n  - NIST-800-171-3.13.11\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(c)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.1\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - set_password_hashing_algorithm_libuserconf\n\n- name: Set Password Hashing Algorithm in /etc/libuser.conf\n  lineinfile:\n    dest: /etc/libuser.conf\n    insertafter: ^\\s*\\[defaults]\n    regexp: ^#?crypt_style\n    line: crypt_style = sha512\n    state: present\n    create: true\n  when: '\"libuser\" in ansible_facts.packages'\n  tags:\n  - CCE-88865-1\n  - CJIS-5.6.2.2\n  - NIST-800-171-3.13.11\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(c)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.1\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - set_password_hashing_algorithm_libuserconf\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_set_password_hashing_algorithm_logindefs": {
			"rule_id": "xccdf_org.ssgproject.content_rule_set_password_hashing_algorithm_logindefs",
			"title": "Set Password Hashing Algorithm in /etc/login.defs",
			"result": "pass",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-90590-1"
			],
			"references": [
				"BP28(R32)",
				"1",
				"12",
				"15",
				"16",
				"5",
				"5.6.2.2",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"DSS05.10",
				"DSS06.03",
				"DSS06.10",
				"3.13.11",
				"CCI-000196",
				"4.3.3.2.2",
				"4.3.3.5.1",
				"4.3.3.5.2",
				"4.3.3.6.1",
				"4.3.3.6.2",
				"4.3.3.6.3",
				"4.3.3.6.4",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.3.6.9",
				"4.3.3.7.2",
				"4.3.3.7.4",
				"SR 1.1",
				"SR 1.10",
				"SR 1.2",
				"SR 1.3",
				"SR 1.4",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"SR 2.1",
				"0418",
				"1055",
				"1402",
				"A.18.1.4",
				"A.7.1.1",
				"A.9.2.1",
				"A.9.2.2",
				"A.9.2.3",
				"A.9.2.4",
				"A.9.2.6",
				"A.9.3.1",
				"A.9.4.2",
				"A.9.4.3",
				"IA-5(c)",
				"IA-5(1)(c)",
				"CM-6(a)",
				"PR.AC-1",
				"PR.AC-6",
				"PR.AC-7",
				"Req-8.2.1",
				"SRG-OS-000073-GPOS-00041"
			],
			"description": "In <code>/etc/login.defs</code>, add or correct the following line to ensure\nthe system will use SHA-512 as the hashing algorithm:\n<pre>ENCRYPT_METHOD SHA512</pre>",
			"rationale": "Passwords need to be protected at all times, and encryption is the standard method for protecting passwords.\nIf passwords are not encrypted, they can be plainly read (i.e., clear text) and easily compromised. Passwords\nthat are encrypted with a weak algorithm are no more protected than if they are kept in plain text.\n<br><br>\nUsing a stronger hashing algorithm makes password cracking attacks more difficult.",
			"platforms": [
				"#login_defs"
			],
			"oval_definition_id": "oval:ssg-set_password_hashing_algorithm_logindefs:def:1",
			"remediations": [
				{
					"remediation_id": "set_password_hashing_algorithm_logindefs",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q shadow-utils; then\n\nvar_password_hashing_algorithm='SHA512'\n\n\nif grep --silent ^ENCRYPT_METHOD /etc/login.defs ; then\n\tsed -i \"s/^ENCRYPT_METHOD .*/ENCRYPT_METHOD $var_password_hashing_algorithm/g\" /etc/login.defs\nelse\n\techo \"\" >> /etc/login.defs\n\techo \"ENCRYPT_METHOD $var_password_hashing_algorithm\" >> /etc/login.defs\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "set_password_hashing_algorithm_logindefs",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-90590-1\n  - CJIS-5.6.2.2\n  - NIST-800-171-3.13.11\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(c)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.1\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - set_password_hashing_algorithm_logindefs\n- name: XCCDF Value var_password_hashing_algorithm # promote to variable\n  set_fact:\n    var_password_hashing_algorithm: !!str SHA512\n  tags:\n    - always\n\n- name: Set Password Hashing Algorithm in /etc/login.defs\n  lineinfile:\n    dest: /etc/login.defs\n    regexp: ^#?ENCRYPT_METHOD\n    line: ENCRYPT_METHOD {{ var_password_hashing_algorithm }}\n    state: present\n    create: true\n  when: '\"shadow-utils\" in ansible_facts.packages'\n  tags:\n  - CCE-90590-1\n  - CJIS-5.6.2.2\n  - NIST-800-171-3.13.11\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(c)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.1\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n  - set_password_hashing_algorithm_logindefs\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_set_password_hashing_algorithm_passwordauth": {
			"rule_id": "xccdf_org.ssgproject.content_rule_set_password_hashing_algorithm_passwordauth",
			"title": "Set PAM''s Password Hashing Algorithm - password-auth",
			"result": "pass",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-85946-2"
			],
			"references": [
				"BP28(R32)",
				"1",
				"12",
				"15",
				"16",
				"5",
				"5.6.2.2",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"DSS05.10",
				"DSS06.03",
				"DSS06.10",
				"3.13.11",
				"CCI-000196",
				"CCI-000803",
				"4.3.3.2.2",
				"4.3.3.5.1",
				"4.3.3.5.2",
				"4.3.3.6.1",
				"4.3.3.6.2",
				"4.3.3.6.3",
				"4.3.3.6.4",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.3.6.9",
				"4.3.3.7.2",
				"4.3.3.7.4",
				"SR 1.1",
				"SR 1.10",
				"SR 1.2",
				"SR 1.3",
				"SR 1.4",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"SR 2.1",
				"0418",
				"1055",
				"1402",
				"A.18.1.4",
				"A.7.1.1",
				"A.9.2.1",
				"A.9.2.2",
				"A.9.2.3",
				"A.9.2.4",
				"A.9.2.6",
				"A.9.3.1",
				"A.9.4.2",
				"A.9.4.3",
				"IA-5(c)",
				"IA-5(1)(c)",
				"CM-6(a)",
				"PR.AC-1",
				"PR.AC-6",
				"PR.AC-7",
				"Req-8.2.1",
				"SRG-OS-000073-GPOS-00041",
				"SRG-OS-000120-GPOS-00061",
				"SRG-OS-000480-VMM-002000"
			],
			"description": "The PAM system service can be configured to only store encrypted\nrepresentations of passwords. In\n<code>/etc/pam.d/password-auth</code>,\nthe\n<code>password</code> section of the file controls which PAM modules execute\nduring a password change. Set the <code>pam_unix.so</code> module in the\n<code>password</code> section to include the argument <code>sha512</code>, as shown\nbelow:\n<br>\n<pre>password    sufficient    pam_unix.so sha512 <i>other arguments...</i></pre>\n<br>\nThis will help ensure when local users change their passwords, hashes for\nthe new passwords will be generated using the SHA-512 algorithm. This is\nthe default.",
			"rationale": "Passwords need to be protected at all times, and encryption is the standard\nmethod for protecting passwords. If passwords are not encrypted, they can\nbe plainly read (i.e., clear text) and easily compromised. Passwords that\nare encrypted with a weak algorithm are no more protected than if they are\nkepy in plain text.\n<br><br>\nThis setting ensures user and group account administration utilities are\nconfigured to store only encrypted representations of passwords.\nAdditionally, the <code>crypt_style</code> configuration option ensures the use\nof a strong hashing algorithm that makes password cracking attacks more\ndifficult.",
			"platforms": [
				"#pam"
			],
			"oval_definition_id": "oval:ssg-set_password_hashing_algorithm_passwordauth:def:1",
			"remediations": [
				{
					"remediation_id": "set_password_hashing_algorithm_passwordauth",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q pam; then\n\nif [ -e \"/etc/pam.d/password-auth\" ] ; then\n    PAM_FILE_PATH=\"/etc/pam.d/password-auth\"\n    if [ -f /usr/bin/authselect ]; then\n        if ! authselect check; then\n        echo \"\n        authselect integrity check failed. Remediation aborted!\n        This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\n        It is not recommended to manually edit the PAM files when authselect tool is available.\n        In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\n        exit 1\n        fi\n        CURRENT_PROFILE=$(authselect current -r | awk '{ print $1 }')\n        # If not already in use, a custom profile is created preserving the enabled features.\n        if [[ ! $CURRENT_PROFILE == custom/* ]]; then\n            ENABLED_FEATURES=$(authselect current | tail -n+3 | awk '{ print $2 }')\n            authselect create-profile hardening -b $CURRENT_PROFILE\n            CURRENT_PROFILE=\"custom/hardening\"\n            \n            authselect apply-changes -b --backup=before-hardening-custom-profile\n            authselect select $CURRENT_PROFILE\n            for feature in $ENABLED_FEATURES; do\n                authselect enable-feature $feature;\n            done\n            \n            authselect apply-changes -b --backup=after-hardening-custom-profile\n        fi\n        PAM_FILE_NAME=$(basename \"/etc/pam.d/password-auth\")\n        PAM_FILE_PATH=\"/etc/authselect/$CURRENT_PROFILE/$PAM_FILE_NAME\"\n        \n        authselect apply-changes -b\n    fi\n    if ! grep -qP '^\\s*password\\s+'\"sufficient\"'\\s+pam_unix.so\\s*.*' \"$PAM_FILE_PATH\"; then\n            # Line matching group + control + module was not found. Check group + module.\n            if [ \"$(grep -cP '^\\s*password\\s+.*\\s+pam_unix.so\\s*' \"$PAM_FILE_PATH\")\" -eq 1 ]; then\n                # The control is updated only if one single line matches.\n                sed -i -E --follow-symlinks 's/^(\\s*password\\s+).*(\\bpam_unix.so.*)/\\1'\"sufficient\"' \\2/' \"$PAM_FILE_PATH\"\n            else\n                echo 'password    '\"sufficient\"'    pam_unix.so' >> \"$PAM_FILE_PATH\"\n            fi\n        fi\n        # Check the option\n        if ! grep -qP '^\\s*password\\s+'\"sufficient\"'\\s+pam_unix.so\\s*.*\\ssha512\\b' \"$PAM_FILE_PATH\"; then\n            sed -i -E --follow-symlinks '/\\s*password\\s+'\"sufficient\"'\\s+pam_unix.so.*/ s/$/ sha512/' \"$PAM_FILE_PATH\"\n        fi\n    if [ -f /usr/bin/authselect ]; then\n        \n        authselect apply-changes -b\n    fi\nelse\n    echo \"/etc/pam.d/password-auth was not found\" >&2\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "set_password_hashing_algorithm_passwordauth",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "medium",
					"strategy": "configure",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-85946-2\n  - CJIS-5.6.2.2\n  - NIST-800-171-3.13.11\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(c)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.1\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - set_password_hashing_algorithm_passwordauth\n\n- name: Set PAM's Password Hashing Algorithm - password-auth - Check if /etc/pam.d/password-auth\n    file is present\n  ansible.builtin.stat:\n    path: /etc/pam.d/password-auth\n  register: result_pam_file_present\n  when: '\"pam\" in ansible_facts.packages'\n  tags:\n  - CCE-85946-2\n  - CJIS-5.6.2.2\n  - NIST-800-171-3.13.11\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(c)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.1\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - set_password_hashing_algorithm_passwordauth\n\n- name: Set PAM's Password Hashing Algorithm - password-auth - Check the proper remediation\n    for the system\n  block:\n\n  - name: Set PAM's Password Hashing Algorithm - password-auth - Define the PAM file\n      to be edited as a local fact\n    ansible.builtin.set_fact:\n      pam_file_path: /etc/pam.d/password-auth\n\n  - name: Set PAM's Password Hashing Algorithm - password-auth - Check if system relies\n      on authselect\n    ansible.builtin.stat:\n      path: /usr/bin/authselect\n    register: result_authselect_present\n\n  - name: Set PAM's Password Hashing Algorithm - password-auth - Remediate using authselect\n    block:\n\n    - name: Set PAM's Password Hashing Algorithm - password-auth - Check integrity\n        of authselect current profile\n      ansible.builtin.command:\n        cmd: authselect check\n      register: result_authselect_check_cmd\n      changed_when: false\n      ignore_errors: true\n\n    - name: Set PAM's Password Hashing Algorithm - password-auth - Informative message\n        based on the authselect integrity check result\n      ansible.builtin.assert:\n        that:\n        - result_authselect_check_cmd is success\n        fail_msg:\n        - authselect integrity check failed. Remediation aborted!\n        - This remediation could not be applied because an authselect profile was\n          not selected or the selected profile is not intact.\n        - It is not recommended to manually edit the PAM files when authselect tool\n          is available.\n        - In cases where the default authselect profile does not cover a specific\n          demand, a custom authselect profile is recommended.\n        success_msg:\n        - authselect integrity check passed\n\n    - name: Set PAM's Password Hashing Algorithm - password-auth - Get authselect\n        current profile\n      ansible.builtin.shell:\n        cmd: authselect current -r | awk '{ print $1 }'\n      register: result_authselect_profile\n      changed_when: false\n      when:\n      - result_authselect_check_cmd is success\n\n    - name: Set PAM's Password Hashing Algorithm - password-auth - Define the current\n        authselect profile as a local fact\n      ansible.builtin.set_fact:\n        authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n        authselect_custom_profile: '{{ result_authselect_profile.stdout }}'\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_profile.stdout is match(\"custom/\")\n\n    - name: Set PAM's Password Hashing Algorithm - password-auth - Define the new\n        authselect custom profile as a local fact\n      ansible.builtin.set_fact:\n        authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n        authselect_custom_profile: custom/hardening\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_profile.stdout is not match(\"custom/\")\n\n    - name: Set PAM's Password Hashing Algorithm - password-auth - Get authselect\n        current features to also enable them in the custom profile\n      ansible.builtin.shell:\n        cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n      register: result_authselect_features\n      changed_when: false\n      when:\n      - result_authselect_profile is not skipped\n      - authselect_current_profile is not match(\"custom/\")\n\n    - name: Set PAM's Password Hashing Algorithm - password-auth - Check if any custom\n        profile with the same name was already created\n      ansible.builtin.stat:\n        path: /etc/authselect/{{ authselect_custom_profile }}\n      register: result_authselect_custom_profile_present\n      changed_when: false\n      when:\n      - authselect_current_profile is not match(\"custom/\")\n\n    - name: Set PAM's Password Hashing Algorithm - password-auth - Create an authselect\n        custom profile based on the current profile\n      ansible.builtin.command:\n        cmd: authselect create-profile hardening -b {{ authselect_current_profile\n          }}\n      when:\n      - result_authselect_check_cmd is success\n      - authselect_current_profile is not match(\"custom/\")\n      - not result_authselect_custom_profile_present.stat.exists\n\n    - name: Set PAM's Password Hashing Algorithm - password-auth - Ensure authselect\n        changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b --backup=before-hardening-custom-profile\n      when:\n      - result_authselect_check_cmd is success\n      - result_authselect_profile is not skipped\n      - authselect_current_profile is not match(\"custom/\")\n      - authselect_custom_profile is not match(authselect_current_profile)\n\n    - name: Set PAM's Password Hashing Algorithm - password-auth - Ensure the authselect\n        custom profile is selected\n      ansible.builtin.command:\n        cmd: authselect select {{ authselect_custom_profile }}\n      register: result_pam_authselect_select_profile\n      when:\n      - result_authselect_check_cmd is success\n      - result_authselect_profile is not skipped\n      - authselect_current_profile is not match(\"custom/\")\n      - authselect_custom_profile is not match(authselect_current_profile)\n\n    - name: Set PAM's Password Hashing Algorithm - password-auth - Restore the authselect\n        features in the custom profile\n      ansible.builtin.command:\n        cmd: authselect enable-feature {{ item }}\n      loop: '{{ result_authselect_features.stdout_lines }}'\n      register: result_pam_authselect_restore_features\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_features is not skipped\n      - result_pam_authselect_select_profile is not skipped\n\n    - name: Set PAM's Password Hashing Algorithm - password-auth - Ensure authselect\n        changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b --backup=after-hardening-custom-profile\n      when:\n      - result_authselect_check_cmd is success\n      - result_authselect_profile is not skipped\n      - result_pam_authselect_restore_features is not skipped\n\n    - name: Set PAM's Password Hashing Algorithm - password-auth - Change the PAM\n        file to be edited according to the custom authselect profile\n      ansible.builtin.set_fact:\n        pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path\n          | basename }}\n    when:\n    - result_authselect_present.stat.exists\n\n  - name: Set PAM's Password Hashing Algorithm - password-auth - Check if expected\n      PAM module line is present in {{ pam_file_path }}\n    ansible.builtin.lineinfile:\n      path: '{{ pam_file_path }}'\n      regexp: ^\\s*password\\s+sufficient\\s+pam_unix.so\\s*.*\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_line_present\n\n  - name: Set PAM's Password Hashing Algorithm - password-auth - Include or update\n      the PAM module line in {{ pam_file_path }}\n    block:\n\n    - name: Set PAM's Password Hashing Algorithm - password-auth - Check if required\n        PAM module line is present in {{ pam_file_path }} with different control\n      ansible.builtin.lineinfile:\n        path: '{{ pam_file_path }}'\n        regexp: ^\\s*password\\s+.*\\s+pam_unix.so\\s*\n        state: absent\n      check_mode: true\n      changed_when: false\n      register: result_pam_line_other_control_present\n\n    - name: Set PAM's Password Hashing Algorithm - password-auth - Ensure the correct\n        control for the required PAM module line in {{ pam_file_path }}\n      ansible.builtin.replace:\n        dest: '{{ pam_file_path }}'\n        regexp: ^(\\s*password\\s+).*(\\bpam_unix.so.*)\n        replace: \\1sufficient \\2\n      register: result_pam_module_edit\n      when:\n      - result_pam_line_other_control_present.found == 1\n\n    - name: Set PAM's Password Hashing Algorithm - password-auth - Ensure the required\n        PAM module line is included in {{ pam_file_path }}\n      ansible.builtin.lineinfile:\n        dest: '{{ pam_file_path }}'\n        line: password    sufficient    pam_unix.so\n      register: result_pam_module_add\n      when:\n      - result_pam_line_other_control_present.found == 0 or result_pam_line_other_control_present.found\n        > 1\n\n    - name: Set PAM's Password Hashing Algorithm - password-auth - Ensure authselect\n        changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b\n      when:\n      - result_authselect_present.stat.exists\n      - (result_pam_module_add is defined and result_pam_module_add.changed) or (result_pam_module_edit\n        is defined and result_pam_module_edit.changed)\n    when:\n    - result_pam_line_present.found is defined\n    - result_pam_line_present.found == 0\n\n  - name: Set PAM's Password Hashing Algorithm - password-auth - Check if the required\n      PAM module option is present in {{ pam_file_path }}\n    ansible.builtin.lineinfile:\n      path: '{{ pam_file_path }}'\n      regexp: ^\\s*password\\s+sufficient\\s+pam_unix.so\\s*.*\\ssha512\\b\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_module_sha512_option_present\n\n  - name: Set PAM's Password Hashing Algorithm - password-auth - Ensure the \"sha512\"\n      PAM option for \"pam_unix.so\" is included in {{ pam_file_path }}\n    ansible.builtin.lineinfile:\n      path: '{{ pam_file_path }}'\n      backrefs: true\n      regexp: ^(\\s*password\\s+sufficient\\s+pam_unix.so.*)\n      line: \\1 sha512\n      state: present\n    register: result_pam_sha512_add\n    when:\n    - result_pam_module_sha512_option_present.found == 0\n\n  - name: Set PAM's Password Hashing Algorithm - password-auth - Ensure authselect\n      changes are applied\n    ansible.builtin.command:\n      cmd: authselect apply-changes -b\n    when:\n    - result_authselect_present.stat.exists\n    - (result_pam_sha512_add is defined and result_pam_sha512_add.changed) or (result_pam_sha512_edit\n      is defined and result_pam_sha512_edit.changed)\n  when:\n  - '\"pam\" in ansible_facts.packages'\n  - result_pam_file_present.stat.exists\n  tags:\n  - CCE-85946-2\n  - CJIS-5.6.2.2\n  - NIST-800-171-3.13.11\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(c)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.1\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - set_password_hashing_algorithm_passwordauth\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_set_password_hashing_algorithm_systemauth": {
			"rule_id": "xccdf_org.ssgproject.content_rule_set_password_hashing_algorithm_systemauth",
			"title": "Set PAM''s Password Hashing Algorithm",
			"result": "pass",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83581-9"
			],
			"references": [
				"BP28(R32)",
				"1",
				"12",
				"15",
				"16",
				"5",
				"5.6.2.2",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"DSS05.10",
				"DSS06.03",
				"DSS06.10",
				"3.13.11",
				"CCI-000196",
				"CCI-000803",
				"4.3.3.2.2",
				"4.3.3.5.1",
				"4.3.3.5.2",
				"4.3.3.6.1",
				"4.3.3.6.2",
				"4.3.3.6.3",
				"4.3.3.6.4",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.3.6.9",
				"4.3.3.7.2",
				"4.3.3.7.4",
				"SR 1.1",
				"SR 1.10",
				"SR 1.2",
				"SR 1.3",
				"SR 1.4",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"SR 2.1",
				"0418",
				"1055",
				"1402",
				"A.18.1.4",
				"A.7.1.1",
				"A.9.2.1",
				"A.9.2.2",
				"A.9.2.3",
				"A.9.2.4",
				"A.9.2.6",
				"A.9.3.1",
				"A.9.4.2",
				"A.9.4.3",
				"IA-5(c)",
				"IA-5(1)(c)",
				"CM-6(a)",
				"PR.AC-1",
				"PR.AC-6",
				"PR.AC-7",
				"Req-8.2.1",
				"SRG-OS-000073-GPOS-00041",
				"SRG-OS-000120-GPOS-00061",
				"SRG-OS-000480-VMM-002000"
			],
			"description": "The PAM system service can be configured to only store encrypted\nrepresentations of passwords. In &quot;/etc/pam.d/system-auth&quot;, the\n<code>password</code> section of the file controls which PAM modules execute\nduring a password change. Set the <code>pam_unix.so</code> module in the\n<code>password</code> section to include the argument <code>sha512</code>, as shown\nbelow:\n<br>\n\n<pre>password    sufficient    pam_unix.so sha512 <i>other arguments...</i></pre>\n\n<br>\nThis will help ensure when local users change their passwords, hashes for\nthe new passwords will be generated using the SHA-512 algorithm. This is\nthe default.",
			"rationale": "Passwords need to be protected at all times, and encryption is the standard\nmethod for protecting passwords. If passwords are not encrypted, they can\nbe plainly read (i.e., clear text) and easily compromised. Passwords that\nare encrypted with a weak algorithm are no more protected than if they are\nkepy in plain text.\n<br><br>\nThis setting ensures user and group account administration utilities are\nconfigured to store only encrypted representations of passwords.\nAdditionally, the <code>crypt_style</code> configuration option ensures the use\nof a strong hashing algorithm that makes password cracking attacks more\ndifficult.",
			"platforms": [
				"#pam"
			],
			"oval_definition_id": "oval:ssg-set_password_hashing_algorithm_systemauth:def:1",
			"remediations": [
				{
					"remediation_id": "set_password_hashing_algorithm_systemauth",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q pam; then\n\nif [ -e \"/etc/pam.d/system-auth\" ] ; then\n    PAM_FILE_PATH=\"/etc/pam.d/system-auth\"\n    if [ -f /usr/bin/authselect ]; then\n        if ! authselect check; then\n        echo \"\n        authselect integrity check failed. Remediation aborted!\n        This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\n        It is not recommended to manually edit the PAM files when authselect tool is available.\n        In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\n        exit 1\n        fi\n        CURRENT_PROFILE=$(authselect current -r | awk '{ print $1 }')\n        # If not already in use, a custom profile is created preserving the enabled features.\n        if [[ ! $CURRENT_PROFILE == custom/* ]]; then\n            ENABLED_FEATURES=$(authselect current | tail -n+3 | awk '{ print $2 }')\n            authselect create-profile hardening -b $CURRENT_PROFILE\n            CURRENT_PROFILE=\"custom/hardening\"\n            \n            authselect apply-changes -b --backup=before-hardening-custom-profile\n            authselect select $CURRENT_PROFILE\n            for feature in $ENABLED_FEATURES; do\n                authselect enable-feature $feature;\n            done\n            \n            authselect apply-changes -b --backup=after-hardening-custom-profile\n        fi\n        PAM_FILE_NAME=$(basename \"/etc/pam.d/system-auth\")\n        PAM_FILE_PATH=\"/etc/authselect/$CURRENT_PROFILE/$PAM_FILE_NAME\"\n        \n        authselect apply-changes -b\n    fi\n    if ! grep -qP '^\\s*password\\s+'\"sufficient\"'\\s+pam_unix.so\\s*.*' \"$PAM_FILE_PATH\"; then\n            # Line matching group + control + module was not found. Check group + module.\n            if [ \"$(grep -cP '^\\s*password\\s+.*\\s+pam_unix.so\\s*' \"$PAM_FILE_PATH\")\" -eq 1 ]; then\n                # The control is updated only if one single line matches.\n                sed -i -E --follow-symlinks 's/^(\\s*password\\s+).*(\\bpam_unix.so.*)/\\1'\"sufficient\"' \\2/' \"$PAM_FILE_PATH\"\n            else\n                echo 'password    '\"sufficient\"'    pam_unix.so' >> \"$PAM_FILE_PATH\"\n            fi\n        fi\n        # Check the option\n        if ! grep -qP '^\\s*password\\s+'\"sufficient\"'\\s+pam_unix.so\\s*.*\\ssha512\\b' \"$PAM_FILE_PATH\"; then\n            sed -i -E --follow-symlinks '/\\s*password\\s+'\"sufficient\"'\\s+pam_unix.so.*/ s/$/ sha512/' \"$PAM_FILE_PATH\"\n        fi\n    if [ -f /usr/bin/authselect ]; then\n        \n        authselect apply-changes -b\n    fi\nelse\n    echo \"/etc/pam.d/system-auth was not found\" >&2\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "set_password_hashing_algorithm_systemauth",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "medium",
					"strategy": "configure",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83581-9\n  - CJIS-5.6.2.2\n  - NIST-800-171-3.13.11\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(c)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.1\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - set_password_hashing_algorithm_systemauth\n\n- name: Set PAM's Password Hashing Algorithm - Check if /etc/pam.d/system-auth file\n    is present\n  ansible.builtin.stat:\n    path: /etc/pam.d/system-auth\n  register: result_pam_file_present\n  when: '\"pam\" in ansible_facts.packages'\n  tags:\n  - CCE-83581-9\n  - CJIS-5.6.2.2\n  - NIST-800-171-3.13.11\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(c)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.1\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - set_password_hashing_algorithm_systemauth\n\n- name: Set PAM's Password Hashing Algorithm - Check the proper remediation for the\n    system\n  block:\n\n  - name: Set PAM's Password Hashing Algorithm - Define the PAM file to be edited\n      as a local fact\n    ansible.builtin.set_fact:\n      pam_file_path: /etc/pam.d/system-auth\n\n  - name: Set PAM's Password Hashing Algorithm - Check if system relies on authselect\n    ansible.builtin.stat:\n      path: /usr/bin/authselect\n    register: result_authselect_present\n\n  - name: Set PAM's Password Hashing Algorithm - Remediate using authselect\n    block:\n\n    - name: Set PAM's Password Hashing Algorithm - Check integrity of authselect current\n        profile\n      ansible.builtin.command:\n        cmd: authselect check\n      register: result_authselect_check_cmd\n      changed_when: false\n      ignore_errors: true\n\n    - name: Set PAM's Password Hashing Algorithm - Informative message based on the\n        authselect integrity check result\n      ansible.builtin.assert:\n        that:\n        - result_authselect_check_cmd is success\n        fail_msg:\n        - authselect integrity check failed. Remediation aborted!\n        - This remediation could not be applied because an authselect profile was\n          not selected or the selected profile is not intact.\n        - It is not recommended to manually edit the PAM files when authselect tool\n          is available.\n        - In cases where the default authselect profile does not cover a specific\n          demand, a custom authselect profile is recommended.\n        success_msg:\n        - authselect integrity check passed\n\n    - name: Set PAM's Password Hashing Algorithm - Get authselect current profile\n      ansible.builtin.shell:\n        cmd: authselect current -r | awk '{ print $1 }'\n      register: result_authselect_profile\n      changed_when: false\n      when:\n      - result_authselect_check_cmd is success\n\n    - name: Set PAM's Password Hashing Algorithm - Define the current authselect profile\n        as a local fact\n      ansible.builtin.set_fact:\n        authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n        authselect_custom_profile: '{{ result_authselect_profile.stdout }}'\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_profile.stdout is match(\"custom/\")\n\n    - name: Set PAM's Password Hashing Algorithm - Define the new authselect custom\n        profile as a local fact\n      ansible.builtin.set_fact:\n        authselect_current_profile: '{{ result_authselect_profile.stdout }}'\n        authselect_custom_profile: custom/hardening\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_profile.stdout is not match(\"custom/\")\n\n    - name: Set PAM's Password Hashing Algorithm - Get authselect current features\n        to also enable them in the custom profile\n      ansible.builtin.shell:\n        cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n      register: result_authselect_features\n      changed_when: false\n      when:\n      - result_authselect_profile is not skipped\n      - authselect_current_profile is not match(\"custom/\")\n\n    - name: Set PAM's Password Hashing Algorithm - Check if any custom profile with\n        the same name was already created\n      ansible.builtin.stat:\n        path: /etc/authselect/{{ authselect_custom_profile }}\n      register: result_authselect_custom_profile_present\n      changed_when: false\n      when:\n      - authselect_current_profile is not match(\"custom/\")\n\n    - name: Set PAM's Password Hashing Algorithm - Create an authselect custom profile\n        based on the current profile\n      ansible.builtin.command:\n        cmd: authselect create-profile hardening -b {{ authselect_current_profile\n          }}\n      when:\n      - result_authselect_check_cmd is success\n      - authselect_current_profile is not match(\"custom/\")\n      - not result_authselect_custom_profile_present.stat.exists\n\n    - name: Set PAM's Password Hashing Algorithm - Ensure authselect changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b --backup=before-hardening-custom-profile\n      when:\n      - result_authselect_check_cmd is success\n      - result_authselect_profile is not skipped\n      - authselect_current_profile is not match(\"custom/\")\n      - authselect_custom_profile is not match(authselect_current_profile)\n\n    - name: Set PAM's Password Hashing Algorithm - Ensure the authselect custom profile\n        is selected\n      ansible.builtin.command:\n        cmd: authselect select {{ authselect_custom_profile }}\n      register: result_pam_authselect_select_profile\n      when:\n      - result_authselect_check_cmd is success\n      - result_authselect_profile is not skipped\n      - authselect_current_profile is not match(\"custom/\")\n      - authselect_custom_profile is not match(authselect_current_profile)\n\n    - name: Set PAM's Password Hashing Algorithm - Restore the authselect features\n        in the custom profile\n      ansible.builtin.command:\n        cmd: authselect enable-feature {{ item }}\n      loop: '{{ result_authselect_features.stdout_lines }}'\n      register: result_pam_authselect_restore_features\n      when:\n      - result_authselect_profile is not skipped\n      - result_authselect_features is not skipped\n      - result_pam_authselect_select_profile is not skipped\n\n    - name: Set PAM's Password Hashing Algorithm - Ensure authselect changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b --backup=after-hardening-custom-profile\n      when:\n      - result_authselect_check_cmd is success\n      - result_authselect_profile is not skipped\n      - result_pam_authselect_restore_features is not skipped\n\n    - name: Set PAM's Password Hashing Algorithm - Change the PAM file to be edited\n        according to the custom authselect profile\n      ansible.builtin.set_fact:\n        pam_file_path: /etc/authselect/{{ authselect_custom_profile }}/{{ pam_file_path\n          | basename }}\n    when:\n    - result_authselect_present.stat.exists\n\n  - name: Set PAM's Password Hashing Algorithm - Check if expected PAM module line\n      is present in {{ pam_file_path }}\n    ansible.builtin.lineinfile:\n      path: '{{ pam_file_path }}'\n      regexp: ^\\s*password\\s+sufficient\\s+pam_unix.so\\s*.*\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_line_present\n\n  - name: Set PAM's Password Hashing Algorithm - Include or update the PAM module\n      line in {{ pam_file_path }}\n    block:\n\n    - name: Set PAM's Password Hashing Algorithm - Check if required PAM module line\n        is present in {{ pam_file_path }} with different control\n      ansible.builtin.lineinfile:\n        path: '{{ pam_file_path }}'\n        regexp: ^\\s*password\\s+.*\\s+pam_unix.so\\s*\n        state: absent\n      check_mode: true\n      changed_when: false\n      register: result_pam_line_other_control_present\n\n    - name: Set PAM's Password Hashing Algorithm - Ensure the correct control for\n        the required PAM module line in {{ pam_file_path }}\n      ansible.builtin.replace:\n        dest: '{{ pam_file_path }}'\n        regexp: ^(\\s*password\\s+).*(\\bpam_unix.so.*)\n        replace: \\1sufficient \\2\n      register: result_pam_module_edit\n      when:\n      - result_pam_line_other_control_present.found == 1\n\n    - name: Set PAM's Password Hashing Algorithm - Ensure the required PAM module\n        line is included in {{ pam_file_path }}\n      ansible.builtin.lineinfile:\n        dest: '{{ pam_file_path }}'\n        line: password    sufficient    pam_unix.so\n      register: result_pam_module_add\n      when:\n      - result_pam_line_other_control_present.found == 0 or result_pam_line_other_control_present.found\n        > 1\n\n    - name: Set PAM's Password Hashing Algorithm - Ensure authselect changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b\n      when:\n      - result_authselect_present.stat.exists\n      - (result_pam_module_add is defined and result_pam_module_add.changed) or (result_pam_module_edit\n        is defined and result_pam_module_edit.changed)\n    when:\n    - result_pam_line_present.found is defined\n    - result_pam_line_present.found == 0\n\n  - name: Set PAM's Password Hashing Algorithm - Check if the required PAM module\n      option is present in {{ pam_file_path }}\n    ansible.builtin.lineinfile:\n      path: '{{ pam_file_path }}'\n      regexp: ^\\s*password\\s+sufficient\\s+pam_unix.so\\s*.*\\ssha512\\b\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_module_sha512_option_present\n\n  - name: Set PAM's Password Hashing Algorithm - Ensure the \"sha512\" PAM option for\n      \"pam_unix.so\" is included in {{ pam_file_path }}\n    ansible.builtin.lineinfile:\n      path: '{{ pam_file_path }}'\n      backrefs: true\n      regexp: ^(\\s*password\\s+sufficient\\s+pam_unix.so.*)\n      line: \\1 sha512\n      state: present\n    register: result_pam_sha512_add\n    when:\n    - result_pam_module_sha512_option_present.found == 0\n\n  - name: Set PAM's Password Hashing Algorithm - Ensure authselect changes are applied\n    ansible.builtin.command:\n      cmd: authselect apply-changes -b\n    when:\n    - result_authselect_present.stat.exists\n    - (result_pam_sha512_add is defined and result_pam_sha512_add.changed) or (result_pam_sha512_edit\n      is defined and result_pam_sha512_edit.changed)\n  when:\n  - '\"pam\" in ansible_facts.packages'\n  - result_pam_file_present.stat.exists\n  tags:\n  - CCE-83581-9\n  - CJIS-5.6.2.2\n  - NIST-800-171-3.13.11\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(c)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.1\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - set_password_hashing_algorithm_systemauth\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_package_opensc_installed": {
			"rule_id": "xccdf_org.ssgproject.content_rule_package_opensc_installed",
			"title": "Install the opensc Package For Multifactor Authentication",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83595-9"
			],
			"references": [
				"CCI-001954",
				"CCI-001953",
				"1382",
				"1384",
				"1386",
				"CM-6(a)",
				"SRG-OS-000375-GPOS-00160",
				"SRG-OS-000376-GPOS-00161",
				"SRG-OS-000376-VMM-001520"
			],
			"description": "\nThe <code>opensc</code> package can be installed with the following command:\n<pre>\n$ sudo dnf install opensc</pre>",
			"rationale": "Using an authentication device, such as a CAC or token that is separate from\nthe information system, ensures that even if the information system is\ncompromised, that compromise will not affect credentials stored on the\nauthentication device.\n<br><br>\nMultifactor solutions that require devices separate from\ninformation systems gaining access include, for example, hardware tokens\nproviding time-based or challenge-response authenticators and smart cards such\nas the U.S. Government Personal Identity Verification card and the DoD Common\nAccess Card.",
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-package_opensc_installed:def:1",
			"remediations": [
				{
					"remediation_id": "package_opensc_installed",
					"system": "urn:redhat:osbuild:blueprint",
					"fix": "\n[[packages]]\nname = \"opensc\"\nversion = \"*\"\n"
				},
				{
					"remediation_id": "package_opensc_installed",
					"system": "urn:redhat:anaconda:pre",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "\npackage --add=opensc\n"
				},
				{
					"remediation_id": "package_opensc_installed",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nif ! rpm -q --quiet \"opensc\" ; then\n    dnf install -y \"opensc\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "package_opensc_installed",
					"system": "urn:xccdf:fix:script:puppet",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "include install_opensc\n\nclass install_opensc {\n  package { 'opensc':\n    ensure => 'installed',\n  }\n}\n"
				},
				{
					"remediation_id": "package_opensc_installed",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "- name: Ensure opensc is installed\n  package:\n    name: opensc\n    state: present\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-83595-9\n  - NIST-800-53-CM-6(a)\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_opensc_installed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_package_pcsc-lite_installed": {
			"rule_id": "xccdf_org.ssgproject.content_rule_package_pcsc-lite_installed",
			"title": "Install the pcsc-lite package",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-86280-5"
			],
			"references": [
				"CCI-001954",
				"1382",
				"1384",
				"1386",
				"CM-6(a)",
				"SRG-OS-000375-GPOS-00160",
				"SRG-OS-000377-VMM-001530"
			],
			"description": "The <code>pcsc-lite</code> package can be installed with the following command:\n<pre>\n$ sudo dnf install pcsc-lite</pre>",
			"rationale": "The pcsc-lite package must be installed if it is to be available for\nmultifactor authentication using smartcards.",
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-package_pcsc-lite_installed:def:1",
			"remediations": [
				{
					"remediation_id": "package_pcsc-lite_installed",
					"system": "urn:redhat:osbuild:blueprint",
					"fix": "\n[[packages]]\nname = \"pcsc-lite\"\nversion = \"*\"\n"
				},
				{
					"remediation_id": "package_pcsc-lite_installed",
					"system": "urn:redhat:anaconda:pre",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "\npackage --add=pcsc-lite\n"
				},
				{
					"remediation_id": "package_pcsc-lite_installed",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nif ! rpm -q --quiet \"pcsc-lite\" ; then\n    dnf install -y \"pcsc-lite\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "package_pcsc-lite_installed",
					"system": "urn:xccdf:fix:script:puppet",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "include install_pcsc-lite\n\nclass install_pcsc-lite {\n  package { 'pcsc-lite':\n    ensure => 'installed',\n  }\n}\n"
				},
				{
					"remediation_id": "package_pcsc-lite_installed",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "- name: Ensure pcsc-lite is installed\n  package:\n    name: pcsc-lite\n    state: present\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-86280-5\n  - NIST-800-53-CM-6(a)\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_pcsc-lite_installed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_service_pcscd_enabled": {
			"rule_id": "xccdf_org.ssgproject.content_rule_service_pcscd_enabled",
			"title": "Enable the pcscd Service",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-87907-2"
			],
			"references": [
				"CCI-001954",
				"1382",
				"1384",
				"1386",
				"IA-2(1)",
				"IA-2(2)",
				"IA-2(3)",
				"IA-2(4)",
				"IA-2(6)",
				"IA-2(7)",
				"IA-2(11)",
				"CM-6(a)",
				"SRG-OS-000375-GPOS-00160",
				"SRG-OS-000377-VMM-001530"
			],
			"description": "\nThe <code>pcscd</code> service can be enabled with the following command:\n<pre>$ sudo systemctl enable pcscd.service</pre>",
			"rationale": "Using an authentication device, such as a CAC or token that is separate from\nthe information system, ensures that even if the information system is\ncompromised, that compromise will not affect credentials stored on the\nauthentication device.\n<br><br>\nMultifactor solutions that require devices separate from\ninformation systems gaining access include, for example, hardware tokens\nproviding time-based or challenge-response authenticators and smart cards such\nas the U.S. Government Personal Identity Verification card and the DoD Common\nAccess Card.",
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-service_pcscd_enabled:def:1",
			"remediations": [
				{
					"remediation_id": "service_pcscd_enabled",
					"system": "urn:redhat:osbuild:blueprint",
					"fix": "\n[customizations.services]\nenabled = [\"pcscd\"]\n"
				},
				{
					"remediation_id": "service_pcscd_enabled",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nSYSTEMCTL_EXEC='/usr/bin/systemctl'\n\"$SYSTEMCTL_EXEC\" unmask 'pcscd.service'\n\"$SYSTEMCTL_EXEC\" start 'pcscd.service'\n\"$SYSTEMCTL_EXEC\" enable 'pcscd.service'\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "service_pcscd_enabled",
					"system": "urn:xccdf:fix:script:puppet",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "include enable_pcscd\n\nclass enable_pcscd {\n  service {'pcscd':\n    enable => true,\n    ensure => 'running',\n  }\n}\n"
				},
				{
					"remediation_id": "service_pcscd_enabled",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "- name: Enable service pcscd\n  block:\n\n  - name: Gather the package facts\n    package_facts:\n      manager: auto\n\n  - name: Start service pcscd\n    service:\n      name: pcscd\n      state: started\n      masked: 'no'\n    when:\n    - '\"pcsc-lite\" in ansible_facts.packages'\n\n  - name: Enable service pcscd\n    ansible.builtin.command:\n      cmd: systemctl enable pcscd\n    when:\n    - '\"pcsc-lite\" in ansible_facts.packages'\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-87907-2\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-2(1)\n  - NIST-800-53-IA-2(11)\n  - NIST-800-53-IA-2(2)\n  - NIST-800-53-IA-2(3)\n  - NIST-800-53-IA-2(4)\n  - NIST-800-53-IA-2(6)\n  - NIST-800-53-IA-2(7)\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - service_pcscd_enabled\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_configure_opensc_card_drivers": {
			"rule_id": "xccdf_org.ssgproject.content_rule_configure_opensc_card_drivers",
			"title": "Configure opensc Smart Card Drivers",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-89122-6"
			],
			"references": [
				"1",
				"12",
				"15",
				"16",
				"5",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"DSS05.10",
				"DSS06.03",
				"DSS06.10",
				"CCI-000765",
				"CCI-000766",
				"CCI-000767",
				"CCI-000768",
				"CCI-000771",
				"CCI-000772",
				"CCI-000884",
				"4.3.3.2.2",
				"4.3.3.5.1",
				"4.3.3.5.2",
				"4.3.3.6.1",
				"4.3.3.6.2",
				"4.3.3.6.3",
				"4.3.3.6.4",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.3.6.9",
				"4.3.3.7.2",
				"4.3.3.7.4",
				"SR 1.1",
				"SR 1.10",
				"SR 1.2",
				"SR 1.3",
				"SR 1.4",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"SR 2.1",
				"1382",
				"1384",
				"1386",
				"A.18.1.4",
				"A.7.1.1",
				"A.9.2.1",
				"A.9.2.2",
				"A.9.2.3",
				"A.9.2.4",
				"A.9.2.6",
				"A.9.3.1",
				"A.9.4.2",
				"A.9.4.3",
				"IA-2(1)",
				"IA-2(2)",
				"IA-2(3)",
				"IA-2(4)",
				"IA-2(6)",
				"IA-2(7)",
				"IA-2(11)",
				"CM-6(a)",
				"PR.AC-1",
				"PR.AC-6",
				"PR.AC-7",
				"Req-8.3",
				"SRG-OS-000104-GPOS-00051",
				"SRG-OS-000106-GPOS-00053",
				"SRG-OS-000107-GPOS-00054",
				"SRG-OS-000109-GPOS-00056",
				"SRG-OS-000108-GPOS-00055",
				"SRG-OS-000108-GPOS-00057",
				"SRG-OS-000108-GPOS-00058",
				"SRG-OS-000376-VMM-001520"
			],
			"description": "The OpenSC smart card tool can auto-detect smart card drivers; however,\nsetting the smart card drivers in use by your organization helps to prevent\nusers from using unauthorized smart cards. The default smart card driver for this\nprofile is <code>cac</code>.\nTo configure the OpenSC driver, edit the <code>/etc/opensc.conf</code>\nand add the following line into the file in the <code>app default</code> block,\nso it will look like:\n\n<pre>\napp default {\n   ...\n   card_drivers = cac;\n}\n</pre>",
			"rationale": "Smart card login provides two-factor authentication stronger than\nthat provided by a username and password combination. Smart cards leverage PKI\n(public key infrastructure) in order to provide and verify credentials.\nConfiguring the smart card driver in use by your organization helps to prevent\nusers from using unauthorized smart cards.",
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-configure_opensc_card_drivers:def:1",
			"remediations": [
				{
					"remediation_id": "configure_opensc_card_drivers",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nvar_smartcard_drivers='cac'\n\n\nOPENSC_TOOL=\"/usr/bin/opensc-tool\"\n\nif [ -f \"${OPENSC_TOOL}\" ]; then\n    ${OPENSC_TOOL} -S app:default:card_drivers:$var_smartcard_drivers\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_force_opensc_card_drivers": {
			"rule_id": "xccdf_org.ssgproject.content_rule_force_opensc_card_drivers",
			"title": "Force opensc To Use Defined Smart Card Driver",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-89151-5"
			],
			"references": [
				"1",
				"12",
				"15",
				"16",
				"5",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"DSS05.10",
				"DSS06.03",
				"DSS06.10",
				"CCI-000765",
				"CCI-000766",
				"CCI-000767",
				"CCI-000768",
				"CCI-000771",
				"CCI-000772",
				"CCI-000884",
				"4.3.3.2.2",
				"4.3.3.5.1",
				"4.3.3.5.2",
				"4.3.3.6.1",
				"4.3.3.6.2",
				"4.3.3.6.3",
				"4.3.3.6.4",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.3.6.9",
				"4.3.3.7.2",
				"4.3.3.7.4",
				"SR 1.1",
				"SR 1.10",
				"SR 1.2",
				"SR 1.3",
				"SR 1.4",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"SR 2.1",
				"1382",
				"1384",
				"1386",
				"A.18.1.4",
				"A.7.1.1",
				"A.9.2.1",
				"A.9.2.2",
				"A.9.2.3",
				"A.9.2.4",
				"A.9.2.6",
				"A.9.3.1",
				"A.9.4.2",
				"A.9.4.3",
				"IA-2(1)",
				"IA-2(2)",
				"IA-2(3)",
				"IA-2(4)",
				"IA-2(6)",
				"IA-2(7)",
				"IA-2(11)",
				"CM-6(a)",
				"PR.AC-1",
				"PR.AC-6",
				"PR.AC-7",
				"Req-8.3",
				"SRG-OS-000104-GPOS-00051",
				"SRG-OS-000106-GPOS-00053",
				"SRG-OS-000107-GPOS-00054",
				"SRG-OS-000109-GPOS-00056",
				"SRG-OS-000108-GPOS-00055",
				"SRG-OS-000108-GPOS-00057",
				"SRG-OS-000108-GPOS-00058",
				"SRG-OS-000376-VMM-001520"
			],
			"description": "The OpenSC smart card middleware can auto-detect smart card drivers; however by\nforcing the smart card driver in use by your organization, opensc will no longer\nautodetect or use other drivers unless specified. This helps to prevent\nusers from using unauthorized smart cards. The default smart card driver for this\nprofile is <code>cac</code>.\nTo force the OpenSC driver, edit the <code>/etc/opensc.conf</code>.\nLook for a line similar to:\n<pre># force_card_driver = customcos;</pre>\nand change it to:\n<pre>force_card_driver = cac;</pre>",
			"rationale": "Smart card login provides two-factor authentication stronger than\nthat provided by a username and password combination. Smart cards leverage PKI\n(public key infrastructure) in order to provide and verify credentials.\nForcing the smart card driver in use by your organization helps to prevent\nusers from using unauthorized smart cards.",
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-force_opensc_card_drivers:def:1",
			"remediations": [
				{
					"remediation_id": "force_opensc_card_drivers",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nvar_smartcard_drivers='cac'\n\n\nOPENSC_TOOL=\"/usr/bin/opensc-tool\"\n\nif [ -f \"${OPENSC_TOOL}\" ]; then\n    ${OPENSC_TOOL} -S app:default:force_card_driver:$var_smartcard_drivers\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_account_disable_post_pw_expiration": {
			"rule_id": "xccdf_org.ssgproject.content_rule_account_disable_post_pw_expiration",
			"title": "Set Account Expiration Following Inactivity",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83627-0"
			],
			"references": [
				"1",
				"12",
				"13",
				"14",
				"15",
				"16",
				"18",
				"3",
				"5",
				"7",
				"8",
				"5.6.2.1.1",
				"DSS01.03",
				"DSS03.05",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"DSS05.10",
				"DSS06.03",
				"DSS06.10",
				"3.5.6",
				"CCI-000017",
				"CCI-000795",
				"4.3.3.2.2",
				"4.3.3.5.1",
				"4.3.3.5.2",
				"4.3.3.6.1",
				"4.3.3.6.2",
				"4.3.3.6.3",
				"4.3.3.6.4",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.3.6.9",
				"4.3.3.7.2",
				"4.3.3.7.3",
				"4.3.3.7.4",
				"SR 1.1",
				"SR 1.10",
				"SR 1.2",
				"SR 1.3",
				"SR 1.4",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"SR 2.1",
				"SR 6.2",
				"A.12.4.1",
				"A.12.4.3",
				"A.18.1.4",
				"A.6.1.2",
				"A.7.1.1",
				"A.9.1.2",
				"A.9.2.1",
				"A.9.2.2",
				"A.9.2.3",
				"A.9.2.4",
				"A.9.2.6",
				"A.9.3.1",
				"A.9.4.1",
				"A.9.4.2",
				"A.9.4.3",
				"A.9.4.4",
				"A.9.4.5",
				"CIP-004-6 R2.2.2",
				"CIP-004-6 R2.2.3",
				"CIP-007-3 R.1.3",
				"CIP-007-3 R5",
				"CIP-007-3 R5.1.1",
				"CIP-007-3 R5.1.3",
				"CIP-007-3 R5.2.1",
				"CIP-007-3 R5.2.3",
				"IA-4(e)",
				"AC-2(3)",
				"CM-6(a)",
				"DE.CM-1",
				"DE.CM-3",
				"PR.AC-1",
				"PR.AC-4",
				"PR.AC-6",
				"PR.AC-7",
				"Req-8.1.4",
				"SRG-OS-000118-GPOS-00060",
				"SRG-OS-000003-VMM-000030",
				"SRG-OS-000118-VMM-000590"
			],
			"description": "To specify the number of days after a password expires (which\nsignifies inactivity) until an account is permanently disabled, add or correct\nthe following line in <code>/etc/default/useradd</code>:\n<pre>INACTIVE=<i>90</i></pre>\nIf a password is currently on the verge of expiration, then\n<code>90</code>\nday(s) remain(s) until the account is automatically\ndisabled. However, if the password will not expire for another 60 days, then 60\ndays plus <code>90</code> day(s) could\nelapse until the account would be automatically disabled. See the\n<code>useradd</code> man page for more information.",
			"rationale": "Inactive identifiers pose a risk to systems and applications because attackers may exploit an inactive identifier and potentially obtain undetected access to the system.\nDisabling inactive accounts ensures that accounts which may not have been responsibly removed are not available to attackers who may have compromised their credentials.\nOwners of inactive accounts will not notice if unauthorized access to their user account has been obtained.",
			"platforms": [
				"#login_defs"
			],
			"oval_definition_id": "oval:ssg-account_disable_post_pw_expiration:def:1",
			"remediations": [
				{
					"remediation_id": "account_disable_post_pw_expiration",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q shadow-utils; then\n\nvar_account_disable_post_pw_expiration='90'\n\n\n# Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed.\n# Otherwise, regular sed command will do.\nsed_command=('sed' '-i')\nif test -L \"/etc/default/useradd\"; then\n    sed_command+=('--follow-symlinks')\nfi\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^INACTIVE\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s=%s\" \"$stripped_key\" \"$var_account_disable_post_pw_expiration\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^INACTIVE\\\\>\" \"/etc/default/useradd\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    \"${sed_command[@]}\" \"s/^INACTIVE\\\\>.*/$escaped_formatted_output/gi\" \"/etc/default/useradd\"\nelse\n    # \\n is precaution for case where file ends without trailing newline\n    cce=\"CCE-83627-0\"\n    printf '\\n# Per %s: Set %s in %s\\n' \"$cce\" \"$formatted_output\" \"/etc/default/useradd\" >> \"/etc/default/useradd\"\n    printf '%s\\n' \"$formatted_output\" >> \"/etc/default/useradd\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "account_disable_post_pw_expiration",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83627-0\n  - CJIS-5.6.2.1.1\n  - NIST-800-171-3.5.6\n  - NIST-800-53-AC-2(3)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-4(e)\n  - PCI-DSS-Req-8.1.4\n  - account_disable_post_pw_expiration\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_account_disable_post_pw_expiration # promote to variable\n  set_fact:\n    var_account_disable_post_pw_expiration: !!str 90\n  tags:\n    - always\n\n- name: Set Account Expiration Following Inactivity\n  lineinfile:\n    create: true\n    dest: /etc/default/useradd\n    regexp: ^INACTIVE\n    line: INACTIVE={{ var_account_disable_post_pw_expiration }}\n  when: '\"shadow-utils\" in ansible_facts.packages'\n  tags:\n  - CCE-83627-0\n  - CJIS-5.6.2.1.1\n  - NIST-800-171-3.5.6\n  - NIST-800-53-AC-2(3)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-4(e)\n  - PCI-DSS-Req-8.1.4\n  - account_disable_post_pw_expiration\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_account_unique_name": {
			"rule_id": "xccdf_org.ssgproject.content_rule_account_unique_name",
			"title": "Ensure All Accounts on the System Have Unique Names",
			"result": "pass",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83628-8"
			],
			"references": [
				"5.5.2",
				"CCI-000770",
				"CCI-000804",
				"Req-8.1.1"
			],
			"description": "Ensure accounts on the system have unique names.\n\nTo ensure all accounts have unique names, run the following command:\n<pre>$ sudo getent passwd | awk -F: &#x27;{ print $1}&#x27; | uniq -d</pre>\nIf a username is returned, change or delete the username.",
			"rationale": "Unique usernames allow for accountability on the system.",
			"oval_definition_id": "oval:ssg-account_unique_name:def:1"
		},
		"xccdf_org.ssgproject.content_rule_accounts_maximum_age_login_defs": {
			"rule_id": "xccdf_org.ssgproject.content_rule_accounts_maximum_age_login_defs",
			"title": "Set Password Maximum Age",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83606-4"
			],
			"references": [
				"BP28(R18)",
				"1",
				"12",
				"15",
				"16",
				"5",
				"5.6.2.1",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"DSS05.10",
				"DSS06.03",
				"DSS06.10",
				"3.5.6",
				"CCI-000199",
				"4.3.3.2.2",
				"4.3.3.5.1",
				"4.3.3.5.2",
				"4.3.3.6.1",
				"4.3.3.6.2",
				"4.3.3.6.3",
				"4.3.3.6.4",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.3.6.9",
				"4.3.3.7.2",
				"4.3.3.7.4",
				"SR 1.1",
				"SR 1.10",
				"SR 1.2",
				"SR 1.3",
				"SR 1.4",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"SR 2.1",
				"0418",
				"1055",
				"1402",
				"A.18.1.4",
				"A.7.1.1",
				"A.9.2.1",
				"A.9.2.2",
				"A.9.2.3",
				"A.9.2.4",
				"A.9.2.6",
				"A.9.3.1",
				"A.9.4.2",
				"A.9.4.3",
				"IA-5(f)",
				"IA-5(1)(d)",
				"CM-6(a)",
				"PR.AC-1",
				"PR.AC-6",
				"PR.AC-7",
				"Req-8.2.4",
				"SRG-OS-000076-GPOS-00044"
			],
			"description": "To specify password maximum age for new accounts,\nedit the file <code>/etc/login.defs</code>\nand add or correct the following line:\n<pre>PASS_MAX_DAYS 90</pre>\nA value of 180 days is sufficient for many environments.\nThe DoD requirement is 60.\nThe profile requirement is <code>90</code>.",
			"rationale": "Any password, no matter how complex, can eventually be cracked. Therefore, passwords\nneed to be changed periodically. If the operating system does not limit the lifetime\nof passwords and force users to change their passwords, there is the risk that the\noperating system passwords could be compromised.\n<br><br>\nSetting the password maximum age ensures users are required to\nperiodically change their passwords. Requiring shorter password lifetimes\nincreases the risk of users writing down the password in a convenient\nlocation subject to physical compromise.",
			"platforms": [
				"#login_defs"
			],
			"oval_definition_id": "oval:ssg-accounts_maximum_age_login_defs:def:1",
			"remediations": [
				{
					"remediation_id": "accounts_maximum_age_login_defs",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q shadow-utils; then\n\nvar_accounts_maximum_age_login_defs='90'\n\n\ngrep -q ^PASS_MAX_DAYS /etc/login.defs && \\\n  sed -i \"s/PASS_MAX_DAYS.*/PASS_MAX_DAYS     $var_accounts_maximum_age_login_defs/g\" /etc/login.defs\nif ! [ $? -eq 0 ]; then\n    echo \"PASS_MAX_DAYS      $var_accounts_maximum_age_login_defs\" >> /etc/login.defs\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "accounts_maximum_age_login_defs",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83606-4\n  - CJIS-5.6.2.1\n  - NIST-800-171-3.5.6\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(d)\n  - NIST-800-53-IA-5(f)\n  - PCI-DSS-Req-8.2.4\n  - accounts_maximum_age_login_defs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_accounts_maximum_age_login_defs # promote to variable\n  set_fact:\n    var_accounts_maximum_age_login_defs: !!str 90\n  tags:\n    - always\n\n- name: Set Password Maximum Age\n  lineinfile:\n    create: true\n    dest: /etc/login.defs\n    regexp: ^#?PASS_MAX_DAYS\n    line: PASS_MAX_DAYS {{ var_accounts_maximum_age_login_defs }}\n  when: '\"shadow-utils\" in ansible_facts.packages'\n  tags:\n  - CCE-83606-4\n  - CJIS-5.6.2.1\n  - NIST-800-171-3.5.6\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(d)\n  - NIST-800-53-IA-5(f)\n  - PCI-DSS-Req-8.2.4\n  - accounts_maximum_age_login_defs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_accounts_password_all_shadowed": {
			"rule_id": "xccdf_org.ssgproject.content_rule_accounts_password_all_shadowed",
			"title": "Verify All Account Password Hashes are Shadowed",
			"result": "pass",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83618-9"
			],
			"references": [
				"1",
				"12",
				"15",
				"16",
				"5",
				"5.5.2",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"DSS05.10",
				"DSS06.03",
				"DSS06.10",
				"3.5.10",
				"4.3.3.2.2",
				"4.3.3.5.1",
				"4.3.3.5.2",
				"4.3.3.6.1",
				"4.3.3.6.2",
				"4.3.3.6.3",
				"4.3.3.6.4",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.3.6.9",
				"4.3.3.7.2",
				"4.3.3.7.4",
				"SR 1.1",
				"SR 1.10",
				"SR 1.2",
				"SR 1.3",
				"SR 1.4",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"SR 2.1",
				"1410",
				"A.18.1.4",
				"A.7.1.1",
				"A.9.2.1",
				"A.9.2.2",
				"A.9.2.3",
				"A.9.2.4",
				"A.9.2.6",
				"A.9.3.1",
				"A.9.4.2",
				"A.9.4.3",
				"IA-5(h)",
				"CM-6(a)",
				"PR.AC-1",
				"PR.AC-6",
				"PR.AC-7",
				"Req-8.2.1"
			],
			"description": "If any password hashes are stored in <code>/etc/passwd</code> (in the second field,\ninstead of an <code>x</code> or <code>*</code>), the cause of this misconfiguration should be\ninvestigated. The account should have its password reset and the hash should be\nproperly stored, or the account should be deleted entirely.",
			"rationale": "The hashes for all user account passwords should be stored in\nthe file <code>/etc/shadow</code> and never in <code>/etc/passwd</code>,\nwhich is readable by all users.",
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-accounts_password_all_shadowed:def:1"
		},
		"xccdf_org.ssgproject.content_rule_gid_passwd_group_same": {
			"rule_id": "xccdf_org.ssgproject.content_rule_gid_passwd_group_same",
			"title": "All GIDs referenced in /etc/passwd must be defined in /etc/group",
			"result": "pass",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "low",
			"identifiers": [
				"CCE-83613-0"
			],
			"references": [
				"1",
				"12",
				"15",
				"16",
				"5",
				"5.5.2",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"DSS05.10",
				"DSS06.03",
				"DSS06.10",
				"CCI-000764",
				"4.3.3.2.2",
				"4.3.3.5.1",
				"4.3.3.5.2",
				"4.3.3.6.1",
				"4.3.3.6.2",
				"4.3.3.6.3",
				"4.3.3.6.4",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.3.6.9",
				"4.3.3.7.2",
				"4.3.3.7.4",
				"SR 1.1",
				"SR 1.10",
				"SR 1.2",
				"SR 1.3",
				"SR 1.4",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"SR 2.1",
				"A.18.1.4",
				"A.7.1.1",
				"A.9.2.1",
				"A.9.2.2",
				"A.9.2.3",
				"A.9.2.4",
				"A.9.2.6",
				"A.9.3.1",
				"A.9.4.2",
				"A.9.4.3",
				"CIP-003-8 R5.1.1",
				"CIP-003-8 R5.3",
				"CIP-004-6 R2.2.3",
				"CIP-004-6 R2.3",
				"CIP-007-3 R5.1",
				"CIP-007-3 R5.1.2",
				"CIP-007-3 R5.2",
				"CIP-007-3 R5.3.1",
				"CIP-007-3 R5.3.2",
				"CIP-007-3 R5.3.3",
				"IA-2",
				"CM-6(a)",
				"PR.AC-1",
				"PR.AC-6",
				"PR.AC-7",
				"Req-8.5.a",
				"SRG-OS-000104-GPOS-00051"
			],
			"description": "Add a group to the system for each GID referenced without a corresponding group.",
			"rationale": "If a user is assigned the Group Identifier (GID) of a group not existing on the system, and a group\nwith the Group Identifier (GID) is subsequently created, the user may have unintended rights to\nany files associated with the group.",
			"oval_definition_id": "oval:ssg-gid_passwd_group_same:def:1"
		},
		"xccdf_org.ssgproject.content_rule_no_empty_passwords": {
			"rule_id": "xccdf_org.ssgproject.content_rule_no_empty_passwords",
			"title": "Prevent Login to Accounts With Empty Password",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "high",
			"identifiers": [
				"CCE-83611-4"
			],
			"references": [
				"1",
				"12",
				"13",
				"14",
				"15",
				"16",
				"18",
				"3",
				"5",
				"5.5.2",
				"APO01.06",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"DSS05.10",
				"DSS06.02",
				"DSS06.03",
				"DSS06.10",
				"3.1.1",
				"3.1.5",
				"CCI-000366",
				"164.308(a)(1)(ii)(B)",
				"164.308(a)(7)(i)",
				"164.308(a)(7)(ii)(A)",
				"164.310(a)(1)",
				"164.310(a)(2)(i)",
				"164.310(a)(2)(ii)",
				"164.310(a)(2)(iii)",
				"164.310(b)",
				"164.310(c)",
				"164.310(d)(1)",
				"164.310(d)(2)(iii)",
				"4.3.3.2.2",
				"4.3.3.5.1",
				"4.3.3.5.2",
				"4.3.3.6.1",
				"4.3.3.6.2",
				"4.3.3.6.3",
				"4.3.3.6.4",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.3.6.9",
				"4.3.3.7.2",
				"4.3.3.7.3",
				"4.3.3.7.4",
				"SR 1.1",
				"SR 1.10",
				"SR 1.2",
				"SR 1.3",
				"SR 1.4",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"SR 2.1",
				"SR 5.2",
				"A.10.1.1",
				"A.11.1.4",
				"A.11.1.5",
				"A.11.2.1",
				"A.13.1.1",
				"A.13.1.3",
				"A.13.2.1",
				"A.13.2.3",
				"A.13.2.4",
				"A.14.1.2",
				"A.14.1.3",
				"A.18.1.4",
				"A.6.1.2",
				"A.7.1.1",
				"A.7.1.2",
				"A.7.3.1",
				"A.8.2.2",
				"A.8.2.3",
				"A.9.1.1",
				"A.9.1.2",
				"A.9.2.1",
				"A.9.2.2",
				"A.9.2.3",
				"A.9.2.4",
				"A.9.2.6",
				"A.9.3.1",
				"A.9.4.1",
				"A.9.4.2",
				"A.9.4.3",
				"A.9.4.4",
				"A.9.4.5",
				"IA-5(1)(a)",
				"IA-5(c)",
				"CM-6(a)",
				"PR.AC-1",
				"PR.AC-4",
				"PR.AC-6",
				"PR.AC-7",
				"PR.DS-5",
				"FIA_UAU.1",
				"Req-8.2.3",
				"SRG-OS-000480-GPOS-00227"
			],
			"description": "If an account is configured for password authentication\nbut does not have an assigned password, it may be possible to log\ninto the account without authentication. Remove any instances of the\n<code>nullok</code> in\n\n<code>/etc/pam.d/system-auth</code>\n\nto prevent logins with empty passwords.",
			"rationale": "If an account has an empty password, anyone could log in and\nrun commands with the privileges of that account. Accounts with\nempty passwords should never be used in operational environments.",
			"warnings": [
				{
					"text": "If the system relies on <code>authselect</code> tool to manage PAM settings, the remediation\nwill also use <code>authselect</code> tool. However, if any manual modification was made in\nPAM files, the <code>authselect</code> integrity check will fail and the remediation will be\naborted in order to preserve intentional changes. In this case, an informative message will\nbe shown in the remediation report.\nNote that this rule is not applicable for systems running within a\ncontainer. Having user with empty password within a container is not\nconsidered a risk, because it should not be possible to directly login into\na container anyway.",
					"category": "general"
				}
			],
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-no_empty_passwords:def:1",
			"remediations": [
				{
					"remediation_id": "no_empty_passwords",
					"system": "urn:xccdf:fix:script:kubernetes",
					"fix": "---\napiVersion: machineconfiguration.openshift.io/v1\nkind: MachineConfig\nspec:\n  config:\n    ignition:\n      version: 3.1.0\n    storage:\n      files:\n      - contents:\n          source: data:,%23%20Generated%20by%20authselect%20on%20Sat%20Oct%2027%2014%3A59%3A36%202018%0A%23%20Do%20not%20modify%20this%20file%20manually.%0A%0Aauth%20%20%20%20%20%20%20%20required%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_env.so%0Aauth%20%20%20%20%20%20%20%20required%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_faildelay.so%20delay%3D2000000%0Aauth%20%20%20%20%20%20%20%20sufficient%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_fprintd.so%0Aauth%20%20%20%20%20%20%20%20%5Bdefault%3D1%20ignore%3Dignore%20success%3Dok%5D%20%20%20%20%20%20%20%20%20pam_succeed_if.so%20uid%20%3E%3D%201000%20quiet%0Aauth%20%20%20%20%20%20%20%20%5Bdefault%3D1%20ignore%3Dignore%20success%3Dok%5D%20%20%20%20%20%20%20%20%20pam_localuser.so%0Aauth%20%20%20%20%20%20%20%20sufficient%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_unix.so%20try_first_pass%0Aauth%20%20%20%20%20%20%20%20requisite%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_succeed_if.so%20uid%20%3E%3D%201000%20quiet_success%0Aauth%20%20%20%20%20%20%20%20sufficient%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_sss.so%20forward_pass%0Aauth%20%20%20%20%20%20%20%20required%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_deny.so%0A%0Aaccount%20%20%20%20%20required%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_unix.so%0Aaccount%20%20%20%20%20sufficient%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_localuser.so%0Aaccount%20%20%20%20%20sufficient%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_succeed_if.so%20uid%20%3C%201000%20quiet%0Aaccount%20%20%20%20%20%5Bdefault%3Dbad%20success%3Dok%20user_unknown%3Dignore%5D%20pam_sss.so%0Aaccount%20%20%20%20%20required%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_permit.so%0A%0Apassword%20%20%20%20requisite%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_pwquality.so%20try_first_pass%20local_users_only%0Apassword%20%20%20%20sufficient%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_unix.so%20sha512%20shadow%20try_first_pass%20use_authtok%0Apassword%20%20%20%20sufficient%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_sss.so%20use_authtok%0Apassword%20%20%20%20required%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_deny.so%0A%0Asession%20%20%20%20%20optional%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_keyinit.so%20revoke%0Asession%20%20%20%20%20required%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_limits.so%0A-session%20%20%20%20optional%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_systemd.so%0Asession%20%20%20%20%20%5Bsuccess%3D1%20default%3Dignore%5D%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_succeed_if.so%20service%20in%20crond%20quiet%20use_uid%0Asession%20%20%20%20%20required%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_unix.so%0Asession%20%20%20%20%20optional%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_sss.so%0A\n        mode: 0644\n        path: /etc/pam.d/password-auth\n        overwrite: true\n      - contents:\n          source: data:,%23%20Generated%20by%20authselect%20on%20Sat%20Oct%2027%2014%3A59%3A36%202018%0A%23%20Do%20not%20modify%20this%20file%20manually.%0A%0Aauth%20%20%20%20%20%20%20%20required%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_env.so%0Aauth%20%20%20%20%20%20%20%20required%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_faildelay.so%20delay%3D2000000%0Aauth%20%20%20%20%20%20%20%20sufficient%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_fprintd.so%0Aauth%20%20%20%20%20%20%20%20%5Bdefault%3D1%20ignore%3Dignore%20success%3Dok%5D%20%20%20%20%20%20%20%20%20pam_succeed_if.so%20uid%20%3E%3D%201000%20quiet%0Aauth%20%20%20%20%20%20%20%20%5Bdefault%3D1%20ignore%3Dignore%20success%3Dok%5D%20%20%20%20%20%20%20%20%20pam_localuser.so%0Aauth%20%20%20%20%20%20%20%20sufficient%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_unix.so%20try_first_pass%0Aauth%20%20%20%20%20%20%20%20requisite%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_succeed_if.so%20uid%20%3E%3D%201000%20quiet_success%0Aauth%20%20%20%20%20%20%20%20sufficient%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_sss.so%20forward_pass%0Aauth%20%20%20%20%20%20%20%20required%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_deny.so%0A%0Aaccount%20%20%20%20%20required%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_unix.so%0Aaccount%20%20%20%20%20sufficient%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_localuser.so%0Aaccount%20%20%20%20%20sufficient%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_succeed_if.so%20uid%20%3C%201000%20quiet%0Aaccount%20%20%20%20%20%5Bdefault%3Dbad%20success%3Dok%20user_unknown%3Dignore%5D%20pam_sss.so%0Aaccount%20%20%20%20%20required%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_permit.so%0A%0Apassword%20%20%20%20requisite%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_pwquality.so%20try_first_pass%20local_users_only%0Apassword%20%20%20%20sufficient%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_unix.so%20sha512%20shadow%20try_first_pass%20use_authtok%0Apassword%20%20%20%20sufficient%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_sss.so%20use_authtok%0Apassword%20%20%20%20required%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_deny.so%0A%0Asession%20%20%20%20%20optional%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_keyinit.so%20revoke%0Asession%20%20%20%20%20required%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_limits.so%0A-session%20%20%20%20optional%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_systemd.so%0Asession%20%20%20%20%20%5Bsuccess%3D1%20default%3Dignore%5D%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_succeed_if.so%20service%20in%20crond%20quiet%20use_uid%0Asession%20%20%20%20%20required%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_unix.so%0Asession%20%20%20%20%20optional%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20pam_sss.so%0A\n        mode: 0644\n        path: /etc/pam.d/system-auth\n        overwrite: true\n"
				},
				{
					"remediation_id": "no_empty_passwords",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "medium",
					"strategy": "configure",
					"fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nif [ -f /usr/bin/authselect ]; then\n    if ! authselect check; then\necho \"\nauthselect integrity check failed. Remediation aborted!\nThis remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\nIt is not recommended to manually edit the PAM files when authselect tool is available.\nIn cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\nexit 1\nfi\nauthselect enable-feature without-nullok\n\nauthselect apply-changes -b\nelse\n    \nif grep -qP '^\\s*auth\\s+'\"sufficient\"'\\s+pam_unix.so\\s.*\\bnullok\\b' \"/etc/pam.d/system-auth\"; then\n    sed -i -E --follow-symlinks 's/(.*auth.*'\"sufficient\"'.*pam_unix.so.*)\\snullok=?[[:alnum:]]*(.*)/\\1\\2/g' \"/etc/pam.d/system-auth\"\nfi\n    \nif grep -qP '^\\s*password\\s+'\"sufficient\"'\\s+pam_unix.so\\s.*\\bnullok\\b' \"/etc/pam.d/system-auth\"; then\n    sed -i -E --follow-symlinks 's/(.*password.*'\"sufficient\"'.*pam_unix.so.*)\\snullok=?[[:alnum:]]*(.*)/\\1\\2/g' \"/etc/pam.d/system-auth\"\nfi\n    \nif grep -qP '^\\s*auth\\s+'\"sufficient\"'\\s+pam_unix.so\\s.*\\bnullok\\b' \"/etc/pam.d/password-auth\"; then\n    sed -i -E --follow-symlinks 's/(.*auth.*'\"sufficient\"'.*pam_unix.so.*)\\snullok=?[[:alnum:]]*(.*)/\\1\\2/g' \"/etc/pam.d/password-auth\"\nfi\n    \nif grep -qP '^\\s*password\\s+'\"sufficient\"'\\s+pam_unix.so\\s.*\\bnullok\\b' \"/etc/pam.d/password-auth\"; then\n    sed -i -E --follow-symlinks 's/(.*password.*'\"sufficient\"'.*pam_unix.so.*)\\snullok=?[[:alnum:]]*(.*)/\\1\\2/g' \"/etc/pam.d/password-auth\"\nfi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "no_empty_passwords",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "medium",
					"strategy": "configure",
					"fix": "- name: Prevent Login to Accounts With Empty Password - Check if system relies on\n    authselect\n  ansible.builtin.stat:\n    path: /usr/bin/authselect\n  register: result_authselect_present\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-83611-4\n  - CJIS-5.5.2\n  - NIST-800-171-3.1.1\n  - NIST-800-171-3.1.5\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - configure_strategy\n  - high_severity\n  - low_complexity\n  - medium_disruption\n  - no_empty_passwords\n  - no_reboot_needed\n\n- name: Prevent Login to Accounts With Empty Password - Remediate using authselect\n  block:\n\n  - name: Prevent Login to Accounts With Empty Password - Check integrity of authselect\n      current profile\n    ansible.builtin.command:\n      cmd: authselect check\n    register: result_authselect_check_cmd\n    changed_when: false\n    ignore_errors: true\n\n  - name: Prevent Login to Accounts With Empty Password - Informative message based\n      on the authselect integrity check result\n    ansible.builtin.assert:\n      that:\n      - result_authselect_check_cmd is success\n      fail_msg:\n      - authselect integrity check failed. Remediation aborted!\n      - This remediation could not be applied because an authselect profile was not\n        selected or the selected profile is not intact.\n      - It is not recommended to manually edit the PAM files when authselect tool\n        is available.\n      - In cases where the default authselect profile does not cover a specific demand,\n        a custom authselect profile is recommended.\n      success_msg:\n      - authselect integrity check passed\n\n  - name: Prevent Login to Accounts With Empty Password - Get authselect current features\n    ansible.builtin.shell:\n      cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n    register: result_authselect_features\n    changed_when: false\n    when:\n    - result_authselect_check_cmd is success\n\n  - name: Prevent Login to Accounts With Empty Password - Ensure \"without-nullok\"\n      feature is enabled using authselect tool\n    ansible.builtin.command:\n      cmd: authselect enable-feature without-nullok\n    register: result_authselect_enable_feature_cmd\n    when:\n    - result_authselect_check_cmd is success\n    - result_authselect_features.stdout is not search(\"without-nullok\")\n\n  - name: Prevent Login to Accounts With Empty Password - Ensure authselect changes\n      are applied\n    ansible.builtin.command:\n      cmd: authselect apply-changes -b\n    when:\n    - result_authselect_enable_feature_cmd is not skipped\n    - result_authselect_enable_feature_cmd is success\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - result_authselect_present.stat.exists\n  tags:\n  - CCE-83611-4\n  - CJIS-5.5.2\n  - NIST-800-171-3.1.1\n  - NIST-800-171-3.1.5\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - configure_strategy\n  - high_severity\n  - low_complexity\n  - medium_disruption\n  - no_empty_passwords\n  - no_reboot_needed\n\n- name: Prevent Login to Accounts With Empty Password - Remediate directly editing\n    PAM files\n  ansible.builtin.replace:\n    dest: '{{ item }}'\n    regexp: nullok\n  loop:\n  - /etc/pam.d/system-auth\n  - /etc/pam.d/password-auth\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not result_authselect_present.stat.exists\n  tags:\n  - CCE-83611-4\n  - CJIS-5.5.2\n  - NIST-800-171-3.1.1\n  - NIST-800-171-3.1.5\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)(a)\n  - NIST-800-53-IA-5(c)\n  - PCI-DSS-Req-8.2.3\n  - configure_strategy\n  - high_severity\n  - low_complexity\n  - medium_disruption\n  - no_empty_passwords\n  - no_reboot_needed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_package_audispd-plugins_installed": {
			"rule_id": "xccdf_org.ssgproject.content_rule_package_audispd-plugins_installed",
			"title": "Install audispd-plugins Package",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83648-6"
			],
			"references": [
				"FMT_SMF_EXT.1",
				"SRG-OS-000342-GPOS-00133"
			],
			"description": "The <code>audispd-plugins</code> package can be installed with the following command:\n<pre>\n$ sudo dnf install audispd-plugins</pre>",
			"rationale": "<code>audispd-plugins</code> provides plugins for the real-time interface to the\naudit subsystem, <code>audispd</code>. These plugins can do things like relay events\nto remote machines or analyze events for suspicious behavior.",
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-package_audispd-plugins_installed:def:1",
			"remediations": [
				{
					"remediation_id": "package_audispd-plugins_installed",
					"system": "urn:redhat:osbuild:blueprint",
					"fix": "\n[[packages]]\nname = \"audispd-plugins\"\nversion = \"*\"\n"
				},
				{
					"remediation_id": "package_audispd-plugins_installed",
					"system": "urn:redhat:anaconda:pre",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "\npackage --add=audispd-plugins\n"
				},
				{
					"remediation_id": "package_audispd-plugins_installed",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nif ! rpm -q --quiet \"audispd-plugins\" ; then\n    dnf install -y \"audispd-plugins\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "package_audispd-plugins_installed",
					"system": "urn:xccdf:fix:script:puppet",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "include install_audispd-plugins\n\nclass install_audispd-plugins {\n  package { 'audispd-plugins':\n    ensure => 'installed',\n  }\n}\n"
				},
				{
					"remediation_id": "package_audispd-plugins_installed",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "- name: Ensure audispd-plugins is installed\n  package:\n    name: audispd-plugins\n    state: present\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-83648-6\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_audispd-plugins_installed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_service_auditd_enabled": {
			"rule_id": "xccdf_org.ssgproject.content_rule_service_auditd_enabled",
			"title": "Enable auditd Service",
			"result": "notselected",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-90829-3"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.3.1",
				"3.3.2",
				"3.3.6",
				"CCI-000126",
				"CCI-000130",
				"CCI-000131",
				"CCI-000132",
				"CCI-000133",
				"CCI-000134",
				"CCI-000135",
				"CCI-000154",
				"CCI-000158",
				"CCI-000172",
				"CCI-000366",
				"CCI-001464",
				"CCI-001487",
				"CCI-001814",
				"CCI-001875",
				"CCI-001876",
				"CCI-001877",
				"CCI-002884",
				"CCI-001878",
				"CCI-001879",
				"CCI-001880",
				"CCI-001881",
				"CCI-001882",
				"CCI-001889",
				"CCI-001914",
				"CCI-000169",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(5)(ii)(C)",
				"164.310(a)(2)(iv)",
				"164.310(d)(2)(iii)",
				"164.312(b)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"CIP-004-6 R3.3",
				"CIP-007-3 R6.5",
				"AC-2(g)",
				"AU-3",
				"AU-10",
				"AU-2(d)",
				"AU-12(c)",
				"AU-14(1)",
				"AC-6(9)",
				"CM-6(a)",
				"SI-4(23)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1",
				"Req-10.1",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000038-GPOS-00016",
				"SRG-OS-000039-GPOS-00017",
				"SRG-OS-000040-GPOS-00018",
				"SRG-OS-000041-GPOS-00019",
				"SRG-OS-000042-GPOS-00021",
				"SRG-OS-000051-GPOS-00024",
				"SRG-OS-000054-GPOS-00025",
				"SRG-OS-000122-GPOS-00063",
				"SRG-OS-000254-GPOS-00095",
				"SRG-OS-000255-GPOS-00096",
				"SRG-OS-000337-GPOS-00129",
				"SRG-OS-000348-GPOS-00136",
				"SRG-OS-000349-GPOS-00137",
				"SRG-OS-000350-GPOS-00138",
				"SRG-OS-000351-GPOS-00139",
				"SRG-OS-000352-GPOS-00140",
				"SRG-OS-000353-GPOS-00141",
				"SRG-OS-000354-GPOS-00142",
				"SRG-OS-000358-GPOS-00145",
				"SRG-OS-000365-GPOS-00152",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000475-GPOS-00220",
				"SRG-OS-000037-VMM-000150",
				"SRG-OS-000063-VMM-000310",
				"SRG-OS-000038-VMM-000160",
				"SRG-OS-000039-VMM-000170",
				"SRG-OS-000040-VMM-000180",
				"SRG-OS-000041-VMM-000190"
			],
			"description": "The <code>auditd</code> service is an essential userspace component of\nthe Linux Auditing System, as it is responsible for writing audit records to\ndisk.\n\nThe <code>auditd</code> service can be enabled with the following command:\n<pre>$ sudo systemctl enable auditd.service</pre>",
			"rationale": "Without establishing what type of events occurred, it would be difficult\nto establish, correlate, and investigate the events leading up to an outage or attack.\nEnsuring the <code>auditd</code> service is active ensures audit records\ngenerated by the kernel are appropriately recorded.\n<br><br>\nAdditionally, a properly configured audit subsystem ensures that actions of\nindividual system users can be uniquely traced to those users so they\ncan be held accountable for their actions.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-service_auditd_enabled:def:1",
			"remediations": [
				{
					"remediation_id": "service_auditd_enabled",
					"system": "urn:redhat:osbuild:blueprint",
					"fix": "\n[customizations.services]\nenabled = [\"auditd\"]\n"
				},
				{
					"remediation_id": "service_auditd_enabled",
					"system": "urn:xccdf:fix:script:kubernetes",
					"fix": "---\napiVersion: machineconfiguration.openshift.io/v1\nkind: MachineConfig\nspec:\n  config:\n    ignition:\n      version: 3.1.0\n    systemd:\n      units:\n      - name: auditd.service\n        enabled: true\n"
				},
				{
					"remediation_id": "service_auditd_enabled",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && { rpm --quiet -q audit; }; then\n\nSYSTEMCTL_EXEC='/usr/bin/systemctl'\n\"$SYSTEMCTL_EXEC\" unmask 'auditd.service'\n\"$SYSTEMCTL_EXEC\" start 'auditd.service'\n\"$SYSTEMCTL_EXEC\" enable 'auditd.service'\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "service_auditd_enabled",
					"system": "urn:xccdf:fix:script:puppet",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "include enable_auditd\n\nclass enable_auditd {\n  service {'auditd':\n    enable => true,\n    ensure => 'running',\n  }\n}\n"
				},
				{
					"remediation_id": "service_auditd_enabled",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-90829-3\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.3.1\n  - NIST-800-171-3.3.2\n  - NIST-800-171-3.3.6\n  - NIST-800-53-AC-2(g)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-10\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-14(1)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-AU-3\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SI-4(23)\n  - PCI-DSS-Req-10.1\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - service_auditd_enabled\n\n- name: Enable service auditd\n  block:\n\n  - name: Gather the package facts\n    package_facts:\n      manager: auto\n\n  - name: Enable service auditd\n    service:\n      name: auditd\n      enabled: 'yes'\n      state: started\n      masked: 'no'\n    when:\n    - '\"audit\" in ansible_facts.packages'\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-90829-3\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.3.1\n  - NIST-800-171-3.3.2\n  - NIST-800-171-3.3.6\n  - NIST-800-53-AC-2(g)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-10\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-14(1)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-AU-3\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-SI-4(23)\n  - PCI-DSS-Req-10.1\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - service_auditd_enabled\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_grub2_audit_argument": {
			"rule_id": "xccdf_org.ssgproject.content_rule_grub2_audit_argument",
			"title": "Enable Auditing for Processes Which Start Prior to the Audit Daemon",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83651-0"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.3.1",
				"CCI-001464",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(5)(ii)(C)",
				"164.310(a)(2)(iv)",
				"164.310(d)(2)(iii)",
				"164.312(b)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AC-17(1)",
				"AU-14(1)",
				"AU-10",
				"CM-6(a)",
				"IR-5(1)",
				"DE.AE-3",
				"DE.AE-5",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1",
				"Req-10.3",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000473-GPOS-00218",
				"SRG-OS-000254-GPOS-00095",
				"SRG-OS-000254-VMM-000880"
			],
			"description": "To ensure all processes can be audited, even those which start\nprior to the audit daemon, add the argument <code>audit=1</code> to the default\nGRUB 2 command line for the Linux operating system.\nTo ensure that <code>audit=1</code> is added as a kernel command line\nargument to newly installed kernels, add <code>audit=1</code> to the\ndefault Grub2 command line for Linux operating systems. Modify the line within\n<code>/etc/default/grub</code> as shown below:\n<pre>GRUB_CMDLINE_LINUX=&quot;... audit=1 ...&quot;</pre>\nRun the following command to update command line for already installed kernels:<pre># grubby --update-kernel=ALL --args=&quot;audit=1&quot;</pre>",
			"rationale": "Each process on the system carries an &quot;auditable&quot; flag which indicates whether\nits activities can be audited. Although <code>auditd</code> takes care of enabling\nthis for all processes which launch after it does, adding the kernel argument\nensures it is set for every process during boot.",
			"platforms": [
				"#grub2"
			],
			"oval_definition_id": "oval:ssg-grub2_audit_argument:def:1",
			"remediations": [
				{
					"remediation_id": "grub2_audit_argument",
					"system": "urn:redhat:osbuild:blueprint",
					"fix": "[customizations.kernel]\nappend = \"audit=1\"\n"
				},
				{
					"remediation_id": "grub2_audit_argument",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && { rpm --quiet -q grub2-common; }; then\n\ngrubby --update-kernel=ALL --args=audit=1\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "grub2_audit_argument",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "medium",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83651-0\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.3.1\n  - NIST-800-53-AC-17(1)\n  - NIST-800-53-AU-10\n  - NIST-800-53-AU-14(1)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IR-5(1)\n  - PCI-DSS-Req-10.3\n  - grub2_audit_argument\n  - low_disruption\n  - medium_complexity\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Update grub defaults and the bootloader menu\n  command: /sbin/grubby --update-kernel=ALL --args=\"audit=1\"\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - '\"grub2-common\" in ansible_facts.packages'\n  tags:\n  - CCE-83651-0\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.3.1\n  - NIST-800-53-AC-17(1)\n  - NIST-800-53-AU-10\n  - NIST-800-53-AU-14(1)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IR-5(1)\n  - PCI-DSS-Req-10.3\n  - grub2_audit_argument\n  - low_disruption\n  - medium_complexity\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_immutable": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_immutable",
			"title": "Make the auditd Configuration Immutable",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83716-1"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"18",
				"19",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"5.4.1.1",
				"APO01.06",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"BAI03.05",
				"BAI08.02",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS05.04",
				"DSS05.07",
				"DSS06.02",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.3.1",
				"3.4.3",
				"CCI-000162",
				"CCI-000163",
				"CCI-000164",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.310(a)(2)(iv)",
				"164.312(d)",
				"164.310(d)(2)(iii)",
				"164.312(b)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.7.3",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 2.1",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.8",
				"SR 2.9",
				"SR 5.2",
				"SR 6.1",
				"A.10.1.1",
				"A.11.1.4",
				"A.11.1.5",
				"A.11.2.1",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.1.3",
				"A.13.2.1",
				"A.13.2.3",
				"A.13.2.4",
				"A.14.1.2",
				"A.14.1.3",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.1.2",
				"A.7.1.1",
				"A.7.1.2",
				"A.7.3.1",
				"A.8.2.2",
				"A.8.2.3",
				"A.9.1.1",
				"A.9.1.2",
				"A.9.2.3",
				"A.9.4.1",
				"A.9.4.4",
				"A.9.4.5",
				"AC-6(9)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"ID.SC-4",
				"PR.AC-4",
				"PR.DS-5",
				"PR.PT-1",
				"RS.AN-1",
				"RS.AN-4",
				"Req-10.5.2",
				"SRG-OS-000057-GPOS-00027",
				"SRG-OS-000058-GPOS-00028",
				"SRG-OS-000059-GPOS-00029"
			],
			"description": "If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following line to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code> in order to make the auditd configuration\nimmutable:\n<pre>-e 2</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file in order to make the auditd configuration\nimmutable:\n<pre>-e 2</pre>\nWith this setting, a reboot will be required to change any audit rules.",
			"rationale": "Making the audit configuration immutable prevents accidental as\nwell as malicious modification of the audit rules, although it may be\nproblematic if legitimate changes are needed during system\noperation.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_immutable:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_immutable",
					"system": "urn:xccdf:fix:script:kubernetes",
					"fix": "---\napiVersion: machineconfiguration.openshift.io/v1\nkind: MachineConfig\nspec:\n  config:\n    ignition:\n      version: 3.1.0\n    storage:\n      files:\n      - contents:\n          source: data:,-e%202%0A\n        mode: 0600\n        path: /etc/audit/rules.d/90-immutable.rules\n        overwrite: true\n"
				},
				{
					"remediation_id": "audit_rules_immutable",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# Traverse all of:\n#\n# /etc/audit/audit.rules,\t\t\t(for auditctl case)\n# /etc/audit/rules.d/*.rules\t\t\t(for augenrules case)\n#\n# files to check if '-e .*' setting is present in that '*.rules' file already.\n# If found, delete such occurrence since auditctl(8) manual page instructs the\n# '-e 2' rule should be placed as the last rule in the configuration\nfind /etc/audit /etc/audit/rules.d -maxdepth 1 -type f -name '*.rules' -exec sed -i '/-e[[:space:]]\\+.*/d' {} ';'\n\n# Append '-e 2' requirement at the end of both:\n# * /etc/audit/audit.rules file \t\t(for auditctl case)\n# * /etc/audit/rules.d/immutable.rules\t\t(for augenrules case)\n\nfor AUDIT_FILE in \"/etc/audit/audit.rules\" \"/etc/audit/rules.d/immutable.rules\"\ndo\n\techo '' >> $AUDIT_FILE\n\techo '# Set the audit.rules configuration immutable per security requirements' >> $AUDIT_FILE\n\techo '# Reboot is required to change audit rules once this setting is applied' >> $AUDIT_FILE\n\techo '-e 2' >> $AUDIT_FILE\n\tchmod o-rwx $AUDIT_FILE\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_immutable",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83716-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.3.1\n  - NIST-800-171-3.4.3\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.2\n  - audit_rules_immutable\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Collect all files from /etc/audit/rules.d with .rules extension\n  find:\n    paths: /etc/audit/rules.d/\n    patterns: '*.rules'\n  register: find_rules_d\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83716-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.3.1\n  - NIST-800-171-3.4.3\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.2\n  - audit_rules_immutable\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Remove the -e option from all Audit config files\n  lineinfile:\n    path: '{{ item }}'\n    regexp: ^\\s*(?:-e)\\s+.*$\n    state: absent\n  loop: '{{ find_rules_d.files | map(attribute=''path'') | list + [''/etc/audit/audit.rules'']\n    }}'\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83716-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.3.1\n  - NIST-800-171-3.4.3\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.2\n  - audit_rules_immutable\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add Audit -e option into /etc/audit/rules.d/immutable.rules and /etc/audit/audit.rules\n  lineinfile:\n    path: '{{ item }}'\n    create: true\n    line: -e 2\n    mode: o-rwx\n  loop:\n  - /etc/audit/audit.rules\n  - /etc/audit/rules.d/immutable.rules\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83716-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.3.1\n  - NIST-800-171-3.4.3\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.2\n  - audit_rules_immutable\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_mac_modification": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_mac_modification",
			"title": "Record Events that Modify the System's Mandatory Access Controls",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83721-1"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.8",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.5.5"
			],
			"description": "If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following line to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>:\n<pre>-w /etc/selinux/ -p wa -k MAC-policy</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-w /etc/selinux/ -p wa -k MAC-policy</pre>",
			"rationale": "The system&#x27;s mandatory access policy (SELinux) should not be\narbitrarily changed by anything other than administrator action. All changes to\nMAC policy should be audited.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_mac_modification:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_mac_modification",
					"system": "urn:xccdf:fix:script:kubernetes",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "---\n\napiVersion: machineconfiguration.openshift.io/v1\nkind: MachineConfig\nspec:\n  config:\n    ignition:\n      version: 3.1.0\n    storage:\n      files:\n      - contents:\n          source: data:,{{ -w%20/etc/selinux/%20-p%20wa%20-k%20MAC-policy%0A }}\n        mode: 0600\n        path: /etc/audit/rules.d/75-etcselinux-wa-MAC-policy.rules\n        overwrite: true\n"
				},
				{
					"remediation_id": "audit_rules_mac_modification",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/selinux/\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/selinux/ $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/selinux/$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/selinux/ -p wa -k MAC-policy\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/MAC-policy.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/etc/selinux/\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/MAC-policy.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/MAC-policy.rules\"\n    # If the MAC-policy.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/selinux/\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/selinux/ $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/selinux/$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/selinux/ -p wa -k MAC-policy\" >> \"$audit_rules_file\"\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_mac_modification",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83721-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_mac_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Check if watch rule for /etc/selinux/ already exists in /etc/audit/rules.d/\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/etc/selinux/\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83721-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_mac_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Search /etc/audit/rules.d for other rules with specified key MAC-policy\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)MAC-policy$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CCE-83721-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_mac_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use /etc/audit/rules.d/MAC-policy.rules as the recipient for the rule\n  set_fact:\n    all_files:\n    - /etc/audit/rules.d/MAC-policy.rules\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CCE-83721-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_mac_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use matched file as the recipient for the rule\n  set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CCE-83721-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_mac_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add watch rule for /etc/selinux/ in /etc/audit/rules.d/\n  lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /etc/selinux/ -p wa -k MAC-policy\n    create: true\n    mode: '0640'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CCE-83721-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_mac_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Check if watch rule for /etc/selinux/ already exists in /etc/audit/audit.rules\n  find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/etc/selinux/\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83721-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_mac_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add watch rule for /etc/selinux/ in /etc/audit/audit.rules\n  lineinfile:\n    line: -w /etc/selinux/ -p wa -k MAC-policy\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0640'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - CCE-83721-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.8\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_mac_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_media_export": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_media_export",
			"title": "Ensure auditd Collects Information on Exporting to Media (successful)",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83735-1"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"AC-6(9)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"Req-10.2.7",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000471-GPOS-00215"
			],
			"description": "At a minimum, the audit system should collect media exportation\nevents for all users and root. If the <code>auditd</code> daemon is configured to\nuse the <code>augenrules</code> program to read audit rules during daemon startup\n(the default), add the following line to a file with suffix <code>.rules</code> in\nthe directory <code>/etc/audit/rules.d</code>, setting ARCH to either b32 or b64 as\nappropriate for your system:\n<pre>-a always,exit -F arch=ARCH -S mount -F auid&gt;=1000 -F auid!=unset -F key=export</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file, setting ARCH to either b32 or b64 as\nappropriate for your system:\n<pre>-a always,exit -F arch=ARCH -S mount -F auid&gt;=1000 -F auid!=unset -F key=export</pre>",
			"rationale": "The unauthorized exportation of data to external media could result in an information leak\nwhere classified information, Privacy Act information, and intellectual property could be lost. An audit\ntrail should be created each time a filesystem is mounted to help identify and guard against information\nloss.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_media_export:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_media_export",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"mount\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_media_export",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83735-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_media_export\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit mount tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83735-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_media_export\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for mount for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - mount\n      syscall_grouping: []\n\n  - name: Check existence of mount in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - mount\n      syscall_grouping: []\n\n  - name: Check existence of mount in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83735-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_media_export\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for mount for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - mount\n      syscall_grouping: []\n\n  - name: Check existence of mount in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - mount\n      syscall_grouping: []\n\n  - name: Check existence of mount in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83735-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_media_export\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_networkconfig_modification": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_networkconfig_modification",
			"title": "Record Events that Modify the System's Network Environment",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83706-2"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"AC-6(9)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"Req-10.5.5"
			],
			"description": "If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>, setting ARCH to either b32 or b64 as\nappropriate for your system:\n<pre>-a always,exit -F arch=ARCH -S sethostname,setdomainname -F key=audit_rules_networkconfig_modification\n-w /etc/issue -p wa -k audit_rules_networkconfig_modification\n-w /etc/issue.net -p wa -k audit_rules_networkconfig_modification\n-w /etc/hosts -p wa -k audit_rules_networkconfig_modification\n-w /etc/sysconfig/network -p wa -k audit_rules_networkconfig_modification</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file, setting ARCH to either b32 or b64 as\nappropriate for your system:\n<pre>-a always,exit -F arch=ARCH -S sethostname,setdomainname -F key=audit_rules_networkconfig_modification\n-w /etc/issue -p wa -k audit_rules_networkconfig_modification\n-w /etc/issue.net -p wa -k audit_rules_networkconfig_modification\n-w /etc/hosts -p wa -k audit_rules_networkconfig_modification\n-w /etc/sysconfig/network -p wa -k audit_rules_networkconfig_modification</pre>",
			"rationale": "The network environment should not be modified by anything other\nthan administrator action. Any change to network parameters should be\naudited.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_networkconfig_modification:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_networkconfig_modification",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"\"\n\tSYSCALL=\"sethostname setdomainname\"\n\tKEY=\"audit_rules_networkconfig_modification\"\n\tSYSCALL_GROUPING=\"sethostname setdomainname\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\n# Then perform the remediations for the watch rules\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/issue\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/issue $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/issue$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/issue -p wa -k audit_rules_networkconfig_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/audit_rules_networkconfig_modification.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/etc/issue\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/audit_rules_networkconfig_modification.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/audit_rules_networkconfig_modification.rules\"\n    # If the audit_rules_networkconfig_modification.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/issue\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/issue $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/issue$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/issue -p wa -k audit_rules_networkconfig_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/issue.net\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/issue.net $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/issue.net$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/issue.net -p wa -k audit_rules_networkconfig_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/audit_rules_networkconfig_modification.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/etc/issue.net\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/audit_rules_networkconfig_modification.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/audit_rules_networkconfig_modification.rules\"\n    # If the audit_rules_networkconfig_modification.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/issue.net\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/issue.net $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/issue.net$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/issue.net -p wa -k audit_rules_networkconfig_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/hosts\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/hosts $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/hosts$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/hosts -p wa -k audit_rules_networkconfig_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/audit_rules_networkconfig_modification.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/etc/hosts\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/audit_rules_networkconfig_modification.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/audit_rules_networkconfig_modification.rules\"\n    # If the audit_rules_networkconfig_modification.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/hosts\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/hosts $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/hosts$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/hosts -p wa -k audit_rules_networkconfig_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/sysconfig/network\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/sysconfig/network $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/sysconfig/network$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/sysconfig/network -p wa -k audit_rules_networkconfig_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/audit_rules_networkconfig_modification.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/etc/sysconfig/network\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/audit_rules_networkconfig_modification.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/audit_rules_networkconfig_modification.rules\"\n    # If the audit_rules_networkconfig_modification.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/sysconfig/network\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/sysconfig/network $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/sysconfig/network$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/sysconfig/network -p wa -k audit_rules_networkconfig_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_networkconfig_modification",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set architecture for audit tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Remediate audit rules for network configuration for x86\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - sethostname\n      - setdomainname\n      syscall_grouping:\n      - sethostname\n      - setdomainname\n\n  - name: Check existence of sethostname, setdomainname in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/audit_rules_networkconfig_modification.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/audit_rules_networkconfig_modification.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_rules_networkconfig_modification\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - sethostname\n      - setdomainname\n      syscall_grouping:\n      - sethostname\n      - setdomainname\n\n  - name: Check existence of sethostname, setdomainname in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_rules_networkconfig_modification\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Remediate audit rules for network configuration for x86_64\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - sethostname\n      - setdomainname\n      syscall_grouping:\n      - sethostname\n      - setdomainname\n\n  - name: Check existence of sethostname, setdomainname in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/audit_rules_networkconfig_modification.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/audit_rules_networkconfig_modification.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=audit_rules_networkconfig_modification\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - sethostname\n      - setdomainname\n      syscall_grouping:\n      - sethostname\n      - setdomainname\n\n  - name: Check existence of sethostname, setdomainname in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=audit_rules_networkconfig_modification\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Check if watch rule for /etc/issue already exists in /etc/audit/rules.d/\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/etc/issue\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Search /etc/audit/rules.d for other rules with specified key audit_rules_networkconfig_modification\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)audit_rules_networkconfig_modification$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Use /etc/audit/rules.d/audit_rules_networkconfig_modification.rules as the\n    recipient for the rule\n  set_fact:\n    all_files:\n    - /etc/audit/rules.d/audit_rules_networkconfig_modification.rules\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Use matched file as the recipient for the rule\n  set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Add watch rule for /etc/issue in /etc/audit/rules.d/\n  lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /etc/issue -p wa -k audit_rules_networkconfig_modification\n    create: true\n    mode: '0640'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Check if watch rule for /etc/issue already exists in /etc/audit/audit.rules\n  find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/etc/issue\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Add watch rule for /etc/issue in /etc/audit/audit.rules\n  lineinfile:\n    line: -w /etc/issue -p wa -k audit_rules_networkconfig_modification\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0640'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Check if watch rule for /etc/issue.net already exists in /etc/audit/rules.d/\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/etc/issue.net\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Search /etc/audit/rules.d for other rules with specified key audit_rules_networkconfig_modification\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)audit_rules_networkconfig_modification$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Use /etc/audit/rules.d/audit_rules_networkconfig_modification.rules as the\n    recipient for the rule\n  set_fact:\n    all_files:\n    - /etc/audit/rules.d/audit_rules_networkconfig_modification.rules\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Use matched file as the recipient for the rule\n  set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Add watch rule for /etc/issue.net in /etc/audit/rules.d/\n  lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /etc/issue.net -p wa -k audit_rules_networkconfig_modification\n    create: true\n    mode: '0640'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Check if watch rule for /etc/issue.net already exists in /etc/audit/audit.rules\n  find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/etc/issue.net\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Add watch rule for /etc/issue.net in /etc/audit/audit.rules\n  lineinfile:\n    line: -w /etc/issue.net -p wa -k audit_rules_networkconfig_modification\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0640'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Check if watch rule for /etc/hosts already exists in /etc/audit/rules.d/\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/etc/hosts\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Search /etc/audit/rules.d for other rules with specified key audit_rules_networkconfig_modification\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)audit_rules_networkconfig_modification$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Use /etc/audit/rules.d/audit_rules_networkconfig_modification.rules as the\n    recipient for the rule\n  set_fact:\n    all_files:\n    - /etc/audit/rules.d/audit_rules_networkconfig_modification.rules\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Use matched file as the recipient for the rule\n  set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Add watch rule for /etc/hosts in /etc/audit/rules.d/\n  lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /etc/hosts -p wa -k audit_rules_networkconfig_modification\n    create: true\n    mode: '0640'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Check if watch rule for /etc/hosts already exists in /etc/audit/audit.rules\n  find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/etc/hosts\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Add watch rule for /etc/hosts in /etc/audit/audit.rules\n  lineinfile:\n    line: -w /etc/hosts -p wa -k audit_rules_networkconfig_modification\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0640'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Check if watch rule for /etc/sysconfig/network already exists in /etc/audit/rules.d/\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/etc/sysconfig/network\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Search /etc/audit/rules.d for other rules with specified key audit_rules_networkconfig_modification\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)audit_rules_networkconfig_modification$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Use /etc/audit/rules.d/audit_rules_networkconfig_modification.rules as the\n    recipient for the rule\n  set_fact:\n    all_files:\n    - /etc/audit/rules.d/audit_rules_networkconfig_modification.rules\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Use matched file as the recipient for the rule\n  set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Add watch rule for /etc/sysconfig/network in /etc/audit/rules.d/\n  lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /etc/sysconfig/network -p wa -k audit_rules_networkconfig_modification\n    create: true\n    mode: '0640'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Check if watch rule for /etc/sysconfig/network already exists in /etc/audit/audit.rules\n  find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/etc/sysconfig/network\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Add watch rule for /etc/sysconfig/network in /etc/audit/audit.rules\n  lineinfile:\n    line: -w /etc/sysconfig/network -p wa -k audit_rules_networkconfig_modification\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0640'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - CCE-83706-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_networkconfig_modification\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_session_events": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_session_events",
			"title": "Record Attempts to Alter Process and Session Initiation Information",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83713-8"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"0582",
				"0584",
				"05885",
				"0586",
				"0846",
				"0957",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.2.3"
			],
			"description": "The audit system already collects process information for all\nusers and root. If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code> in order to watch for attempted manual\nedits of files involved in storing such process information:\n<pre>-w /var/run/utmp -p wa -k session\n-w /var/log/btmp -p wa -k session\n-w /var/log/wtmp -p wa -k session</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file in order to watch for attempted manual\nedits of files involved in storing such process information:\n<pre>-w /var/run/utmp -p wa -k session\n-w /var/log/btmp -p wa -k session\n-w /var/log/wtmp -p wa -k session</pre>",
			"rationale": "Manual editing of these files may indicate nefarious activity, such\nas an attacker attempting to remove evidence of an intrusion.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_session_events:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_session_events",
					"system": "urn:xccdf:fix:script:kubernetes",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "---\n\n\napiVersion: machineconfiguration.openshift.io/v1\nkind: MachineConfig\nspec:\n  config:\n    ignition:\n      version: 3.1.0\n    storage:\n      files:\n      - contents:\n          source: data:,{{ %0A-w%20/var/run/utmp%20-p%20wa%20-k%20session%0A-w%20/var/log/btmp%20-p%20wa%20-k%20session%0A-w%20/var/log/wtmp%20-p%20wa%20-k%20session%0A }}\n        mode: 0600\n        path: /etc/audit/rules.d/75-audit-session-events.rules\n        overwrite: true\n"
				},
				{
					"remediation_id": "audit_rules_session_events",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/run/utmp\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/run/utmp $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/var/run/utmp$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /var/run/utmp -p wa -k session\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/session.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/var/run/utmp\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/session.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/session.rules\"\n    # If the session.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/run/utmp\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/run/utmp $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/var/run/utmp$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /var/run/utmp -p wa -k session\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/btmp\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/btmp $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/btmp$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /var/log/btmp -p wa -k session\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/session.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/var/log/btmp\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/session.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/session.rules\"\n    # If the session.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/btmp\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/btmp $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/btmp$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /var/log/btmp -p wa -k session\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/wtmp\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/wtmp $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/wtmp$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /var/log/wtmp -p wa -k session\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/session.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/var/log/wtmp\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/session.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/session.rules\"\n    # If the session.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/wtmp\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/wtmp $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/wtmp$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /var/log/wtmp -p wa -k session\" >> \"$audit_rules_file\"\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_session_events",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83713-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - audit_rules_session_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Check if watch rule for /var/run/utmp already exists in /etc/audit/rules.d/\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/var/run/utmp\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83713-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - audit_rules_session_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Search /etc/audit/rules.d for other rules with specified key session\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)session$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CCE-83713-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - audit_rules_session_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use /etc/audit/rules.d/session.rules as the recipient for the rule\n  set_fact:\n    all_files:\n    - /etc/audit/rules.d/session.rules\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CCE-83713-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - audit_rules_session_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use matched file as the recipient for the rule\n  set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CCE-83713-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - audit_rules_session_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add watch rule for /var/run/utmp in /etc/audit/rules.d/\n  lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /var/run/utmp -p wa -k session\n    create: true\n    mode: '0640'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CCE-83713-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - audit_rules_session_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Check if watch rule for /var/run/utmp already exists in /etc/audit/audit.rules\n  find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/var/run/utmp\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83713-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - audit_rules_session_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add watch rule for /var/run/utmp in /etc/audit/audit.rules\n  lineinfile:\n    line: -w /var/run/utmp -p wa -k session\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0640'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - CCE-83713-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - audit_rules_session_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Check if watch rule for /var/log/btmp already exists in /etc/audit/rules.d/\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/var/log/btmp\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83713-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - audit_rules_session_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Search /etc/audit/rules.d for other rules with specified key session\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)session$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CCE-83713-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - audit_rules_session_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use /etc/audit/rules.d/session.rules as the recipient for the rule\n  set_fact:\n    all_files:\n    - /etc/audit/rules.d/session.rules\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CCE-83713-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - audit_rules_session_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use matched file as the recipient for the rule\n  set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CCE-83713-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - audit_rules_session_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add watch rule for /var/log/btmp in /etc/audit/rules.d/\n  lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /var/log/btmp -p wa -k session\n    create: true\n    mode: '0640'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CCE-83713-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - audit_rules_session_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Check if watch rule for /var/log/btmp already exists in /etc/audit/audit.rules\n  find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/var/log/btmp\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83713-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - audit_rules_session_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add watch rule for /var/log/btmp in /etc/audit/audit.rules\n  lineinfile:\n    line: -w /var/log/btmp -p wa -k session\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0640'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - CCE-83713-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - audit_rules_session_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Check if watch rule for /var/log/wtmp already exists in /etc/audit/rules.d/\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/var/log/wtmp\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83713-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - audit_rules_session_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Search /etc/audit/rules.d for other rules with specified key session\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)session$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CCE-83713-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - audit_rules_session_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use /etc/audit/rules.d/session.rules as the recipient for the rule\n  set_fact:\n    all_files:\n    - /etc/audit/rules.d/session.rules\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CCE-83713-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - audit_rules_session_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use matched file as the recipient for the rule\n  set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CCE-83713-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - audit_rules_session_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add watch rule for /var/log/wtmp in /etc/audit/rules.d/\n  lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /var/log/wtmp -p wa -k session\n    create: true\n    mode: '0640'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CCE-83713-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - audit_rules_session_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Check if watch rule for /var/log/wtmp already exists in /etc/audit/audit.rules\n  find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/var/log/wtmp\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83713-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - audit_rules_session_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Add watch rule for /var/log/wtmp in /etc/audit/audit.rules\n  lineinfile:\n    line: -w /var/log/wtmp -p wa -k session\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0640'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - CCE-83713-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.3\n  - audit_rules_session_events\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_sysadmin_actions": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_sysadmin_actions",
			"title": "Ensure auditd Collects System Administrator Actions",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83729-4"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"18",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"DSS06.03",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000126",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.2.2",
				"4.3.3.3.9",
				"4.3.3.5.1",
				"4.3.3.5.2",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.3.7.2",
				"4.3.3.7.3",
				"4.3.3.7.4",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.1",
				"SR 1.13",
				"SR 1.2",
				"SR 1.3",
				"SR 1.4",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"SR 2.1",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.1.2",
				"A.6.2.1",
				"A.6.2.2",
				"A.7.1.1",
				"A.9.1.2",
				"A.9.2.1",
				"A.9.2.2",
				"A.9.2.3",
				"A.9.2.4",
				"A.9.2.6",
				"A.9.3.1",
				"A.9.4.1",
				"A.9.4.2",
				"A.9.4.3",
				"A.9.4.4",
				"A.9.4.5",
				"AC-2(7)(b)",
				"AU-2(d)",
				"AU-12(c)",
				"AC-6(9)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-1",
				"PR.AC-3",
				"PR.AC-4",
				"PR.AC-6",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.2.2",
				"Req-10.2.5.b",
				"SRG-OS-000004-GPOS-00004",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000304-GPOS-00121",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000470-GPOS-00214",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000239-GPOS-00089",
				"SRG-OS-000240-GPOS-00090",
				"SRG-OS-000241-GPOS-00091",
				"SRG-OS-000303-GPOS-00120",
				"SRG-OS-000304-GPOS-00121",
				"SRG-OS-000466-GPOS-00210",
				"SRG-OS-000476-GPOS-00221",
				"SRG-OS-000462-VMM-001840",
				"SRG-OS-000471-VMM-001910"
			],
			"description": "At a minimum, the audit system should collect administrator actions\nfor all users and root. If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the default),\nadd the following line to a file with suffix <code>.rules</code> in the directory\n<code>/etc/audit/rules.d</code>:\n<pre>-w /etc/sudoers -p wa -k actions\n-w /etc/sudoers.d/ -p wa -k actions</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-w /etc/sudoers -p wa -k actions\n-w /etc/sudoers.d/ -p wa -k actions</pre>",
			"rationale": "The actions taken by system administrators should be audited to keep a record\nof what was executed on the system, as well as, for accountability purposes.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_sysadmin_actions:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_sysadmin_actions",
					"system": "urn:xccdf:fix:script:kubernetes",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "---\napiVersion: machineconfiguration.openshift.io/v1\nkind: MachineConfig\nspec:\n  config:\n    ignition:\n      version: 3.1.0\n    storage:\n      files:\n      - contents:\n          source: data:,{{ -w%20/etc/sudoers.d/%20-p%20wa%20-k%20actions%0A-w%20/etc/sudoers%20-p%20wa%20-k%20actions%0A }}\n        mode: 0600\n        path: /etc/audit/rules.d/75-audit-sysadmin-actions.rules\n        overwrite: true\n"
				},
				{
					"remediation_id": "audit_rules_sysadmin_actions",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/sudoers\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/sudoers $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/sudoers$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/sudoers -p wa -k actions\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/actions.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/etc/sudoers\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/actions.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/actions.rules\"\n    # If the actions.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/sudoers\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/sudoers $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/sudoers$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/sudoers -p wa -k actions\" >> \"$audit_rules_file\"\n    fi\ndone\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/sudoers.d/\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/sudoers.d/ $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/sudoers.d/$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/sudoers.d/ -p wa -k actions\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/actions.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/etc/sudoers.d/\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/actions.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/actions.rules\"\n    # If the actions.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/sudoers.d/\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/sudoers.d/ $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/sudoers.d/$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/sudoers.d/ -p wa -k actions\" >> \"$audit_rules_file\"\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_sysadmin_actions",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83729-4\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(7)(b)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.2\n  - PCI-DSS-Req-10.2.5.b\n  - audit_rules_sysadmin_actions\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Search /etc/audit/rules.d for audit rule entries for sysadmin actions\n  find:\n    paths: /etc/audit/rules.d\n    recurse: false\n    contains: ^.*/etc/sudoers.*$\n    patterns: '*.rules'\n  register: find_audit_sysadmin_actions\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83729-4\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(7)(b)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.2\n  - PCI-DSS-Req-10.2.5.b\n  - audit_rules_sysadmin_actions\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Use /etc/audit/rules.d/actions.rules as the recipient for the rule\n  set_fact:\n    all_sysadmin_actions_files:\n    - /etc/audit/rules.d/actions.rules\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_audit_sysadmin_actions.matched is defined and find_audit_sysadmin_actions.matched\n    == 0\n  tags:\n  - CCE-83729-4\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(7)(b)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.2\n  - PCI-DSS-Req-10.2.5.b\n  - audit_rules_sysadmin_actions\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Use matched file as the recipient for the rule\n  set_fact:\n    all_sysadmin_actions_files:\n    - '{{ find_audit_sysadmin_actions.files | map(attribute=''path'') | list | first\n      }}'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_audit_sysadmin_actions.matched is defined and find_audit_sysadmin_actions.matched\n    > 0\n  tags:\n  - CCE-83729-4\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(7)(b)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.2\n  - PCI-DSS-Req-10.2.5.b\n  - audit_rules_sysadmin_actions\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Inserts/replaces audit rule for /etc/sudoers rule in rules.d\n  lineinfile:\n    path: '{{ all_sysadmin_actions_files[0] }}'\n    line: -w /etc/sudoers -p wa -k actions\n    create: true\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83729-4\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(7)(b)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.2\n  - PCI-DSS-Req-10.2.5.b\n  - audit_rules_sysadmin_actions\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Inserts/replaces audit rule for /etc/sudoers.d rule in rules.d\n  lineinfile:\n    path: '{{ all_sysadmin_actions_files[0] }}'\n    line: -w /etc/sudoers.d/ -p wa -k actions\n    create: true\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83729-4\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(7)(b)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.2\n  - PCI-DSS-Req-10.2.5.b\n  - audit_rules_sysadmin_actions\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Inserts/replaces audit rule for /etc/sudoers in audit.rules\n  lineinfile:\n    path: /etc/audit/audit.rules\n    line: -w /etc/sudoers -p wa -k actions\n    create: true\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83729-4\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(7)(b)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.2\n  - PCI-DSS-Req-10.2.5.b\n  - audit_rules_sysadmin_actions\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Inserts/replaces audit rule for /etc/sudoers.d in audit.rules\n  lineinfile:\n    path: /etc/audit/audit.rules\n    line: -w /etc/sudoers.d/ -p wa -k actions\n    create: true\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83729-4\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(7)(b)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.2\n  - PCI-DSS-Req-10.2.5.b\n  - audit_rules_sysadmin_actions\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_group": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_group",
			"title": "Record Events that Modify User/Group Information - /etc/group",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83722-9"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"18",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"DSS06.03",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000018",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-001403",
				"CCI-001404",
				"CCI-001405",
				"CCI-001683",
				"CCI-001684",
				"CCI-001685",
				"CCI-001686",
				"CCI-002130",
				"CCI-002132",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.2.2",
				"4.3.3.3.9",
				"4.3.3.5.1",
				"4.3.3.5.2",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.3.7.2",
				"4.3.3.7.3",
				"4.3.3.7.4",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.1",
				"SR 1.13",
				"SR 1.2",
				"SR 1.3",
				"SR 1.4",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"SR 2.1",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.1.2",
				"A.6.2.1",
				"A.6.2.2",
				"A.7.1.1",
				"A.9.1.2",
				"A.9.2.1",
				"A.9.2.2",
				"A.9.2.3",
				"A.9.2.4",
				"A.9.2.6",
				"A.9.3.1",
				"A.9.4.1",
				"A.9.4.2",
				"A.9.4.3",
				"A.9.4.4",
				"A.9.4.5",
				"CIP-004-6 R2.2.2",
				"CIP-004-6 R2.2.3",
				"CIP-007-3 R.1.3",
				"CIP-007-3 R5",
				"CIP-007-3 R5.1.1",
				"CIP-007-3 R5.1.3",
				"CIP-007-3 R5.2.1",
				"CIP-007-3 R5.2.3",
				"AC-2(4)",
				"AU-2(d)",
				"AU-12(c)",
				"AC-6(9)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-1",
				"PR.AC-3",
				"PR.AC-4",
				"PR.AC-6",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.2.5",
				"SRG-OS-000004-GPOS-00004",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000304-GPOS-00121",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000470-GPOS-00214",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000239-GPOS-00089",
				"SRG-OS-000240-GPOS-00090",
				"SRG-OS-000241-GPOS-00091",
				"SRG-OS-000303-GPOS-00120",
				"SRG-OS-000466-GPOS-00210",
				"SRG-OS-000476-GPOS-00221",
				"SRG-OS-000004-VMM-000040",
				"SRG-OS-000239-VMM-000810",
				"SRG-OS-000240-VMM-000820",
				"SRG-OS-000241-VMM-000830",
				"SRG-OS-000274-VMM-000960",
				"SRG-OS-000275-VMM-000970",
				"SRG-OS-000276-VMM-000980",
				"SRG-OS-000277-VMM-000990",
				"SRG-OS-000303-VMM-001090",
				"SRG-OS-000304-VMM-001100",
				"SRG-OS-000476-VMM-001960"
			],
			"description": "If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>, in order to capture events that modify\naccount changes:\n<br><br>\n<pre>-w /etc/group -p wa -k audit_rules_usergroup_modification</pre>\n<br><br>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file, in order to capture events that modify\naccount changes:\n<br><br>\n<pre>-w /etc/group -p wa -k audit_rules_usergroup_modification</pre>",
			"rationale": "In addition to auditing new user and group accounts, these watches\nwill alert the system administrator(s) to any modifications. Any unexpected\nusers, groups, or modifications should be investigated for legitimacy.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_usergroup_modification_group:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_usergroup_modification_group",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/group\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/group $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/group$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/group -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/etc/group\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/audit_rules_usergroup_modification.rules\"\n    # If the audit_rules_usergroup_modification.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/group\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/group $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/group$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/group -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_usergroup_modification_group",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83722-9\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit group tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83722-9\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Search /etc/audit/rules.d for other user/group modification audit rules\n  find:\n    paths: /etc/audit/rules.d\n    recurse: false\n    contains: -k audit_rules_usergroup_modification$\n    patterns: '*.rules'\n  register: find_group\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83722-9\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: If existing user/group modification ruleset not found, use /etc/audit/rules.d/privileged.rules\n    as the recipient for the rule\n  set_fact:\n    all_files:\n    - /etc/audit/rules.d/privileged.rules\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_group.matched is defined and find_group.matched == 0\n  tags:\n  - CCE-83722-9\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use matched file as the recipient for the rule\n  set_fact:\n    all_files:\n    - '{{ find_group.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_group.matched is defined and find_group.matched > 0\n  tags:\n  - CCE-83722-9\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Inserts/replaces the group rule in rules.d when on x86\n  lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /etc/group -p wa -k audit_rules_usergroup_modification\n    create: true\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83722-9\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Inserts/replaces the group rule in /etc/audit/audit.rules\n  lineinfile:\n    line: -w /etc/group -p wa -k audit_rules_usergroup_modification\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83722-9\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_gshadow": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_gshadow",
			"title": "Record Events that Modify User/Group Information - /etc/gshadow",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83723-7"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"18",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"DSS06.03",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000018",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-001403",
				"CCI-001404",
				"CCI-001405",
				"CCI-001683",
				"CCI-001684",
				"CCI-001685",
				"CCI-001686",
				"CCI-002130",
				"CCI-002132",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.2.2",
				"4.3.3.3.9",
				"4.3.3.5.1",
				"4.3.3.5.2",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.3.7.2",
				"4.3.3.7.3",
				"4.3.3.7.4",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.1",
				"SR 1.13",
				"SR 1.2",
				"SR 1.3",
				"SR 1.4",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"SR 2.1",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.1.2",
				"A.6.2.1",
				"A.6.2.2",
				"A.7.1.1",
				"A.9.1.2",
				"A.9.2.1",
				"A.9.2.2",
				"A.9.2.3",
				"A.9.2.4",
				"A.9.2.6",
				"A.9.3.1",
				"A.9.4.1",
				"A.9.4.2",
				"A.9.4.3",
				"A.9.4.4",
				"A.9.4.5",
				"CIP-004-6 R2.2.2",
				"CIP-004-6 R2.2.3",
				"CIP-007-3 R.1.3",
				"CIP-007-3 R5",
				"CIP-007-3 R5.1.1",
				"CIP-007-3 R5.1.3",
				"CIP-007-3 R5.2.1",
				"CIP-007-3 R5.2.3",
				"AC-2(4)",
				"AU-2(d)",
				"AU-12(c)",
				"AC-6(9)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-1",
				"PR.AC-3",
				"PR.AC-4",
				"PR.AC-6",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.2.5",
				"SRG-OS-000004-GPOS-00004",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000304-GPOS-00121",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000470-GPOS-00214",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000239-GPOS-00089",
				"SRG-OS-000240-GPOS-00090",
				"SRG-OS-000241-GPOS-00091",
				"SRG-OS-000303-GPOS-00120",
				"SRG-OS-000466-GPOS-00210",
				"SRG-OS-000476-GPOS-00221",
				"SRG-OS-000004-VMM-000040",
				"SRG-OS-000239-VMM-000810",
				"SRG-OS-000240-VMM-000820",
				"SRG-OS-000241-VMM-000830",
				"SRG-OS-000274-VMM-000960",
				"SRG-OS-000275-VMM-000970",
				"SRG-OS-000276-VMM-000980",
				"SRG-OS-000277-VMM-000990",
				"SRG-OS-000303-VMM-001090",
				"SRG-OS-000304-VMM-001100",
				"SRG-OS-000476-VMM-001960"
			],
			"description": "If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>, in order to capture events that modify\naccount changes:\n<br><br>\n<pre>-w /etc/gshadow -p wa -k audit_rules_usergroup_modification</pre>\n<br><br>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file, in order to capture events that modify\naccount changes:\n<br><br>\n<pre>-w /etc/gshadow -p wa -k audit_rules_usergroup_modification</pre>",
			"rationale": "In addition to auditing new user and group accounts, these watches\nwill alert the system administrator(s) to any modifications. Any unexpected\nusers, groups, or modifications should be investigated for legitimacy.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_usergroup_modification_gshadow:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_usergroup_modification_gshadow",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/gshadow\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/gshadow $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/gshadow$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/gshadow -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/etc/gshadow\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/audit_rules_usergroup_modification.rules\"\n    # If the audit_rules_usergroup_modification.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/gshadow\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/gshadow $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/gshadow$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/gshadow -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_usergroup_modification_gshadow",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83723-7\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_gshadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit gshadow tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83723-7\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_gshadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Search /etc/audit/rules.d for other user/group modification audit rules\n  find:\n    paths: /etc/audit/rules.d\n    recurse: false\n    contains: -k audit_rules_usergroup_modification$\n    patterns: '*.rules'\n  register: find_gshadow\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83723-7\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_gshadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: If existing user/group modification ruleset not found, use /etc/audit/rules.d/privileged.rules\n    as the recipient for the rule\n  set_fact:\n    all_files:\n    - /etc/audit/rules.d/privileged.rules\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_gshadow.matched is defined and find_gshadow.matched == 0\n  tags:\n  - CCE-83723-7\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_gshadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use matched file as the recipient for the rule\n  set_fact:\n    all_files:\n    - '{{ find_gshadow.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_gshadow.matched is defined and find_gshadow.matched > 0\n  tags:\n  - CCE-83723-7\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_gshadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Inserts/replaces the gshadow rule in rules.d when on x86\n  lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /etc/gshadow -p wa -k audit_rules_usergroup_modification\n    create: true\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83723-7\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_gshadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Inserts/replaces the gshadow rule in /etc/audit/audit.rules\n  lineinfile:\n    line: -w /etc/gshadow -p wa -k audit_rules_usergroup_modification\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83723-7\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_gshadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_opasswd": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_opasswd",
			"title": "Record Events that Modify User/Group Information - /etc/security/opasswd",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83712-0"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"18",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"DSS06.03",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000018",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-001403",
				"CCI-001404",
				"CCI-001405",
				"CCI-001683",
				"CCI-001684",
				"CCI-001685",
				"CCI-001686",
				"CCI-002130",
				"CCI-002132",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.2.2",
				"4.3.3.3.9",
				"4.3.3.5.1",
				"4.3.3.5.2",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.3.7.2",
				"4.3.3.7.3",
				"4.3.3.7.4",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.1",
				"SR 1.13",
				"SR 1.2",
				"SR 1.3",
				"SR 1.4",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"SR 2.1",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.1.2",
				"A.6.2.1",
				"A.6.2.2",
				"A.7.1.1",
				"A.9.1.2",
				"A.9.2.1",
				"A.9.2.2",
				"A.9.2.3",
				"A.9.2.4",
				"A.9.2.6",
				"A.9.3.1",
				"A.9.4.1",
				"A.9.4.2",
				"A.9.4.3",
				"A.9.4.4",
				"A.9.4.5",
				"CIP-004-6 R2.2.2",
				"CIP-004-6 R2.2.3",
				"CIP-007-3 R.1.3",
				"CIP-007-3 R5",
				"CIP-007-3 R5.1.1",
				"CIP-007-3 R5.1.3",
				"CIP-007-3 R5.2.1",
				"CIP-007-3 R5.2.3",
				"AC-2(4)",
				"AU-2(d)",
				"AU-12(c)",
				"AC-6(9)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-1",
				"PR.AC-3",
				"PR.AC-4",
				"PR.AC-6",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.2.5",
				"SRG-OS-000004-GPOS-00004",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000304-GPOS-00121",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000470-GPOS-00214",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000239-GPOS-00089",
				"SRG-OS-000240-GPOS-00090",
				"SRG-OS-000241-GPOS-00091",
				"SRG-OS-000303-GPOS-00120",
				"SRG-OS-000466-GPOS-00210",
				"SRG-OS-000476-GPOS-00221",
				"SRG-OS-000004-VMM-000040",
				"SRG-OS-000239-VMM-000810",
				"SRG-OS-000240-VMM-000820",
				"SRG-OS-000241-VMM-000830",
				"SRG-OS-000274-VMM-000960",
				"SRG-OS-000275-VMM-000970",
				"SRG-OS-000276-VMM-000980",
				"SRG-OS-000277-VMM-000990",
				"SRG-OS-000303-VMM-001090",
				"SRG-OS-000304-VMM-001100",
				"SRG-OS-000476-VMM-001960"
			],
			"description": "If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>, in order to capture events that modify\naccount changes:\n<br><br>\n<pre>-w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification</pre>\n<br><br>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file, in order to capture events that modify\naccount changes:\n<br><br>\n<pre>-w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification</pre>",
			"rationale": "In addition to auditing new user and group accounts, these watches\nwill alert the system administrator(s) to any modifications. Any unexpected\nusers, groups, or modifications should be investigated for legitimacy.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_usergroup_modification_opasswd:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_usergroup_modification_opasswd",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/security/opasswd\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/security/opasswd $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/security/opasswd$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/etc/security/opasswd\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/audit_rules_usergroup_modification.rules\"\n    # If the audit_rules_usergroup_modification.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/security/opasswd\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/security/opasswd $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/security/opasswd$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_usergroup_modification_opasswd",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83712-0\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_opasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit opasswd tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83712-0\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_opasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Search /etc/audit/rules.d for other user/group modification audit rules\n  find:\n    paths: /etc/audit/rules.d\n    recurse: false\n    contains: -k audit_rules_usergroup_modification$\n    patterns: '*.rules'\n  register: find_opasswd\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83712-0\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_opasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: If existing user/group modification ruleset not found, use /etc/audit/rules.d/privileged.rules\n    as the recipient for the rule\n  set_fact:\n    all_files:\n    - /etc/audit/rules.d/privileged.rules\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_opasswd.matched is defined and find_opasswd.matched == 0\n  tags:\n  - CCE-83712-0\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_opasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use matched file as the recipient for the rule\n  set_fact:\n    all_files:\n    - '{{ find_opasswd.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_opasswd.matched is defined and find_opasswd.matched > 0\n  tags:\n  - CCE-83712-0\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_opasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Inserts/replaces the opasswd rule in rules.d when on x86\n  lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification\n    create: true\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83712-0\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_opasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Inserts/replaces the opasswd rule in /etc/audit/audit.rules\n  lineinfile:\n    line: -w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83712-0\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_opasswd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_passwd": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_passwd",
			"title": "Record Events that Modify User/Group Information - /etc/passwd",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83714-6"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"18",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"DSS06.03",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000018",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-001403",
				"CCI-001404",
				"CCI-001405",
				"CCI-001683",
				"CCI-001684",
				"CCI-001685",
				"CCI-001686",
				"CCI-002130",
				"CCI-002132",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.2.2",
				"4.3.3.3.9",
				"4.3.3.5.1",
				"4.3.3.5.2",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.3.7.2",
				"4.3.3.7.3",
				"4.3.3.7.4",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.1",
				"SR 1.13",
				"SR 1.2",
				"SR 1.3",
				"SR 1.4",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"SR 2.1",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.1.2",
				"A.6.2.1",
				"A.6.2.2",
				"A.7.1.1",
				"A.9.1.2",
				"A.9.2.1",
				"A.9.2.2",
				"A.9.2.3",
				"A.9.2.4",
				"A.9.2.6",
				"A.9.3.1",
				"A.9.4.1",
				"A.9.4.2",
				"A.9.4.3",
				"A.9.4.4",
				"A.9.4.5",
				"CIP-004-6 R2.2.2",
				"CIP-004-6 R2.2.3",
				"CIP-007-3 R.1.3",
				"CIP-007-3 R5",
				"CIP-007-3 R5.1.1",
				"CIP-007-3 R5.1.3",
				"CIP-007-3 R5.2.1",
				"CIP-007-3 R5.2.3",
				"AC-2(4)",
				"AU-2(d)",
				"AU-12(c)",
				"AC-6(9)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-1",
				"PR.AC-3",
				"PR.AC-4",
				"PR.AC-6",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.2.5",
				"SRG-OS-000004-GPOS-00004",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000304-GPOS-00121",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000470-GPOS-00214",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000239-GPOS-00089",
				"SRG-OS-000240-GPOS-00090",
				"SRG-OS-000241-GPOS-00091",
				"SRG-OS-000303-GPOS-00120",
				"SRG-OS-000304-GPOS-00121",
				"SRG-OS-000466-GPOS-00210",
				"SRG-OS-000476-GPOS-00221",
				"SRG-OS-000274-GPOS-00104",
				"SRG-OS-000275-GPOS-00105",
				"SRG-OS-000276-GPOS-00106",
				"SRG-OS-000277-GPOS-00107",
				"SRG-OS-000004-VMM-000040",
				"SRG-OS-000239-VMM-000810",
				"SRG-OS-000240-VMM-000820",
				"SRG-OS-000241-VMM-000830",
				"SRG-OS-000274-VMM-000960",
				"SRG-OS-000275-VMM-000970",
				"SRG-OS-000276-VMM-000980",
				"SRG-OS-000277-VMM-000990",
				"SRG-OS-000303-VMM-001090",
				"SRG-OS-000304-VMM-001100",
				"SRG-OS-000476-VMM-001960"
			],
			"description": "If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>, in order to capture events that modify\naccount changes:\n<br><br>\n<pre>-w /etc/passwd -p wa -k audit_rules_usergroup_modification</pre>\n<br><br>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file, in order to capture events that modify\naccount changes:\n<br><br>\n<pre>-w /etc/passwd -p wa -k audit_rules_usergroup_modification</pre>",
			"rationale": "In addition to auditing new user and group accounts, these watches\nwill alert the system administrator(s) to any modifications. Any unexpected\nusers, groups, or modifications should be investigated for legitimacy.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_usergroup_modification_passwd:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_usergroup_modification_passwd",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/passwd\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/passwd $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/passwd$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/passwd -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/etc/passwd\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/audit_rules_usergroup_modification.rules\"\n    # If the audit_rules_usergroup_modification.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/passwd\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/passwd $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/passwd$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/passwd -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_usergroup_modification_passwd",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83714-6\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit passwd tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83714-6\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Search /etc/audit/rules.d for other user/group modification audit rules\n  find:\n    paths: /etc/audit/rules.d\n    recurse: false\n    contains: -k audit_rules_usergroup_modification$\n    patterns: '*.rules'\n  register: find_passwd\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83714-6\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: If existing user/group modification ruleset not found, use /etc/audit/rules.d/privileged.rules\n    as the recipient for the rule\n  set_fact:\n    all_files:\n    - /etc/audit/rules.d/privileged.rules\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_passwd.matched is defined and find_passwd.matched == 0\n  tags:\n  - CCE-83714-6\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use matched file as the recipient for the rule\n  set_fact:\n    all_files:\n    - '{{ find_passwd.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_passwd.matched is defined and find_passwd.matched > 0\n  tags:\n  - CCE-83714-6\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Inserts/replaces the passwd rule in rules.d when on x86\n  lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /etc/passwd -p wa -k audit_rules_usergroup_modification\n    create: true\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83714-6\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Inserts/replaces the passwd rule in /etc/audit/audit.rules\n  lineinfile:\n    line: -w /etc/passwd -p wa -k audit_rules_usergroup_modification\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83714-6\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_shadow": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_shadow",
			"title": "Record Events that Modify User/Group Information - /etc/shadow",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83725-2"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"18",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"DSS06.03",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000018",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-001403",
				"CCI-001404",
				"CCI-001405",
				"CCI-001683",
				"CCI-001684",
				"CCI-001685",
				"CCI-001686",
				"CCI-002130",
				"CCI-002132",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.2.2",
				"4.3.3.3.9",
				"4.3.3.5.1",
				"4.3.3.5.2",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.3.7.2",
				"4.3.3.7.3",
				"4.3.3.7.4",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.1",
				"SR 1.13",
				"SR 1.2",
				"SR 1.3",
				"SR 1.4",
				"SR 1.5",
				"SR 1.7",
				"SR 1.8",
				"SR 1.9",
				"SR 2.1",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.1.2",
				"A.6.2.1",
				"A.6.2.2",
				"A.7.1.1",
				"A.9.1.2",
				"A.9.2.1",
				"A.9.2.2",
				"A.9.2.3",
				"A.9.2.4",
				"A.9.2.6",
				"A.9.3.1",
				"A.9.4.1",
				"A.9.4.2",
				"A.9.4.3",
				"A.9.4.4",
				"A.9.4.5",
				"CIP-004-6 R2.2.2",
				"CIP-004-6 R2.2.3",
				"CIP-007-3 R.1.3",
				"CIP-007-3 R5",
				"CIP-007-3 R5.1.1",
				"CIP-007-3 R5.1.3",
				"CIP-007-3 R5.2.1",
				"CIP-007-3 R5.2.3",
				"AC-2(4)",
				"AU-2(d)",
				"AU-12(c)",
				"AC-6(9)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-1",
				"PR.AC-3",
				"PR.AC-4",
				"PR.AC-6",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.2.5",
				"SRG-OS-000004-GPOS-00004",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000304-GPOS-00121",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000470-GPOS-00214",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000239-GPOS-00089",
				"SRG-OS-000240-GPOS-00090",
				"SRG-OS-000241-GPOS-00091",
				"SRG-OS-000303-GPOS-00120",
				"SRG-OS-000466-GPOS-00210",
				"SRG-OS-000476-GPOS-00221",
				"SRG-OS-000004-VMM-000040",
				"SRG-OS-000239-VMM-000810",
				"SRG-OS-000240-VMM-000820",
				"SRG-OS-000241-VMM-000830",
				"SRG-OS-000274-VMM-000960",
				"SRG-OS-000275-VMM-000970",
				"SRG-OS-000276-VMM-000980",
				"SRG-OS-000277-VMM-000990",
				"SRG-OS-000303-VMM-001090",
				"SRG-OS-000304-VMM-001100",
				"SRG-OS-000476-VMM-001960"
			],
			"description": "If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>, in order to capture events that modify\naccount changes:\n<br><br>\n<pre>-w /etc/shadow -p wa -k audit_rules_usergroup_modification</pre>\n<br><br>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file, in order to capture events that modify\naccount changes:\n<br><br>\n<pre>-w /etc/shadow -p wa -k audit_rules_usergroup_modification</pre>",
			"rationale": "In addition to auditing new user and group accounts, these watches\nwill alert the system administrator(s) to any modifications. Any unexpected\nusers, groups, or modifications should be investigated for legitimacy.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_usergroup_modification_shadow:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_usergroup_modification_shadow",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/shadow\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/shadow $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/shadow$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/shadow -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/etc/shadow\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/audit_rules_usergroup_modification.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/audit_rules_usergroup_modification.rules\"\n    # If the audit_rules_usergroup_modification.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/shadow\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/shadow $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/shadow$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/shadow -p wa -k audit_rules_usergroup_modification\" >> \"$audit_rules_file\"\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_usergroup_modification_shadow",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83725-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit shadow tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83725-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Search /etc/audit/rules.d for other user/group modification audit rules\n  find:\n    paths: /etc/audit/rules.d\n    recurse: false\n    contains: -k audit_rules_usergroup_modification$\n    patterns: '*.rules'\n  register: find_shadow\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83725-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: If existing user/group modification ruleset not found, use /etc/audit/rules.d/privileged.rules\n    as the recipient for the rule\n  set_fact:\n    all_files:\n    - /etc/audit/rules.d/privileged.rules\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_shadow.matched is defined and find_shadow.matched == 0\n  tags:\n  - CCE-83725-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Use matched file as the recipient for the rule\n  set_fact:\n    all_files:\n    - '{{ find_shadow.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_shadow.matched is defined and find_shadow.matched > 0\n  tags:\n  - CCE-83725-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Inserts/replaces the shadow rule in rules.d when on x86\n  lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /etc/shadow -p wa -k audit_rules_usergroup_modification\n    create: true\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83725-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Inserts/replaces the shadow rule in /etc/audit/audit.rules\n  lineinfile:\n    line: -w /etc/shadow -p wa -k audit_rules_usergroup_modification\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83725-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.5\n  - audit_rules_usergroup_modification_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_file_ownership_var_log_audit": {
			"rule_id": "xccdf_org.ssgproject.content_rule_file_ownership_var_log_audit",
			"title": "System Audit Logs Must Be Owned By Root",
			"result": "pass",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83726-0"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"18",
				"19",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"5.4.1.1",
				"APO01.06",
				"APO11.04",
				"APO12.06",
				"BAI03.05",
				"BAI08.02",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS05.04",
				"DSS05.07",
				"DSS06.02",
				"MEA02.01",
				"3.3.1",
				"CCI-000162",
				"CCI-000163",
				"CCI-000164",
				"CCI-001314",
				"4.2.3.10",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.7.3",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 2.1",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.8",
				"SR 2.9",
				"SR 5.2",
				"SR 6.1",
				"A.10.1.1",
				"A.11.1.4",
				"A.11.1.5",
				"A.11.2.1",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.1.3",
				"A.13.2.1",
				"A.13.2.3",
				"A.13.2.4",
				"A.14.1.2",
				"A.14.1.3",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.1.2",
				"A.7.1.1",
				"A.7.1.2",
				"A.7.3.1",
				"A.8.2.2",
				"A.8.2.3",
				"A.9.1.1",
				"A.9.1.2",
				"A.9.2.3",
				"A.9.4.1",
				"A.9.4.4",
				"A.9.4.5",
				"CIP-003-8 R5.1.1",
				"CIP-003-8 R5.3",
				"CIP-004-6 R2.3",
				"CIP-007-3 R2.1",
				"CIP-007-3 R2.2",
				"CIP-007-3 R2.3",
				"CIP-007-3 R5.1",
				"CIP-007-3 R5.1.1",
				"CIP-007-3 R5.1.2",
				"CM-6(a)",
				"AC-6(1)",
				"AU-9(4)",
				"DE.AE-3",
				"DE.AE-5",
				"PR.AC-4",
				"PR.DS-5",
				"PR.PT-1",
				"RS.AN-1",
				"RS.AN-4",
				"Req-10.5.1",
				"SRG-OS-000057-GPOS-00027",
				"SRG-OS-000058-GPOS-00028",
				"SRG-OS-000059-GPOS-00029"
			],
			"description": "All audit logs must be owned by root user and group. By default, the path for audit log is <pre>/var/log/audit/</pre>.\n\nTo properly set the owner of <code>/var/log/audit</code>, run the command:\n<pre>$ sudo chown root /var/log/audit </pre>\n\nTo properly set the owner of <code>/var/log/audit/*</code>, run the command:\n<pre>$ sudo chown root /var/log/audit/* </pre>",
			"rationale": "Unauthorized disclosure of audit records can reveal system and configuration data to\nattackers, thus compromising its confidentiality.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-file_ownership_var_log_audit:def:1",
			"remediations": [
				{
					"remediation_id": "file_ownership_var_log_audit",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\nif LC_ALL=C grep -m 1 -q ^log_group /etc/audit/auditd.conf; then\n  GROUP=$(awk -F \"=\" '/log_group/ {print $2}' /etc/audit/auditd.conf | tr -d ' ')\n  if ! [ \"${GROUP}\" == 'root' ] ; then\n    chown root:${GROUP} /var/log/audit\n    chown root:${GROUP} /var/log/audit/audit.log*\n  else\n    chown root:root /var/log/audit\n    chown root:root /var/log/audit/audit.log*\n  fi\nelse\n  chown root:root /var/log/audit\n  chown root:root /var/log/audit/audit.log*\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_file_permissions_var_log_audit": {
			"rule_id": "xccdf_org.ssgproject.content_rule_file_permissions_var_log_audit",
			"title": "System Audit Logs Must Have Mode 0640 or Less Permissive",
			"result": "pass",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83720-3"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"18",
				"19",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"5.4.1.1",
				"APO01.06",
				"APO11.04",
				"APO12.06",
				"BAI03.05",
				"BAI08.02",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS05.04",
				"DSS05.07",
				"DSS06.02",
				"MEA02.01",
				"3.3.1",
				"CCI-000162",
				"CCI-000163",
				"CCI-000164",
				"CCI-001314",
				"4.2.3.10",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.7.3",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 2.1",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.8",
				"SR 2.9",
				"SR 5.2",
				"SR 6.1",
				"A.10.1.1",
				"A.11.1.4",
				"A.11.1.5",
				"A.11.2.1",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.1.3",
				"A.13.2.1",
				"A.13.2.3",
				"A.13.2.4",
				"A.14.1.2",
				"A.14.1.3",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.1.2",
				"A.7.1.1",
				"A.7.1.2",
				"A.7.3.1",
				"A.8.2.2",
				"A.8.2.3",
				"A.9.1.1",
				"A.9.1.2",
				"A.9.2.3",
				"A.9.4.1",
				"A.9.4.4",
				"A.9.4.5",
				"CIP-003-8 R5.1.1",
				"CIP-003-8 R5.3",
				"CIP-004-6 R2.3",
				"CIP-007-3 R2.1",
				"CIP-007-3 R2.2",
				"CIP-007-3 R2.3",
				"CIP-007-3 R5.1",
				"CIP-007-3 R5.1.1",
				"CIP-007-3 R5.1.2",
				"CM-6(a)",
				"AC-6(1)",
				"AU-9(4)",
				"DE.AE-3",
				"DE.AE-5",
				"PR.AC-4",
				"PR.DS-5",
				"PR.PT-1",
				"RS.AN-1",
				"RS.AN-4",
				"Req-10.5",
				"SRG-OS-000057-GPOS-00027",
				"SRG-OS-000058-GPOS-00028",
				"SRG-OS-000059-GPOS-00029",
				"SRG-OS-000206-GPOS-00084"
			],
			"description": "\nDetermine where the audit logs are stored with the following command:\n<pre>$ sudo grep -iw log_file /etc/audit/auditd.conf\nlog_file = /var/log/audit/audit.log</pre>\nConfigure the audit log to be protected from unauthorized read access by setting the correct\npermissive mode with the following command:\n<pre>$ sudo chmod 0600 <i>audit_log_file</i></pre>\nBy default, <i>audit_log_file</i> is &quot;/var/log/audit/audit.log&quot;.",
			"rationale": "If users can write to audit logs, audit trails can be modified or destroyed.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-file_permissions_var_log_audit:def:1",
			"remediations": [
				{
					"remediation_id": "file_permissions_var_log_audit",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\nif LC_ALL=C grep -iw ^log_file /etc/audit/auditd.conf; then\n    FILE=$(awk -F \"=\" '/^log_file/ {print $2}' /etc/audit/auditd.conf | tr -d ' ')\nelse\n    FILE=\"/var/log/audit/audit.log\"\nfi\n\n\nchmod 0600 $FILE\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_chmod": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_chmod",
			"title": "Record Events that Modify the System's Discretionary Access Controls - chmod",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83830-0"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000126",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.5.5",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000064-GPOS-00033",
				"SRG-OS-000466-GPOS-00210",
				"SRG-OS-000458-GPOS-00203",
				"SRG-OS-000458-VMM-001810",
				"SRG-OS-000474-VMM-001940"
			],
			"description": "At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured to\nuse the <code>augenrules</code> program to read audit rules during daemon startup\n(the default), add the following line to a file with suffix <code>.rules</code> in\nthe directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S chmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S chmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S chmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S chmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>",
			"rationale": "The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.",
			"warnings": [
				{
					"text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect.  Here the system calls\nhave been placed independent of other system calls.  Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
					"category": "general"
				}
			],
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_dac_modification_chmod:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_dac_modification_chmod",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"chmod\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"chmod fchmod fchmodat\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_dac_modification_chmod",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83830-0\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_chmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit chmod tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83830-0\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_chmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for chmod for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - chmod\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of chmod in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - chmod\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of chmod in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83830-0\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_chmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for chmod for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - chmod\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of chmod in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - chmod\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of chmod in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83830-0\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_chmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_chown": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_chown",
			"title": "Record Events that Modify the System's Discretionary Access Controls - chown",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83812-8"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000126",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.5.5",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000064-GPOS-00033",
				"SRG-OS-000466-GPOS-00210",
				"SRG-OS-000458-GPOS-00203",
				"SRG-OS-000474-GPOS-00219",
				"SRG-OS-000458-VMM-001810",
				"SRG-OS-000474-VMM-001940"
			],
			"description": "At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured to\nuse the <code>augenrules</code> program to read audit rules during daemon startup\n(the default), add the following line to a file with suffix <code>.rules</code> in\nthe directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S chown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S chown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S chown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S chown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>",
			"rationale": "The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.",
			"warnings": [
				{
					"text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect.  Here the system calls\nhave been placed independent of other system calls.  Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
					"category": "general"
				}
			],
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_dac_modification_chown:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_dac_modification_chown",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"chown\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"chown fchown fchownat lchown\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_dac_modification_chown",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83812-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_chown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit chown tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83812-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_chown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for chown for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - chown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of chown in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - chown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of chown in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83812-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_chown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for chown for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - chown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of chown in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - chown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of chown in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83812-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_chown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchmod": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchmod",
			"title": "Record Events that Modify the System's Discretionary Access Controls - fchmod",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83832-6"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000126",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.5.5",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000064-GPOS-00033",
				"SRG-OS-000466-GPOS-00210",
				"SRG-OS-000458-GPOS-00203",
				"SRG-OS-000458-VMM-001810",
				"SRG-OS-000474-VMM-001940"
			],
			"description": "At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured to\nuse the <code>augenrules</code> program to read audit rules during daemon startup\n(the default), add the following line to a file with suffix <code>.rules</code> in\nthe directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S fchmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fchmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S fchmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fchmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>",
			"rationale": "The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.",
			"warnings": [
				{
					"text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
					"category": "general"
				}
			],
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_dac_modification_fchmod:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_dac_modification_fchmod",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"fchmod\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"chmod fchmod fchmodat\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_dac_modification_fchmod",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83832-6\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_fchmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit fchmod tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83832-6\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_fchmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fchmod for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchmod\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of fchmod in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchmod\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of fchmod in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83832-6\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_fchmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fchmod for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchmod\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of fchmod in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchmod\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of fchmod in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83832-6\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_fchmod\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchmodat": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchmodat",
			"title": "Record Events that Modify the System's Discretionary Access Controls - fchmodat",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83822-7"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000126",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.5.5",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000064-GPOS-00033",
				"SRG-OS-000466-GPOS-00210",
				"SRG-OS-000458-GPOS-00203",
				"SRG-OS-000458-VMM-001810",
				"SRG-OS-000474-VMM-001940"
			],
			"description": "At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured to\nuse the <code>augenrules</code> program to read audit rules during daemon startup\n(the default), add the following line to a file with suffix <code>.rules</code> in\nthe directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S fchmodat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fchmodat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S fchmodat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fchmodat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>",
			"rationale": "The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.",
			"warnings": [
				{
					"text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
					"category": "general"
				}
			],
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_dac_modification_fchmodat:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_dac_modification_fchmodat",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"fchmodat\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"chmod fchmod fchmodat\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_dac_modification_fchmodat",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83822-7\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_fchmodat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit fchmodat tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83822-7\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_fchmodat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fchmodat for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchmodat\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of fchmodat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchmodat\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of fchmodat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83822-7\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_fchmodat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fchmodat for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchmodat\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of fchmodat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchmodat\n      syscall_grouping:\n      - chmod\n      - fchmod\n      - fchmodat\n\n  - name: Check existence of fchmodat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83822-7\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_fchmodat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchown": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchown",
			"title": "Record Events that Modify the System's Discretionary Access Controls - fchown",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83829-2"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000126",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.5.5",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000064-GPOS-00033",
				"SRG-OS-000466-GPOS-00210",
				"SRG-OS-000458-GPOS-00203",
				"SRG-OS-000474-GPOS-00219",
				"SRG-OS-000458-VMM-001810",
				"SRG-OS-000474-VMM-001940"
			],
			"description": "At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S fchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S fchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>",
			"rationale": "The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.",
			"warnings": [
				{
					"text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
					"category": "general"
				}
			],
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_dac_modification_fchown:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_dac_modification_fchown",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"fchown\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"chown fchown fchownat lchown\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_dac_modification_fchown",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83829-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_fchown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit fchown tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83829-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_fchown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fchown for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of fchown in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of fchown in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83829-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_fchown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fchown for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of fchown in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of fchown in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83829-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_fchown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchownat": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchownat",
			"title": "Record Events that Modify the System's Discretionary Access Controls - fchownat",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83831-8"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000126",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.5.5",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000064-GPOS-00033",
				"SRG-OS-000466-GPOS-00210",
				"SRG-OS-000458-GPOS-00203",
				"SRG-OS-000474-GPOS-00219",
				"SRG-OS-000458-VMM-001810",
				"SRG-OS-000474-VMM-001940"
			],
			"description": "At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S fchownat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fchownat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S fchownat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fchownat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>",
			"rationale": "The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.",
			"warnings": [
				{
					"text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
					"category": "general"
				}
			],
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_dac_modification_fchownat:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_dac_modification_fchownat",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"fchownat\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"chown fchown fchownat lchown\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_dac_modification_fchownat",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83831-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_fchownat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit fchownat tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83831-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_fchownat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fchownat for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchownat\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of fchownat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchownat\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of fchownat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83831-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_fchownat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fchownat for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchownat\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of fchownat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fchownat\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of fchownat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83831-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_fchownat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fremovexattr": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fremovexattr",
			"title": "Record Events that Modify the System's Discretionary Access Controls - fremovexattr",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83821-9"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.5.5",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000458-GPOS-00203",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000463-GPOS-00207",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000474-GPOS-00219",
				"SRG-OS-000466-GPOS-00210",
				"SRG-OS-000468-GPOS-00212",
				"SRG-OS-000064-GPOS-00033",
				"SRG-OS-000458-VMM-001810",
				"SRG-OS-000474-VMM-001940"
			],
			"description": "At a minimum, the audit system should collect file permission\nchanges for all users and root.\n<br><br>\nIf the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S fremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n<pre>-a always,exit -F arch=b32 -S fremovexattr -F auid=0 -F key=perm_mod</pre>\n<br><br>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n<pre>-a always,exit -F arch=b64 -S fremovexattr -F auid=0 -F key=perm_mod</pre>\n<br><br>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S fremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n<pre>-a always,exit -F arch=b32 -S fremovexattr -F auid=0 -F key=perm_mod</pre>\n<br><br>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n<pre>-a always,exit -F arch=b64 -S fremovexattr -F auid=0 -F key=perm_mod</pre>",
			"rationale": "The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.",
			"warnings": [
				{
					"text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
					"category": "general"
				}
			],
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_dac_modification_fremovexattr:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_dac_modification_fremovexattr",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"fremovexattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\n\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid=0\"\n\tSYSCALL=\"fremovexattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_dac_modification_fremovexattr",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83821-9\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_fremovexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit fremovexattr tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83821-9\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_fremovexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fremovexattr for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fremovexattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fremovexattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fremovexattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fremovexattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83821-9\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_fremovexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fremovexattr for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fremovexattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fremovexattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fremovexattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fremovexattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83821-9\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_fremovexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fsetxattr": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fsetxattr",
			"title": "Record Events that Modify the System's Discretionary Access Controls - fsetxattr",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83817-7"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000126",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.5.5",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000458-GPOS-00203",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000463-GPOS-00207",
				"SRG-OS-000466-GPOS-00210",
				"SRG-OS-000468-GPOS-00212",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000474-GPOS-00219",
				"SRG-OS-000064-GPOS-00033",
				"SRG-OS-000458-VMM-001810",
				"SRG-OS-000474-VMM-001940"
			],
			"description": "At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S fsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n<pre>-a always,exit -F arch=b32 -S fsetxattr -F auid=0 -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n<pre>-a always,exit -F arch=b64 -S fsetxattr -F auid=0 -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S fsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n<pre>-a always,exit -F arch=b32 -S fsetxattr -F auid=0 -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S fsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n<pre>-a always,exit -F arch=b64 -S fsetxattr -F auid=0 -F key=perm_mod</pre>",
			"rationale": "The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.",
			"warnings": [
				{
					"text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
					"category": "general"
				}
			],
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_dac_modification_fsetxattr:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_dac_modification_fsetxattr",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"fsetxattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\n\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid=0\"\n\tSYSCALL=\"fsetxattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_dac_modification_fsetxattr",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83817-7\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_fsetxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit fsetxattr tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83817-7\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_fsetxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fsetxattr for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fsetxattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fsetxattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fsetxattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fsetxattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83817-7\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_fsetxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for fsetxattr for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fsetxattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fsetxattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fsetxattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - fsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of fsetxattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83817-7\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_fsetxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lchown": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lchown",
			"title": "Record Events that Modify the System's Discretionary Access Controls - lchown",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83833-4"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000126",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.5.5",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000064-GPOS-00033",
				"SRG-OS-000466-GPOS-00210",
				"SRG-OS-000458-GPOS-00203",
				"SRG-OS-000474-GPOS-00219",
				"SRG-OS-000458-VMM-001810",
				"SRG-OS-000474-VMM-001940"
			],
			"description": "At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S lchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S lchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S lchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S lchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>",
			"rationale": "The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.",
			"warnings": [
				{
					"text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
					"category": "general"
				}
			],
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_dac_modification_lchown:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_dac_modification_lchown",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"lchown\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"chown fchown fchownat lchown\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_dac_modification_lchown",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83833-4\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_lchown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit lchown tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83833-4\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_lchown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for lchown for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lchown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of lchown in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lchown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of lchown in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83833-4\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_lchown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for lchown for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lchown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of lchown in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lchown\n      syscall_grouping:\n      - chown\n      - fchown\n      - fchownat\n      - lchown\n\n  - name: Check existence of lchown in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83833-4\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_lchown\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lremovexattr": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lremovexattr",
			"title": "Record Events that Modify the System's Discretionary Access Controls - lremovexattr",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83814-4"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.5.5",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000458-GPOS-00203",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000463-GPOS-00207",
				"SRG-OS-000468-GPOS-00212",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000474-GPOS-00219",
				"SRG-OS-000466-GPOS-00210",
				"SRG-OS-000064-GPOS-00033",
				"SRG-OS-000458-VMM-001810",
				"SRG-OS-000474-VMM-001940"
			],
			"description": "At a minimum, the audit system should collect file permission\nchanges for all users and root.\n<br><br>\nIf the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S lremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n<pre>-a always,exit -F arch=b32 -S lremovexattr -F auid=0 -F key=perm_mod</pre>\n<br><br>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S lremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n<pre>-a always,exit -F arch=b64 -S lremovexattr -F auid=0 -F key=perm_mod</pre>\n<br><br>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S lremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n<pre>-a always,exit -F arch=b32 -S lremovexattr -F auid=0 -F key=perm_mod</pre>\n<br><br>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S lremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n<pre>-a always,exit -F arch=b64 -S lremovexattr -F auid=0 -F key=perm_mod</pre>",
			"rationale": "The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.",
			"warnings": [
				{
					"text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
					"category": "general"
				}
			],
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_dac_modification_lremovexattr:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_dac_modification_lremovexattr",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"lremovexattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\n\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid=0\"\n\tSYSCALL=\"lremovexattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_dac_modification_lremovexattr",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83814-4\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_lremovexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit lremovexattr tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83814-4\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_lremovexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for lremovexattr for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lremovexattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lremovexattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lremovexattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lremovexattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83814-4\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_lremovexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for lremovexattr for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lremovexattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lremovexattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lremovexattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lremovexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lremovexattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83814-4\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_lremovexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lsetxattr": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lsetxattr",
			"title": "Record Events that Modify the System's Discretionary Access Controls - lsetxattr",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83808-6"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000126",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.5.5",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000458-GPOS-00203",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000463-GPOS-00207",
				"SRG-OS-000466-GPOS-00210",
				"SRG-OS-000468-GPOS-00212",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000474-GPOS-00219",
				"SRG-OS-000064-GPOS-00033",
				"SRG-OS-000458-VMM-001810",
				"SRG-OS-000474-VMM-001940"
			],
			"description": "At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S lsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n<pre>-a always,exit -F arch=b32 -S lsetxattr -F auid=0 -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S lsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n<pre>-a always,exit -F arch=b64 -S lsetxattr -F auid=0 -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S lsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n<pre>-a always,exit -F arch=b32 -S lsetxattr -F auid=0 -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S lsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n<pre>-a always,exit -F arch=b64 -S lsetxattr -F auid=0 -F key=perm_mod</pre>",
			"rationale": "The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.",
			"warnings": [
				{
					"text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
					"category": "general"
				}
			],
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_dac_modification_lsetxattr:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_dac_modification_lsetxattr",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"lsetxattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\n\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid=0\"\n\tSYSCALL=\"lsetxattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_dac_modification_lsetxattr",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83808-6\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_lsetxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit lsetxattr tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83808-6\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_lsetxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for lsetxattr for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lsetxattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lsetxattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lsetxattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lsetxattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83808-6\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_lsetxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for lsetxattr for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lsetxattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lsetxattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lsetxattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - lsetxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of lsetxattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83808-6\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_lsetxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_removexattr": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_removexattr",
			"title": "Record Events that Modify the System's Discretionary Access Controls - removexattr",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83807-8"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.5.5",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000458-GPOS-00203",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000463-GPOS-00207",
				"SRG-OS-000468-GPOS-00212",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000474-GPOS-00219",
				"SRG-OS-000466-GPOS-00210",
				"SRG-OS-000064-GPOS-00033",
				"SRG-OS-000458-VMM-001810",
				"SRG-OS-000474-VMM-001940"
			],
			"description": "At a minimum, the audit system should collect file permission\nchanges for all users and root.\n<br><br>\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add the\nfollowing line to a file with suffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S removexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n<pre>-a always,exit -F arch=b32 -S removexattr -F auid=0 -F key=perm_mod</pre>\n<br><br>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S removexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n<pre>-a always,exit -F arch=b64 -S removexattr -F auid=0 -F key=perm_mod</pre>\n<br><br>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S removexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n<pre>-a always,exit -F arch=b32 -S removexattr -F auid=0 -F key=perm_mod</pre>\n<br><br>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S removexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n<pre>-a always,exit -F arch=b64 -S removexattr -F auid=0 -F key=perm_mod</pre>",
			"rationale": "The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.",
			"warnings": [
				{
					"text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
					"category": "general"
				}
			],
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_dac_modification_removexattr:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_dac_modification_removexattr",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"removexattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\n\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid=0\"\n\tSYSCALL=\"removexattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_dac_modification_removexattr",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83807-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_removexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit removexattr tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83807-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_removexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for removexattr for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - removexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of removexattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - removexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of removexattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - removexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of removexattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - removexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of removexattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83807-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_removexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for removexattr for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - removexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of removexattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - removexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of removexattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - removexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of removexattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - removexattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of removexattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83807-8\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_removexattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_setxattr": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_setxattr",
			"title": "Record Events that Modify the System's Discretionary Access Controls - setxattr",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83811-0"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000126",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.5.5",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000466-GPOS-00210",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000064-GPOS-00033",
				"SRG-OS-000458-GPOS-00203",
				"SRG-OS-000458-VMM-001810",
				"SRG-OS-000474-VMM-001940"
			],
			"description": "At a minimum, the audit system should collect file permission\nchanges for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S setxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n<pre>-a always,exit -F arch=b32 -S setxattr -F auid=0 -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S setxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n<pre>-a always,exit -F arch=b64 -S setxattr -F auid=0 -F key=perm_mod</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S setxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n<pre>-a always,exit -F arch=b32 -S setxattr -F auid=0 -F key=perm_mod</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S setxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>\n<pre>-a always,exit -F arch=b64 -S setxattr -F auid=0 -F key=perm_mod</pre>",
			"rationale": "The changing of file permissions could indicate that a user is attempting to\ngain access to information that would otherwise be disallowed. Auditing DAC modifications\ncan facilitate the identification of patterns of abuse among both authorized and\nunauthorized users.",
			"warnings": [
				{
					"text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
					"category": "general"
				}
			],
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_dac_modification_setxattr:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_dac_modification_setxattr",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"setxattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\n\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid=0\"\n\tSYSCALL=\"setxattr\"\n\tKEY=\"perm_mod\"\n\tSYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"\n\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_dac_modification_setxattr",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83811-0\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_setxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit setxattr tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83811-0\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_setxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for setxattr for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - setxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of setxattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - setxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of setxattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - setxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of setxattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - setxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of setxattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83811-0\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_setxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for setxattr for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - setxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of setxattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - setxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of setxattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - setxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of setxattr in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/perm_mod.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - setxattr\n      syscall_grouping:\n      - fremovexattr\n      - lremovexattr\n      - removexattr\n      - fsetxattr\n      - lsetxattr\n      - setxattr\n\n  - name: Check existence of setxattr in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid=0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid=0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F\n        key=perm_mod\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83811-0\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.5\n  - audit_rules_dac_modification_setxattr\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_rename": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_rename",
			"title": "Ensure auditd Collects File Deletion Events by User - rename",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83754-2"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-000366",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.4",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.1.1",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.MA-2",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.2.7",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000466-GPOS-00210",
				"SRG-OS-000467-GPOS-00211",
				"SRG-OS-000468-GPOS-00212",
				"SRG-OS-000466-VMM-001870",
				"SRG-OS-000468-VMM-001890"
			],
			"description": "At a minimum, the audit system should collect file deletion events\nfor all users and root. If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following line to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>, setting ARCH to either b32 or b64 as\nappropriate for your system:\n<pre>-a always,exit -F arch=ARCH -S rename -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file, setting ARCH to either b32 or b64 as\nappropriate for your system:\n<pre>-a always,exit -F arch=ARCH -S rename -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>",
			"rationale": "Auditing file deletions will create an audit trail for files that are removed\nfrom the system. The audit trail could aid in system troubleshooting, as well as, detecting\nmalicious processes that attempt to delete log files to conceal their presence.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_file_deletion_events_rename:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_file_deletion_events_rename",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"rename\"\n\tKEY=\"delete\"\n\tSYSCALL_GROUPING=\"unlink unlinkat rename renameat rmdir\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_file_deletion_events_rename",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83754-2\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_file_deletion_events_rename\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit rename tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83754-2\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_file_deletion_events_rename\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for rename for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - rename\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of rename in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - rename\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of rename in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83754-2\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_file_deletion_events_rename\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for rename for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - rename\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of rename in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - rename\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of rename in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83754-2\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_file_deletion_events_rename\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_renameat": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_renameat",
			"title": "Ensure auditd Collects File Deletion Events by User - renameat",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83756-7"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-000366",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.4",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.1.1",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.MA-2",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.2.7",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000466-GPOS-00210",
				"SRG-OS-000467-GPOS-00211",
				"SRG-OS-000468-GPOS-00212",
				"SRG-OS-000466-VMM-001870",
				"SRG-OS-000468-VMM-001890"
			],
			"description": "At a minimum, the audit system should collect file deletion events\nfor all users and root. If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following line to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>, setting ARCH to either b32 or b64 as\nappropriate for your system:\n<pre>-a always,exit -F arch=ARCH -S renameat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file, setting ARCH to either b32 or b64 as\nappropriate for your system:\n<pre>-a always,exit -F arch=ARCH -S renameat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>",
			"rationale": "Auditing file deletions will create an audit trail for files that are removed\nfrom the system. The audit trail could aid in system troubleshooting, as well as, detecting\nmalicious processes that attempt to delete log files to conceal their presence.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_file_deletion_events_renameat:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_file_deletion_events_renameat",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"renameat\"\n\tKEY=\"delete\"\n\tSYSCALL_GROUPING=\"unlink unlinkat rename renameat rmdir\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_file_deletion_events_renameat",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83756-7\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_file_deletion_events_renameat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit renameat tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83756-7\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_file_deletion_events_renameat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for renameat for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - renameat\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of renameat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - renameat\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of renameat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83756-7\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_file_deletion_events_renameat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for renameat for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - renameat\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of renameat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - renameat\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of renameat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83756-7\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_file_deletion_events_renameat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_rmdir": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_rmdir",
			"title": "Ensure auditd Collects File Deletion Events by User - rmdir",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83758-3"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-000366",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.4",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.1.1",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.MA-2",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.2.7",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000466-GPOS-00210",
				"SRG-OS-000467-GPOS-00211",
				"SRG-OS-000468-GPOS-00212",
				"SRG-OS-000466-VMM-001870",
				"SRG-OS-000468-VMM-001890"
			],
			"description": "At a minimum, the audit system should collect file deletion events\nfor all users and root. If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following line to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>, setting ARCH to either b32 or b64 as\nappropriate for your system:\n<pre>-a always,exit -F arch=ARCH -S rmdir -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file, setting ARCH to either b32 or b64 as\nappropriate for your system:\n<pre>-a always,exit -F arch=ARCH -S rmdir -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>",
			"rationale": "Auditing file deletions will create an audit trail for files that are removed\nfrom the system. The audit trail could aid in system troubleshooting, as well as, detecting\nmalicious processes that attempt to delete log files to conceal their presence.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_file_deletion_events_rmdir:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_file_deletion_events_rmdir",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"rmdir\"\n\tKEY=\"delete\"\n\tSYSCALL_GROUPING=\"unlink unlinkat rename renameat rmdir\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_file_deletion_events_rmdir",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83758-3\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_file_deletion_events_rmdir\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit rmdir tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83758-3\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_file_deletion_events_rmdir\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for rmdir for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - rmdir\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of rmdir in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - rmdir\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of rmdir in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83758-3\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_file_deletion_events_rmdir\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for rmdir for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - rmdir\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of rmdir in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - rmdir\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of rmdir in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83758-3\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_file_deletion_events_rmdir\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_unlink": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_unlink",
			"title": "Ensure auditd Collects File Deletion Events by User - unlink",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83757-5"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-000366",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.4",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.1.1",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.MA-2",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.2.7",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000466-GPOS-00210",
				"SRG-OS-000467-GPOS-00211",
				"SRG-OS-000468-GPOS-00212",
				"SRG-OS-000466-VMM-001870",
				"SRG-OS-000468-VMM-001890"
			],
			"description": "At a minimum, the audit system should collect file deletion events\nfor all users and root. If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following line to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>, setting ARCH to either b32 or b64 as\nappropriate for your system:\n<pre>-a always,exit -F arch=ARCH -S unlink -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file, setting ARCH to either b32 or b64 as\nappropriate for your system:\n<pre>-a always,exit -F arch=ARCH -S unlink -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>",
			"rationale": "Auditing file deletions will create an audit trail for files that are removed\nfrom the system. The audit trail could aid in system troubleshooting, as well as, detecting\nmalicious processes that attempt to delete log files to conceal their presence.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_file_deletion_events_unlink:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_file_deletion_events_unlink",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"unlink\"\n\tKEY=\"delete\"\n\tSYSCALL_GROUPING=\"unlink unlinkat rename renameat rmdir\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_file_deletion_events_unlink",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83757-5\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_file_deletion_events_unlink\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit unlink tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83757-5\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_file_deletion_events_unlink\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for unlink for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - unlink\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of unlink in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - unlink\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of unlink in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83757-5\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_file_deletion_events_unlink\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for unlink for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - unlink\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of unlink in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - unlink\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of unlink in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83757-5\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_file_deletion_events_unlink\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_unlinkat": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_unlinkat",
			"title": "Ensure auditd Collects File Deletion Events by User - unlinkat",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83755-9"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-000366",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.4",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.1.1",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.MA-2",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.2.7",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000466-GPOS-00210",
				"SRG-OS-000467-GPOS-00211",
				"SRG-OS-000468-GPOS-00212",
				"SRG-OS-000466-VMM-001870",
				"SRG-OS-000468-VMM-001890"
			],
			"description": "At a minimum, the audit system should collect file deletion events\nfor all users and root. If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following line to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>, setting ARCH to either b32 or b64 as\nappropriate for your system:\n<pre>-a always,exit -F arch=ARCH -S unlinkat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file, setting ARCH to either b32 or b64 as\nappropriate for your system:\n<pre>-a always,exit -F arch=ARCH -S unlinkat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>",
			"rationale": "Auditing file deletions will create an audit trail for files that are removed\nfrom the system. The audit trail could aid in system troubleshooting, as well as, detecting\nmalicious processes that attempt to delete log files to conceal their presence.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_file_deletion_events_unlinkat:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_file_deletion_events_unlinkat",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\tAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\n\tSYSCALL=\"unlinkat\"\n\tKEY=\"delete\"\n\tSYSCALL_GROUPING=\"unlink unlinkat rename renameat rmdir\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_file_deletion_events_unlinkat",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83755-9\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_file_deletion_events_unlinkat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit unlinkat tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83755-9\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_file_deletion_events_unlinkat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for unlinkat for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - unlinkat\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of unlinkat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - unlinkat\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of unlinkat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83755-9\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_file_deletion_events_unlinkat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for unlinkat for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - unlinkat\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of unlinkat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/delete.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k\n        |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - unlinkat\n      syscall_grouping:\n      - unlink\n      - unlinkat\n      - rename\n      - renameat\n      - rmdir\n\n  - name: Check existence of unlinkat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F\n        key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000\n        -F auid!=unset -F key=delete\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83755-9\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_file_deletion_events_unlinkat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_creat": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_creat",
			"title": "Record Unsuccessful Access Attempts to Files - creat",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83786-4"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.2.4",
				"Req-10.2.1",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000064-GPOS-00033",
				"SRG-OS-000458-GPOS-00203",
				"SRG-OS-000461-GPOS-00205",
				"SRG-OS-000458-VMM-001810",
				"SRG-OS-000461-VMM-001830"
			],
			"description": "At a minimum, the audit system should collect unauthorized file\naccesses for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following lines to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>",
			"rationale": "Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing\nthese events could serve as evidence of potential system compromise.",
			"warnings": [
				{
					"text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
					"category": "general"
				}
			],
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_unsuccessful_file_modification_creat:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_unsuccessful_file_modification_creat",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"creat\"\nKEY=\"access\"\nSYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\"\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EACCES\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EPERM\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_unsuccessful_file_modification_creat",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83786-4\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_creat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit creat tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83786-4\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_creat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for creat EACCES for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - creat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of creat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - creat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of creat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83786-4\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_creat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for creat EACCES for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - creat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of creat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - creat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of creat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83786-4\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_creat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for creat EPERM for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - creat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of creat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - creat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of creat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83786-4\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_creat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for creat EPERM for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - creat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of creat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - creat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of creat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83786-4\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_creat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_ftruncate": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_ftruncate",
			"title": "Record Unsuccessful Access Attempts to Files - ftruncate",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83800-3"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.2.4",
				"Req-10.2.1",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000064-GPOS-00033",
				"SRG-OS-000458-GPOS-00203",
				"SRG-OS-000461-GPOS-00205",
				"SRG-OS-000458-VMM-001810",
				"SRG-OS-000461-VMM-001830"
			],
			"description": "At a minimum, the audit system should collect unauthorized file\naccesses for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following lines to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>",
			"rationale": "Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing\nthese events could serve as evidence of potential system compromise.",
			"warnings": [
				{
					"text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
					"category": "general"
				}
			],
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_unsuccessful_file_modification_ftruncate:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_unsuccessful_file_modification_ftruncate",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"ftruncate\"\nKEY=\"access\"\nSYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\"\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EACCES\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EPERM\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_unsuccessful_file_modification_ftruncate",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83800-3\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_ftruncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit ftruncate tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83800-3\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_ftruncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for ftruncate EACCES for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - ftruncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of ftruncate in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - ftruncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of ftruncate in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83800-3\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_ftruncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for ftruncate EACCES for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - ftruncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of ftruncate in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - ftruncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of ftruncate in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83800-3\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_ftruncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for ftruncate EPERM for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - ftruncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of ftruncate in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - ftruncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of ftruncate in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83800-3\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_ftruncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for ftruncate EPERM for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - ftruncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of ftruncate in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - ftruncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of ftruncate in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83800-3\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_ftruncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_open": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_open",
			"title": "Record Unsuccessful Access Attempts to Files - open",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83801-1"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.2.4",
				"Req-10.2.1",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000064-GPOS-00033",
				"SRG-OS-000458-GPOS-00203",
				"SRG-OS-000461-GPOS-00205",
				"SRG-OS-000458-VMM-001810",
				"SRG-OS-000461-VMM-001830"
			],
			"description": "At a minimum, the audit system should collect unauthorized file\naccesses for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following lines to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S open -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S open -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S open -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S open -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S open -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S open -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S open -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S open -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>",
			"rationale": "Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing\nthese events could serve as evidence of potential system compromise.",
			"warnings": [
				{
					"text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
					"category": "general"
				}
			],
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_unsuccessful_file_modification_open:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_unsuccessful_file_modification_open",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"open\"\nKEY=\"access\"\nSYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\"\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EACCES\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EPERM\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_unsuccessful_file_modification_open",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83801-1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit open tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83801-1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for open EACCES for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83801-1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for open EACCES for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83801-1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for open EPERM for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83801-1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for open EPERM for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83801-1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_open_by_handle_at": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_open_by_handle_at",
			"title": "Record Unsuccessful Access Attempts to Files - open_by_handle_at",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83796-3"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.2.4",
				"Req-10.2.1",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000064-GPOS-00033",
				"SRG-OS-000458-GPOS-00203",
				"SRG-OS-000461-GPOS-00205",
				"SRG-OS-000458-VMM-001810",
				"SRG-OS-000461-VMM-001830"
			],
			"description": "At a minimum, the audit system should collect unauthorized file\naccesses for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following lines to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S open_by_handle_at -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S open_by_handle_at -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S open_by_handle_at -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S open_by_handle_at -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S open_by_handle_at,truncate,ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S open_by_handle_at,truncate,ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S open_by_handle_at,truncate,ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S open_by_handle_at,truncate,ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>",
			"rationale": "Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing\nthese events could serve as evidence of potential system compromise.",
			"warnings": [
				{
					"text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
					"category": "general"
				}
			],
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_unsuccessful_file_modification_open_by_handle_at:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_unsuccessful_file_modification_open_by_handle_at",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"open_by_handle_at\"\nKEY=\"access\"\nSYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\"\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EACCES\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EPERM\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_unsuccessful_file_modification_open_by_handle_at",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83796-3\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open_by_handle_at\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit open_by_handle_at tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83796-3\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open_by_handle_at\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for open_by_handle_at EACCES for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open_by_handle_at\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open_by_handle_at in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open_by_handle_at\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open_by_handle_at in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83796-3\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open_by_handle_at\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for open_by_handle_at EACCES for x86_64\n    platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open_by_handle_at\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open_by_handle_at in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open_by_handle_at\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open_by_handle_at in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83796-3\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open_by_handle_at\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for open_by_handle_at EPERM for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open_by_handle_at\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open_by_handle_at in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open_by_handle_at\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open_by_handle_at in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83796-3\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open_by_handle_at\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for open_by_handle_at EPERM for x86_64\n    platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open_by_handle_at\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open_by_handle_at in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - open_by_handle_at\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of open_by_handle_at in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83796-3\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_open_by_handle_at\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_openat": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_openat",
			"title": "Record Unsuccessful Access Attempts to Files - openat",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83794-8"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.2.4",
				"Req-10.2.1",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000064-GPOS-00033",
				"SRG-OS-000458-GPOS-00203",
				"SRG-OS-000461-GPOS-00205",
				"SRG-OS-000458-VMM-001810",
				"SRG-OS-000461-VMM-001830"
			],
			"description": "At a minimum, the audit system should collect unauthorized file\naccesses for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following lines to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S openat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S openat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S openat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S openat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S openat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S openat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S openat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S openat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>",
			"rationale": "Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing\nthese events could serve as evidence of potential system compromise.",
			"warnings": [
				{
					"text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
					"category": "general"
				}
			],
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_unsuccessful_file_modification_openat:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_unsuccessful_file_modification_openat",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"openat\"\nKEY=\"access\"\nSYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\"\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EACCES\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EPERM\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_unsuccessful_file_modification_openat",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83794-8\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_openat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit openat tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83794-8\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_openat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for openat EACCES for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - openat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of openat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - openat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of openat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83794-8\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_openat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for openat EACCES for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - openat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of openat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - openat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of openat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83794-8\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_openat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for openat EPERM for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - openat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of openat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - openat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of openat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83794-8\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_openat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for openat EPERM for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - openat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of openat in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - openat\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of openat in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83794-8\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_openat\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_truncate": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_truncate",
			"title": "Record Unsuccessful Access Attempts to Files - truncate",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83792-2"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.2.4",
				"Req-10.2.1",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000064-GPOS-00033",
				"SRG-OS-000458-GPOS-00203",
				"SRG-OS-000461-GPOS-00205",
				"SRG-OS-000458-VMM-001810",
				"SRG-OS-000461-VMM-001830"
			],
			"description": "At a minimum, the audit system should collect unauthorized file\naccesses for all users and root. If the <code>auditd</code> daemon is configured\nto use the <code>augenrules</code> program to read audit rules during daemon\nstartup (the default), add the following lines to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S truncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S truncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S truncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S truncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S truncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b32 -S truncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>\n\nIf the system is 64 bit then also add the following lines:\n<pre>\n-a always,exit -F arch=b64 -S truncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access\n-a always,exit -F arch=b64 -S truncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>",
			"rationale": "Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing\nthese events could serve as evidence of potential system compromise.",
			"warnings": [
				{
					"text": "Note that these rules can be configured in a\nnumber of ways while still achieving the desired effect. Here the system calls\nhave been placed independent of other system calls. Grouping these system\ncalls with others as identifying earlier in this guide is more efficient.",
					"category": "general"
				}
			],
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_unsuccessful_file_modification_truncate:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_unsuccessful_file_modification_truncate",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nAUID_FILTERS=\"-F auid>=1000 -F auid!=unset\"\nSYSCALL=\"truncate\"\nKEY=\"access\"\nSYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\"\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EACCES\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F exit=-EPERM\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_unsuccessful_file_modification_truncate",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83792-2\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_truncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Set architecture for audit truncate tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83792-2\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_truncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for truncate EACCES for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - truncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of truncate in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - truncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of truncate in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83792-2\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_truncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for truncate EACCES for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - truncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of truncate in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - truncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of truncate in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83792-2\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_truncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for truncate EPERM for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - truncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of truncate in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - truncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of truncate in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83792-2\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_truncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for truncate EPERM for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - truncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of truncate in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/access.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - truncate\n      syscall_grouping:\n      - creat\n      - ftruncate\n      - truncate\n      - open\n      - openat\n      - open_by_handle_at\n\n  - name: Check existence of truncate in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset\n        (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM\n        -F auid>=1000 -F auid!=unset -F key=access\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83792-2\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.1\n  - PCI-DSS-Req-10.2.4\n  - audit_rules_unsuccessful_file_modification_truncate\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - reboot_required\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_delete": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_delete",
			"title": "Ensure auditd Collects Information on Kernel Module Unloading - delete_module",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83802-9"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"AC-6(9)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.2.7",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000471-GPOS-00216",
				"SRG-OS-000477-GPOS-00222",
				"SRG-OS-000477-VMM-001970"
			],
			"description": "To capture kernel module unloading events, use following line, setting ARCH to\neither b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit:\n\n<pre>-a always,exit -F arch=<i>ARCH</i> -S delete_module -F key=modules</pre>\n\n\nPlace to add the line depends on a way <code>auditd</code> daemon is configured. If it is configured\nto use the <code>augenrules</code> program (the default), add the line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>.\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code> utility,\nadd the line to file <code>/etc/audit/audit.rules</code>.",
			"rationale": "The removal of kernel modules can be used to alter the behavior of\nthe kernel and potentially introduce malicious code into kernel space. It is important\nto have an audit trail of modules that have been introduced into the kernel.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_kernel_module_loading_delete:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_kernel_module_loading_delete",
					"system": "urn:xccdf:fix:script:kubernetes",
					"fix": "---\napiVersion: machineconfiguration.openshift.io/v1\nkind: MachineConfig\nspec:\n  config:\n    ignition:\n      version: 3.1.0\n    storage:\n      files:\n      - contents:\n          source: data:,-a%20always%2Cexit%20-F%20arch%3Db32%20-S%20delete_module%20-k%20module-change%0A-a%20always%2Cexit%20-F%20arch%3Db64%20-S%20delete_module%20-k%20module-change%0A\n        mode: 0600\n        path: /etc/audit/rules.d/75-kernel-module-loading-delete.rules\n        overwrite: true\n"
				},
				{
					"remediation_id": "audit_rules_kernel_module_loading_delete",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n# Note: 32-bit and 64-bit kernel syscall numbers not always line up =>\n#       it's required on a 64-bit system to check also for the presence\n#       of 32-bit's equivalent of the corresponding rule.\n#       (See `man 7 audit.rules` for details )\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\t\n\tAUID_FILTERS=\"\"\n\t\n\tSYSCALL=\"delete_module\"\n\tKEY=\"modules\"\n\tSYSCALL_GROUPING=\"delete_module\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_kernel_module_loading_delete",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83802-9\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_delete\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set architecture for audit delete_module tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83802-9\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_delete\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Perform remediation of Audit rules for delete_module for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - delete_module\n      syscall_grouping: []\n\n  - name: Check existence of delete_module in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/module-change.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=module-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - delete_module\n      syscall_grouping: []\n\n  - name: Check existence of delete_module in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=module-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83802-9\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_delete\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Perform remediation of Audit rules for delete_module for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - delete_module\n      syscall_grouping: []\n\n  - name: Check existence of delete_module in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/module-change.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=module-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - delete_module\n      syscall_grouping: []\n\n  - name: Check existence of delete_module in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=module-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83802-9\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_delete\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_finit": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_finit",
			"title": "Ensure auditd Collects Information on Kernel Module Loading and Unloading - finit_module",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83803-7"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"AC-6(9)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.2.7",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000471-GPOS-00216",
				"SRG-OS-000477-GPOS-00222",
				"SRG-OS-000477-VMM-001970"
			],
			"description": "If the <code>auditd</code> daemon is configured to use the <code>augenrules</code> program\nto read audit rules during daemon startup (the default), add the following lines to a file\nwith suffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code> to capture kernel module\nloading and unloading events, setting ARCH to either b32 or b64 as appropriate for your system:\n\n<pre>-a always,exit -F arch=<i>ARCH</i> -S finit_module -F key=modules</pre>\n    If the <code>auditd</code> daemon is configured to use the <code>auditctl</code> utility to read audit\nrules during daemon startup, add the following lines to <code>/etc/audit/audit.rules</code> file\nin order to capture kernel module loading and unloading events, setting ARCH to either b32 or\nb64 as appropriate for your system:\n\n<pre>-a always,exit -F arch=<i>ARCH</i> -S finit_module -F key=modules</pre>",
			"rationale": "The addition/removal of kernel modules can be used to alter the behavior of\nthe kernel and potentially introduce malicious code into kernel space. It is important\nto have an audit trail of modules that have been introduced into the kernel.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_kernel_module_loading_finit:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_kernel_module_loading_finit",
					"system": "urn:xccdf:fix:script:kubernetes",
					"fix": "---\napiVersion: machineconfiguration.openshift.io/v1\nkind: MachineConfig\nspec:\n  config:\n    ignition:\n      version: 3.1.0\n    storage:\n      files:\n      - contents:\n          source: data:,-a%20always%2Cexit%20-F%20arch%3Db32%20-S%20finit_module%20-k%20module-change%0A-a%20always%2Cexit%20-F%20arch%3Db64%20-S%20finit_module%20-k%20module-change%0A\n        mode: 0600\n        path: /etc/audit/rules.d/75-kernel-module-loading-finit.rules\n        overwrite: true\n"
				},
				{
					"remediation_id": "audit_rules_kernel_module_loading_finit",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n# Note: 32-bit and 64-bit kernel syscall numbers not always line up =>\n#       it's required on a 64-bit system to check also for the presence\n#       of 32-bit's equivalent of the corresponding rule.\n#       (See `man 7 audit.rules` for details )\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\t\n\tAUID_FILTERS=\"\"\n\t\n\tSYSCALL=\"finit_module\"\n\tKEY=\"modules\"\n\tSYSCALL_GROUPING=\"init_module finit_module\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_kernel_module_loading_finit",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83803-7\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_finit\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set architecture for audit finit_module tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83803-7\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_finit\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Perform remediation of Audit rules for finit_module for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - finit_module\n      syscall_grouping:\n      - init_module\n      - finit_module\n\n  - name: Check existence of finit_module in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/module-change.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=module-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - finit_module\n      syscall_grouping:\n      - init_module\n      - finit_module\n\n  - name: Check existence of finit_module in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=module-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83803-7\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_finit\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Perform remediation of Audit rules for finit_module for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - finit_module\n      syscall_grouping:\n      - init_module\n      - finit_module\n\n  - name: Check existence of finit_module in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/module-change.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=module-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - finit_module\n      syscall_grouping:\n      - init_module\n      - finit_module\n\n  - name: Check existence of finit_module in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=module-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83803-7\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_finit\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_init": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_init",
			"title": "Ensure auditd Collects Information on Kernel Module Loading - init_module",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-90835-0"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000130",
				"CCI-000135",
				"CCI-000169",
				"CCI-000172",
				"CCI-002884",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"AC-6(9)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.2.7",
				"SRG-OS-000037-GPOS-00015",
				"SRG-OS-000042-GPOS-00020",
				"SRG-OS-000062-GPOS-00031",
				"SRG-OS-000392-GPOS-00172",
				"SRG-OS-000462-GPOS-00206",
				"SRG-OS-000471-GPOS-00215",
				"SRG-OS-000471-GPOS-00216",
				"SRG-OS-000477-GPOS-00222",
				"SRG-OS-000477-VMM-001970"
			],
			"description": "To capture kernel module loading events, use following line, setting ARCH to\neither b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit:\n\n<pre>-a always,exit -F arch=<i>ARCH</i> -S init_module -F key=modules</pre>\n\n\nPlace to add the line depends on a way <code>auditd</code> daemon is configured. If it is configured\nto use the <code>augenrules</code> program (the default), add the line to a file with suffix\n<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>.\n\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code> utility,\nadd the line to file <code>/etc/audit/audit.rules</code>.",
			"rationale": "The addition of kernel modules can be used to alter the behavior of\nthe kernel and potentially introduce malicious code into kernel space. It is important\nto have an audit trail of modules that have been introduced into the kernel.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_kernel_module_loading_init:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_kernel_module_loading_init",
					"system": "urn:xccdf:fix:script:kubernetes",
					"fix": "---\napiVersion: machineconfiguration.openshift.io/v1\nkind: MachineConfig\nspec:\n  config:\n    ignition:\n      version: 3.1.0\n    storage:\n      files:\n      - contents:\n          source: data:,-a%20always%2Cexit%20-F%20arch%3Db32%20-S%20init_module%20-k%20module-change%0A-a%20always%2Cexit%20-F%20arch%3Db64%20-S%20init_module%20-k%20module-change%0A\n        mode: 0600\n        path: /etc/audit/rules.d/75-kernel-module-loading-init.rules\n        overwrite: true\n"
				},
				{
					"remediation_id": "audit_rules_kernel_module_loading_init",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n# Note: 32-bit and 64-bit kernel syscall numbers not always line up =>\n#       it's required on a 64-bit system to check also for the presence\n#       of 32-bit's equivalent of the corresponding rule.\n#       (See `man 7 audit.rules` for details )\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"\"\n\t\n\tAUID_FILTERS=\"\"\n\t\n\tSYSCALL=\"init_module\"\n\tKEY=\"modules\"\n\tSYSCALL_GROUPING=\"init_module finit_module\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_kernel_module_loading_init",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-90835-0\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_init\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Set architecture for audit init_module tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-90835-0\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_init\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Perform remediation of Audit rules for init_module for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - init_module\n      syscall_grouping:\n      - init_module\n      - finit_module\n\n  - name: Check existence of init_module in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/module-change.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=module-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - init_module\n      syscall_grouping:\n      - init_module\n      - finit_module\n\n  - name: Check existence of init_module in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=module-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-90835-0\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_init\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Perform remediation of Audit rules for init_module for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - init_module\n      syscall_grouping:\n      - init_module\n      - finit_module\n\n  - name: Check existence of init_module in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/module-change.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=module-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - init_module\n      syscall_grouping:\n      - init_module\n      - finit_module\n\n  - name: Check existence of init_module in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=module-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-90835-0\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.7\n  - audit_rules_kernel_module_loading_init\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_login_events": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_login_events",
			"title": "Record Attempts to Alter Logon and Logout Events",
			"result": "fail",
			"time": "2022-10-26T09:46:09+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83784-9"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-000172",
				"CCI-002884",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"AC-6(9)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"Req-10.2.3"
			],
			"description": "The audit system already collects login information for all users\nand root. If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following lines to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code> in order to watch for attempted manual\nedits of files involved in storing logon events:\n<pre>-w /var/log/tallylog -p wa -k logins\n-w /var/log/faillock -p wa -k logins\n-w /var/log/lastlog -p wa -k logins</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following lines to\n<code>/etc/audit/audit.rules</code> file in order to watch for unattempted manual\nedits of files involved in storing logon events:\n<pre>-w /var/log/tallylog -p wa -k logins\n-w /var/log/faillock -p wa -k logins\n-w /var/log/lastlog -p wa -k logins</pre>",
			"rationale": "Manual editing of these files may indicate nefarious activity, such\nas an attacker attempting to remove evidence of an intrusion.",
			"warnings": [
				{
					"text": "This rule checks for multiple syscalls related to login events;\nit was written with DISA STIG in mind. Other policies should use a\nseparate rule for each syscall that needs to be checked. For example:\n<ul><li><code>audit_rules_login_events_tallylog</code></li><li><code>audit_rules_login_events_faillock</code></li><li><code>audit_rules_login_events_lastlog</code></li></ul>",
					"category": "general"
				}
			],
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_login_events:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_login_events",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\n\n\n\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/tallylog\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/tallylog $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/tallylog$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /var/log/tallylog -p wa -k logins\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/logins.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/var/log/tallylog\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/logins.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/logins.rules\"\n    # If the logins.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/tallylog\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/tallylog $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/tallylog$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /var/log/tallylog -p wa -k logins\" >> \"$audit_rules_file\"\n    fi\ndone\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/faillock\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/faillock $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/faillock$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /var/log/faillock -p wa -k logins\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/logins.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/var/log/faillock\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/logins.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/logins.rules\"\n    # If the logins.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/faillock\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/faillock $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/faillock$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /var/log/faillock -p wa -k logins\" >> \"$audit_rules_file\"\n    fi\ndone\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/lastlog\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/lastlog $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/lastlog$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /var/log/lastlog -p wa -k logins\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/logins.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/var/log/lastlog\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/logins.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/logins.rules\"\n    # If the logins.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/var/log/lastlog\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/var/log/lastlog $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/var/log/lastlog$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /var/log/lastlog -p wa -k logins\" >> \"$audit_rules_file\"\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands",
			"title": "Ensure auditd Collects Information on the Use of Privileged Commands",
			"result": "fail",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83759-1"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO08.04",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.05",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-002234",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.5",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.3.4.5.9",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 3.9",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"0582",
				"0584",
				"05885",
				"0586",
				"0846",
				"0957",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.1",
				"A.16.1.2",
				"A.16.1.3",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.1.3",
				"A.6.2.1",
				"A.6.2.2",
				"CIP-004-6 R2.2.2",
				"CIP-004-6 R2.2.3",
				"CIP-007-3 R.1.3",
				"CIP-007-3 R5",
				"CIP-007-3 R5.1.1",
				"CIP-007-3 R5.1.3",
				"CIP-007-3 R5.2.1",
				"CIP-007-3 R5.2.3",
				"AC-2(4)",
				"AU-2(d)",
				"AU-12(c)",
				"AC-6(9)",
				"CM-6(a)",
				"DE.AE-2",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"DE.DP-4",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"RS.CO-2",
				"Req-10.2.2",
				"SRG-OS-000327-GPOS-00127",
				"SRG-OS-000471-VMM-001910"
			],
			"description": "The audit system should collect information about usage of privileged\ncommands for all users and root. To find the relevant setuid /\nsetgid programs, run the following command for each local partition\n<i>PART</i>:\n<pre>$ sudo find <i>PART</i> -xdev -type f -perm -4000 -o -type f -perm -2000 2&gt;/dev/null</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>augenrules</code>\nprogram to read audit rules during daemon startup (the default), add a line of\nthe following form to a file with suffix <code>.rules</code> in the directory\n<code>/etc/audit/rules.d</code> for each setuid / setgid program on the system,\nreplacing the <i>SETUID_PROG_PATH</i> part with the full path of that setuid /\nsetgid program in the list:\n<pre>-a always,exit -F path=<i>SETUID_PROG_PATH</i> -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add a line of the following\nform to <code>/etc/audit/audit.rules</code> for each setuid / setgid program on the\nsystem, replacing the <i>SETUID_PROG_PATH</i> part with the full path of that\nsetuid / setgid program in the list:\n<pre>-a always,exit -F path=<i>SETUID_PROG_PATH</i> -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>",
			"rationale": "Misuse of privileged functions, either intentionally or unintentionally by\nauthorized users, or by unauthorized external entities that have compromised system accounts,\nis a serious and ongoing concern and can have significant adverse impacts on organizations.\nAuditing the use of privileged functions is one way to detect such misuse and identify\nthe risk from insider and advanced persistent threats.\n<br><br>\nPrivileged programs are subject to escalation-of-privilege attacks,\nwhich attempt to subvert their normal role of providing some necessary but\nlimited capability. As such, motivation exists to monitor these programs for\nunusual activity.",
			"warnings": [
				{
					"text": "This rule checks for multiple syscalls related to privileged commands;\nit was written with DISA STIG in mind. Other policies should use a\nseparate rule for each syscall that needs to be checked. For example:\n<ul><li><code>audit_rules_privileged_commands_su</code></li><li><code>audit_rules_privileged_commands_umount</code></li><li><code>audit_rules_privileged_commands_passwd</code></li></ul>",
					"category": "general"
				}
			],
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_privileged_commands:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_privileged_commands",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\nfiles_to_inspect=()\n\n# If the audit tool is 'auditctl', then:\n# * add '/etc/audit/audit.rules'to the list of files to be inspected,\n# * specify '/etc/audit/audit.rules' as the output audit file, where\n#   missing rules should be inserted\nfiles_to_inspect=(\"/etc/audit/audit.rules\")\noutput_audit_file=\"/etc/audit/audit.rules\"\n\n# Obtain the list of SUID/SGID binaries on the particular system (split by newline)\n# into privileged_binaries array\nprivileged_binaries=()\nreadarray -t privileged_binaries < <(find / -not \\( -fstype afs -o -fstype ceph -o -fstype cifs -o -fstype smb3 -o -fstype smbfs -o -fstype sshfs -o -fstype ncpfs -o -fstype ncp -o -fstype nfs -o -fstype nfs4 -o -fstype gfs -o -fstype gfs2 -o -fstype glusterfs -o -fstype gpfs -o -fstype pvfs2 -o -fstype ocfs2 -o -fstype lustre -o -fstype davfs -o -fstype fuse.sshfs \\) -type f \\( -perm -4000 -o -perm -2000 \\) 2> /dev/null)\n\n# Keep list of SUID/SGID binaries that have been already handled within some previous iteration\nsbinaries_to_skip=()\n\n# For each found sbinary in privileged_binaries list\nfor sbinary in \"${privileged_binaries[@]}\"\ndo\n\n    # Check if this sbinary wasn't already handled in some of the previous sbinary iterations\n    # Return match only if whole sbinary definition matched (not in the case just prefix matched!!!)\n    if [[ $(sed -ne \"\\|${sbinary}|p\" <<< \"${sbinaries_to_skip[*]}\") ]]\n    then\n        # If so, don't process it second time & go to process next sbinary\n        continue\n    fi\n\n    # Reset the counter of inspected files when starting to check\n    # presence of existing audit rule for new sbinary\n    count_of_inspected_files=0\n\n    # Define expected rule form for this binary\n    expected_rule=\"-a always,exit -F path=${sbinary} -F auid>=1000 -F auid!=unset -F key=privileged\"\n\n    # If list of audit rules files to be inspected is empty, just add new rule and move on to next binary\n    if [[ ${#files_to_inspect[@]} -eq 0 ]]; then\n        echo \"$expected_rule\" >> \"$output_audit_file\"\n        continue\n    fi\n\n    # Replace possible slash '/' character in sbinary definition so we could use it in sed expressions below\n    sbinary_esc=${sbinary//$'/'/$'\\/'}\n\n    # For each audit rules file from the list of files to be inspected\n    for afile in \"${files_to_inspect[@]}\"\n    do\n        # Search current audit rules file's content for match. Match criteria:\n        # * existing rule is for the same SUID/SGID binary we are currently processing (but\n        #   can contain multiple -F path= elements covering multiple SUID/SGID binaries)\n        # * existing rule contains all arguments from expected rule form (though can contain\n        #   them in arbitrary order)\n\n        base_search=$(sed -e '/-a always,exit/!d' -e '/-F path='\"${sbinary_esc}\"'[^[:graph:]]/!d'\t\t\\\n                -e '/-F path=[^[:space:]]\\+/!d'\t\t\t\t\t\t\\\n                -e '/-F auid>='\"1000\"'/!d' -e '/-F auid!=\\(4294967295\\|unset\\)/!d'\t\\\n                -e '/-k \\|-F key=/!d' \"$afile\")\n\n        # Increase the count of inspected files for this sbinary\n        count_of_inspected_files=$((count_of_inspected_files + 1))\n\n        # Search current audit rules file's content for presence of rule pattern for this sbinary\n        if [[ $base_search ]]\n        then\n\n            # Current audit rules file already contains rule for this binary =>\n            # Store the exact form of found rule for this binary for further processing\n            concrete_rule=$base_search\n\n            # Select all other SUID/SGID binaries possibly also present in the found rule\n\n            readarray -t handled_sbinaries < <(grep -o -e \"-F path=[^[:space:]]\\+\" <<< \"$concrete_rule\")\n            handled_sbinaries=(\"${handled_sbinaries[@]//-F path=/}\")\n\n            # Merge the list of such SUID/SGID binaries found in this iteration with global list ignoring duplicates\n            readarray -t sbinaries_to_skip < <(for i in \"${sbinaries_to_skip[@]}\" \"${handled_sbinaries[@]}\"; do echo \"$i\"; done | sort -du)\n\n            # if there is a -F perm flag, remove it\n            if grep -q '.*-F\\s\\+perm=[rwxa]\\+.*' <<< \"$concrete_rule\"; then\n\n                # Separate concrete_rule into three sections using hash '#'\n                # sign as a delimiter around rule's permission section borders\n                # note that the trailing space after perm flag is captured because there would be\n                # two consecutive spaces after joining remaining parts of the rule together\n                concrete_rule=\"$(echo \"$concrete_rule\" | sed -n \"s/\\(.*\\)\\+\\(-F perm=[rwax]\\+\\ \\?\\)\\+/\\1#\\2#/p\")\"\n\n                # Split concrete_rule into head and tail sections using hash '#' delimiter\n                # The second column contains the permission section, which we don't need to extract\n                rule_head=$(cut -d '#' -f 1 <<< \"$concrete_rule\")\n                rule_tail=$(cut -d '#' -f 3 <<< \"$concrete_rule\")\n\n                # Remove permissions section from existing rule in the file\n                sed -i \"s#${rule_head}\\(.*\\)${rule_tail}#${rule_head}${rule_tail}#\" \"$afile\"\n            fi\n        # If the required audit rule for particular sbinary wasn't found yet, insert it under following conditions:\n        #\n        # * in the \"auditctl\" mode of operation insert particular rule each time\n        #   (because in this mode there's only one file -- /etc/audit/audit.rules to be inspected for presence of this rule),\n        #\n        # * in the \"augenrules\" mode of operation insert particular rule only once and only in case we have already\n        #   searched all of the files from /etc/audit/rules.d/*.rules location (since that audit rule can be defined\n        #   in any of those files and if not, we want it to be inserted only once into /etc/audit/rules.d/privileged.rules file)\n        #\n\t\n\telse\n            # Check if this sbinary wasn't already handled in some of the previous afile iterations\n            # Return match only if whole sbinary definition matched (not in the case just prefix matched!!!)\n            if [[ ! $(sed -ne \"\\|${sbinary}|p\" <<< \"${sbinaries_to_skip[*]}\") ]]\n            then\n                # Current audit rules file's content doesn't contain expected rule for this\n                # SUID/SGID binary yet => append it\n                echo \"$expected_rule\" >> \"$output_audit_file\"\n            fi\n            continue\n        fi\n    done\ndone\nfiles_to_inspect=()\n# If the audit tool is 'augenrules', then:\n# * add '/etc/audit/rules.d/*.rules' to the list of files to be inspected\n#   (split by newline),\n# * specify /etc/audit/rules.d/privileged.rules' as the output file, where\n#   missing rules should be inserted\nreadarray -t files_to_inspect < <(find /etc/audit/rules.d -maxdepth 1 -type f -name '*.rules' -print)\noutput_audit_file=\"/etc/audit/rules.d/privileged.rules\"\n\n# Obtain the list of SUID/SGID binaries on the particular system (split by newline)\n# into privileged_binaries array\nprivileged_binaries=()\nreadarray -t privileged_binaries < <(find / -not \\( -fstype afs -o -fstype ceph -o -fstype cifs -o -fstype smb3 -o -fstype smbfs -o -fstype sshfs -o -fstype ncpfs -o -fstype ncp -o -fstype nfs -o -fstype nfs4 -o -fstype gfs -o -fstype gfs2 -o -fstype glusterfs -o -fstype gpfs -o -fstype pvfs2 -o -fstype ocfs2 -o -fstype lustre -o -fstype davfs -o -fstype fuse.sshfs \\) -type f \\( -perm -4000 -o -perm -2000 \\) 2> /dev/null)\n\n# Keep list of SUID/SGID binaries that have been already handled within some previous iteration\nsbinaries_to_skip=()\n\n# For each found sbinary in privileged_binaries list\nfor sbinary in \"${privileged_binaries[@]}\"\ndo\n\n    # Check if this sbinary wasn't already handled in some of the previous sbinary iterations\n    # Return match only if whole sbinary definition matched (not in the case just prefix matched!!!)\n    if [[ $(sed -ne \"\\|${sbinary}|p\" <<< \"${sbinaries_to_skip[*]}\") ]]\n    then\n        # If so, don't process it second time & go to process next sbinary\n        continue\n    fi\n\n    # Reset the counter of inspected files when starting to check\n    # presence of existing audit rule for new sbinary\n    count_of_inspected_files=0\n\n    # Define expected rule form for this binary\n    expected_rule=\"-a always,exit -F path=${sbinary} -F auid>=1000 -F auid!=unset -F key=privileged\"\n\n    # If list of audit rules files to be inspected is empty, just add new rule and move on to next binary\n    if [[ ${#files_to_inspect[@]} -eq 0 ]]; then\n        echo \"$expected_rule\" >> \"$output_audit_file\"\n        continue\n    fi\n\n    # Replace possible slash '/' character in sbinary definition so we could use it in sed expressions below\n    sbinary_esc=${sbinary//$'/'/$'\\/'}\n\n    # For each audit rules file from the list of files to be inspected\n    for afile in \"${files_to_inspect[@]}\"\n    do\n        # Search current audit rules file's content for match. Match criteria:\n        # * existing rule is for the same SUID/SGID binary we are currently processing (but\n        #   can contain multiple -F path= elements covering multiple SUID/SGID binaries)\n        # * existing rule contains all arguments from expected rule form (though can contain\n        #   them in arbitrary order)\n\n        base_search=$(sed -e '/-a always,exit/!d' -e '/-F path='\"${sbinary_esc}\"'[^[:graph:]]/!d'\t\t\\\n                -e '/-F path=[^[:space:]]\\+/!d'\t\t\t\t\t\t\\\n                -e '/-F auid>='\"1000\"'/!d' -e '/-F auid!=\\(4294967295\\|unset\\)/!d'\t\\\n                -e '/-k \\|-F key=/!d' \"$afile\")\n\n        # Increase the count of inspected files for this sbinary\n        count_of_inspected_files=$((count_of_inspected_files + 1))\n\n        # Search current audit rules file's content for presence of rule pattern for this sbinary\n        if [[ $base_search ]]\n        then\n\n            # Current audit rules file already contains rule for this binary =>\n            # Store the exact form of found rule for this binary for further processing\n            concrete_rule=$base_search\n\n            # Select all other SUID/SGID binaries possibly also present in the found rule\n\n            readarray -t handled_sbinaries < <(grep -o -e \"-F path=[^[:space:]]\\+\" <<< \"$concrete_rule\")\n            handled_sbinaries=(\"${handled_sbinaries[@]//-F path=/}\")\n\n            # Merge the list of such SUID/SGID binaries found in this iteration with global list ignoring duplicates\n            readarray -t sbinaries_to_skip < <(for i in \"${sbinaries_to_skip[@]}\" \"${handled_sbinaries[@]}\"; do echo \"$i\"; done | sort -du)\n\n            # if there is a -F perm flag, remove it\n            if grep -q '.*-F\\s\\+perm=[rwxa]\\+.*' <<< \"$concrete_rule\"; then\n\n                # Separate concrete_rule into three sections using hash '#'\n                # sign as a delimiter around rule's permission section borders\n                # note that the trailing space after perm flag is captured because there would be\n                # two consecutive spaces after joining remaining parts of the rule together\n                concrete_rule=\"$(echo \"$concrete_rule\" | sed -n \"s/\\(.*\\)\\+\\(-F perm=[rwax]\\+\\ \\?\\)\\+/\\1#\\2#/p\")\"\n\n                # Split concrete_rule into head and tail sections using hash '#' delimiter\n                # The second column contains the permission section, which we don't need to extract\n                rule_head=$(cut -d '#' -f 1 <<< \"$concrete_rule\")\n                rule_tail=$(cut -d '#' -f 3 <<< \"$concrete_rule\")\n\n                # Remove permissions section from existing rule in the file\n                sed -i \"s#${rule_head}\\(.*\\)${rule_tail}#${rule_head}${rule_tail}#\" \"$afile\"\n            fi\n        # If the required audit rule for particular sbinary wasn't found yet, insert it under following conditions:\n        #\n        # * in the \"auditctl\" mode of operation insert particular rule each time\n        #   (because in this mode there's only one file -- /etc/audit/audit.rules to be inspected for presence of this rule),\n        #\n        # * in the \"augenrules\" mode of operation insert particular rule only once and only in case we have already\n        #   searched all of the files from /etc/audit/rules.d/*.rules location (since that audit rule can be defined\n        #   in any of those files and if not, we want it to be inserted only once into /etc/audit/rules.d/privileged.rules file)\n        #\n\telif [[ $count_of_inspected_files -eq \"${#files_to_inspect[@]}\" ]]\n        then\n\t\n            # Check if this sbinary wasn't already handled in some of the previous afile iterations\n            # Return match only if whole sbinary definition matched (not in the case just prefix matched!!!)\n            if [[ ! $(sed -ne \"\\|${sbinary}|p\" <<< \"${sbinaries_to_skip[*]}\") ]]\n            then\n                # Current audit rules file's content doesn't contain expected rule for this\n                # SUID/SGID binary yet => append it\n                echo \"$expected_rule\" >> \"$output_audit_file\"\n            fi\n            continue\n        fi\n    done\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_privileged_commands",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83759-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.2\n  - audit_rules_privileged_commands\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Search for privileged commands\n  shell: |\n    set -o pipefail\n    find / -not \\( -fstype afs -o -fstype ceph -o -fstype cifs -o -fstype smb3 -o -fstype smbfs -o -fstype sshfs -o -fstype ncpfs -o -fstype ncp -o -fstype nfs -o -fstype nfs4 -o -fstype gfs -o -fstype gfs2 -o -fstype glusterfs -o -fstype gpfs -o -fstype pvfs2 -o -fstype ocfs2 -o -fstype lustre -o -fstype davfs -o -fstype fuse.sshfs \\) -type f \\( -perm -4000 -o -perm -2000 \\) 2> /dev/null\n  args:\n    warn: false\n    executable: /bin/bash\n  check_mode: false\n  register: find_result\n  changed_when: false\n  failed_when: false\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83759-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.2\n  - audit_rules_privileged_commands\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Search /etc/audit/rules.d for audit rule entries\n  find:\n    paths: /etc/audit/rules.d\n    recurse: false\n    contains: ^.*path={{ item }} .*$\n    patterns: '*.rules'\n  with_items:\n  - '{{ find_result.stdout_lines }}'\n  register: files_result\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83759-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.2\n  - audit_rules_privileged_commands\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Overwrites the rule in rules.d\n  lineinfile:\n    path: '{{ item.1.path }}'\n    line: -a always,exit -F path={{ item.0.item }} -F auid>=1000 -F auid!=unset -F\n      key=privileged\n    create: false\n    regexp: ^.*path={{ item.0.item }} .*$\n  with_subelements:\n  - '{{ files_result.results }}'\n  - files\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83759-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.2\n  - audit_rules_privileged_commands\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Adds the rule in rules.d\n  lineinfile:\n    path: /etc/audit/rules.d/privileged.rules\n    line: -a always,exit -F path={{ item.item }} -F auid>=1000 -F auid!=unset -F key=privileged\n    create: true\n  with_items:\n  - '{{ files_result.results }}'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - files_result.results is defined and item.matched == 0\n  tags:\n  - CCE-83759-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.2\n  - audit_rules_privileged_commands\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Inserts/replaces the rule in audit.rules\n  lineinfile:\n    path: /etc/audit/audit.rules\n    line: -a always,exit -F path={{ item.item }} -F auid>=1000 -F auid!=unset -F key=privileged\n    create: true\n    regexp: ^.*path={{ item.item }} .*$\n  with_items:\n  - '{{ files_result.results }}'\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83759-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-2(4)\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.2.2\n  - audit_rules_privileged_commands\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_time_adjtimex": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_time_adjtimex",
			"title": "Record attempts to alter time through adjtimex",
			"result": "fail",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83840-9"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-001487",
				"CCI-000169",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"AC-6(9)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"Req-10.4.2.b"
			],
			"description": "If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following line to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S adjtimex -F key=audit_time_rules</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S adjtimex -F key=audit_time_rules</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S adjtimex -F key=audit_time_rules</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S adjtimex -F key=audit_time_rules</pre>\nThe -k option allows for the specification of a key in string form that can be\nused for better reporting capability through ausearch and aureport. Multiple\nsystem calls can be defined on the same line to save space if desired, but is\nnot required. See an example of multiple combined syscalls:\n<pre>-a always,exit -F arch=b64 -S adjtimex,settimeofday -F key=audit_time_rules</pre>",
			"rationale": "Arbitrary changes to the system time can be used to obfuscate\nnefarious activities in log files, as well as to confuse network services that\nare highly dependent upon an accurate system time (such as sshd). All changes\nto the system time should be audited.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_time_adjtimex:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_time_adjtimex",
					"system": "urn:xccdf:fix:script:kubernetes",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "---\napiVersion: machineconfiguration.openshift.io/v1\nkind: MachineConfig\nspec:\n  config:\n    ignition:\n      version: 3.1.0\n    storage:\n      files:\n      - contents:\n          source: data:,{{ -a%20always%2Cexit%20-F%20arch%3Db64%20-S%20adjtimex%20-k%20audit_time_rules%0A-a%20always%2Cexit%20-F%20arch%3Db32%20-S%20adjtimex%20-k%20audit_time_rules%0A }}\n        mode: 0600\n        path: /etc/audit/rules.d/75-syscall-adjtimex.rules\n        overwrite: true\n"
				},
				{
					"remediation_id": "audit_rules_time_adjtimex",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n    # Create expected audit group and audit rule form for particular system call & architecture\n    if [ ${ARCH} = \"b32\" ]\n    then\n        ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n        # stime system call is known at 32-bit arch (see e.g \"$ ausyscall i386 stime\" 's output)\n        # so append it to the list of time group system calls to be audited\n        SYSCALL=\"adjtimex settimeofday stime\"\n        SYSCALL_GROUPING=\"adjtimex settimeofday stime\"\n    elif [ ${ARCH} = \"b64\" ]\n    then\n        ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n        # stime system call isn't known at 64-bit arch (see \"$ ausyscall x86_64 stime\" 's output)\n        # therefore don't add it to the list of time group system calls to be audited\n        SYSCALL=\"adjtimex settimeofday\"\n        SYSCALL_GROUPING=\"adjtimex settimeofday\"\n    fi\n    OTHER_FILTERS=\"\"\n    AUID_FILTERS=\"\"\n    KEY=\"audit_time_rules\"\n    # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n    unset syscall_a\n    unset syscall_grouping\n    unset syscall_string\n    unset syscall\n    unset file_to_edit\n    unset rule_to_edit\n    unset rule_syscalls_to_edit\n    unset other_string\n    unset auid_string\n    unset full_rule\n\n    # Load macro arguments into arrays\n    read -a syscall_a <<< $SYSCALL\n    read -a syscall_grouping <<< $SYSCALL_GROUPING\n\n    # Create a list of audit *.rules files that should be inspected for presence and correctness\n    # of a particular audit rule. The scheme is as follows:\n    #\n    # -----------------------------------------------------------------------------------------\n    #  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n    # -----------------------------------------------------------------------------------------\n    #        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n    # -----------------------------------------------------------------------------------------\n    #        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n    #        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n    # -----------------------------------------------------------------------------------------\n    #\n    files_to_inspect=()\n\n\n    # If audit tool is 'augenrules', then check if the audit rule is defined\n    # If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n    # If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\n    default_file=\"/etc/audit/rules.d/$KEY.rules\"\n    # As other_filters may include paths, lets use a different delimiter for it\n    # The \"F\" script expression tells sed to print the filenames where the expressions matched\n    readarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n    # Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\n    if [ ${#files_to_inspect[@]} -eq \"0\" ]\n    then\n        file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n        files_to_inspect=(\"$file_to_inspect\")\n        if [ ! -e \"$file_to_inspect\" ]\n        then\n            touch \"$file_to_inspect\"\n            chmod 0640 \"$file_to_inspect\"\n        fi\n    fi\n\n    # After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\n    skip=1\n\n    for audit_file in \"${files_to_inspect[@]}\"\n    do\n        # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n        # i.e, collect rules that match:\n        # * the action, list and arch, (2-nd argument)\n        # * the other filters, (3-rd argument)\n        # * the auid filters, (4-rd argument)\n        readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n        candidate_rules=()\n        # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n        for s_rule in \"${similar_rules[@]}\"\n        do\n            # Strip all the options and fields we know of,\n            # than check if there was any field left over\n            extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n            grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n        done\n\n        if [[ ${#syscall_a[@]} -ge 1 ]]\n        then\n            # Check if the syscall we want is present in any of the similar existing rules\n            for rule in \"${candidate_rules[@]}\"\n            do\n                rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n                all_syscalls_found=0\n                for syscall in \"${syscall_a[@]}\"\n                do\n                    grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                       # A syscall was not found in the candidate rule\n                       all_syscalls_found=1\n                       }\n                done\n                if [[ $all_syscalls_found -eq 0 ]]\n                then\n                    # We found a rule with all the syscall(s) we want; skip rest of macro\n                    skip=0\n                    break\n                fi\n\n                # Check if this rule can be grouped with our target syscall and keep track of it\n                for syscall_g in \"${syscall_grouping[@]}\"\n                do\n                    if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                    then\n                        file_to_edit=${audit_file}\n                        rule_to_edit=${rule}\n                        rule_syscalls_to_edit=${rule_syscalls}\n                    fi\n                done\n            done\n        else\n            # If there is any candidate rule, it is compliant; skip rest of macro\n            if [ \"${#candidate_rules[@]}\" -gt 0 ]\n            then\n                skip=0\n            fi\n        fi\n\n        if [ \"$skip\" -eq 0 ]; then\n            break\n        fi\n    done\n\n    if [ \"$skip\" -ne 0 ]; then\n        # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n        # At this point we know if we need to either append the $full_rule or group\n        # the syscall together with an exsiting rule\n\n        # Append the full_rule if it cannot be grouped to any other rule\n        if [ -z ${rule_to_edit+x} ]\n        then\n            # Build full_rule while avoid adding double spaces when other_filters is empty\n            if [ \"${#syscall_a[@]}\" -gt 0 ]\n            then\n                syscall_string=\"\"\n                for syscall in \"${syscall_a[@]}\"\n                do\n                    syscall_string+=\" -S $syscall\"\n                done\n            fi\n            other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n            auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n            full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n            echo \"$full_rule\" >> \"$default_file\"\n            chmod o-rwx ${default_file}\n        else\n            # Check if the syscalls are declared as a comma separated list or\n            # as multiple -S parameters\n            if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n            then\n                delimiter=\",\"\n            else\n                delimiter=\" -S \"\n            fi\n            new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n                   # A syscall was not found in the candidate rule\n                   new_grouped_syscalls+=\"${delimiter}${syscall}\"\n                   }\n            done\n\n            # Group the syscall in the rule\n            sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n        fi\n    fi\n    unset syscall_a\n    unset syscall_grouping\n    unset syscall_string\n    unset syscall\n    unset file_to_edit\n    unset rule_to_edit\n    unset rule_syscalls_to_edit\n    unset other_string\n    unset auid_string\n    unset full_rule\n\n    # Load macro arguments into arrays\n    read -a syscall_a <<< $SYSCALL\n    read -a syscall_grouping <<< $SYSCALL_GROUPING\n\n    # Create a list of audit *.rules files that should be inspected for presence and correctness\n    # of a particular audit rule. The scheme is as follows:\n    #\n    # -----------------------------------------------------------------------------------------\n    #  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n    # -----------------------------------------------------------------------------------------\n    #        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n    # -----------------------------------------------------------------------------------------\n    #        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n    #        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n    # -----------------------------------------------------------------------------------------\n    #\n    files_to_inspect=()\n\n\n\n    # If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n    # file to the list of files to be inspected\n    default_file=\"/etc/audit/audit.rules\"\n    files_to_inspect+=('/etc/audit/audit.rules' )\n\n    # After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\n    skip=1\n\n    for audit_file in \"${files_to_inspect[@]}\"\n    do\n        # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n        # i.e, collect rules that match:\n        # * the action, list and arch, (2-nd argument)\n        # * the other filters, (3-rd argument)\n        # * the auid filters, (4-rd argument)\n        readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n        candidate_rules=()\n        # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n        for s_rule in \"${similar_rules[@]}\"\n        do\n            # Strip all the options and fields we know of,\n            # than check if there was any field left over\n            extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n            grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n        done\n\n        if [[ ${#syscall_a[@]} -ge 1 ]]\n        then\n            # Check if the syscall we want is present in any of the similar existing rules\n            for rule in \"${candidate_rules[@]}\"\n            do\n                rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n                all_syscalls_found=0\n                for syscall in \"${syscall_a[@]}\"\n                do\n                    grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                       # A syscall was not found in the candidate rule\n                       all_syscalls_found=1\n                       }\n                done\n                if [[ $all_syscalls_found -eq 0 ]]\n                then\n                    # We found a rule with all the syscall(s) we want; skip rest of macro\n                    skip=0\n                    break\n                fi\n\n                # Check if this rule can be grouped with our target syscall and keep track of it\n                for syscall_g in \"${syscall_grouping[@]}\"\n                do\n                    if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                    then\n                        file_to_edit=${audit_file}\n                        rule_to_edit=${rule}\n                        rule_syscalls_to_edit=${rule_syscalls}\n                    fi\n                done\n            done\n        else\n            # If there is any candidate rule, it is compliant; skip rest of macro\n            if [ \"${#candidate_rules[@]}\" -gt 0 ]\n            then\n                skip=0\n            fi\n        fi\n\n        if [ \"$skip\" -eq 0 ]; then\n            break\n        fi\n    done\n\n    if [ \"$skip\" -ne 0 ]; then\n        # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n        # At this point we know if we need to either append the $full_rule or group\n        # the syscall together with an exsiting rule\n\n        # Append the full_rule if it cannot be grouped to any other rule\n        if [ -z ${rule_to_edit+x} ]\n        then\n            # Build full_rule while avoid adding double spaces when other_filters is empty\n            if [ \"${#syscall_a[@]}\" -gt 0 ]\n            then\n                syscall_string=\"\"\n                for syscall in \"${syscall_a[@]}\"\n                do\n                    syscall_string+=\" -S $syscall\"\n                done\n            fi\n            other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n            auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n            full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n            echo \"$full_rule\" >> \"$default_file\"\n            chmod o-rwx ${default_file}\n        else\n            # Check if the syscalls are declared as a comma separated list or\n            # as multiple -S parameters\n            if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n            then\n                delimiter=\",\"\n            else\n                delimiter=\" -S \"\n            fi\n            new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n                   # A syscall was not found in the candidate rule\n                   new_grouped_syscalls+=\"${delimiter}${syscall}\"\n                   }\n            done\n\n            # Group the syscall in the rule\n            sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n        fi\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_time_adjtimex",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83840-9\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.4.2.b\n  - audit_rules_time_adjtimex\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set architecture for audit tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83840-9\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.4.2.b\n  - audit_rules_time_adjtimex\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for adjtimex for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - adjtimex\n      syscall_grouping:\n      - adjtimex\n      - settimeofday\n      - stime\n\n  - name: Check existence of adjtimex in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/audit_time_rules.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/audit_time_rules.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_time_rules\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - adjtimex\n      syscall_grouping:\n      - adjtimex\n      - settimeofday\n      - stime\n\n  - name: Check existence of adjtimex in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_time_rules\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83840-9\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.4.2.b\n  - audit_rules_time_adjtimex\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for adjtimex for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - adjtimex\n      syscall_grouping:\n      - adjtimex\n      - settimeofday\n\n  - name: Check existence of adjtimex in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/audit_time_rules.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/audit_time_rules.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=audit_time_rules\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - adjtimex\n      syscall_grouping:\n      - adjtimex\n      - settimeofday\n      - stime\n\n  - name: Check existence of adjtimex in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=audit_time_rules\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83840-9\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.4.2.b\n  - audit_rules_time_adjtimex\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_time_clock_settime": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_time_clock_settime",
			"title": "Record Attempts to Alter Time Through clock_settime",
			"result": "fail",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83837-5"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-001487",
				"CCI-000169",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"AC-6(9)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"Req-10.4.2.b"
			],
			"description": "If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following line to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S clock_settime -F a0=0x0 -F key=time-change</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S clock_settime -F a0=0x0 -F key=time-change</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S clock_settime -F a0=0x0 -F key=time-change</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S clock_settime -F a0=0x0 -F key=time-change</pre>\nThe -k option allows for the specification of a key in string form that can\nbe used for better reporting capability through ausearch and aureport.\nMultiple system calls can be defined on the same line to save space if\ndesired, but is not required. See an example of multiple combined syscalls:\n<pre>-a always,exit -F arch=b64 -S adjtimex,settimeofday -F key=audit_time_rules</pre>",
			"rationale": "Arbitrary changes to the system time can be used to obfuscate\nnefarious activities in log files, as well as to confuse network services that\nare highly dependent upon an accurate system time (such as sshd). All changes\nto the system time should be audited.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_time_clock_settime:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_time_clock_settime",
					"system": "urn:xccdf:fix:script:kubernetes",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "---\napiVersion: machineconfiguration.openshift.io/v1\nkind: MachineConfig\nspec:\n  config:\n    ignition:\n      version: 3.1.0\n    storage:\n      files:\n      - contents:\n          source: data:,{{ -a%20always%2Cexit%20-F%20arch%3Db64%20-S%20clock_settime%20-F%20a0%3D0x0%20-k%20time-change%0A-a%20always%2Cexit%20-F%20arch%3Db32%20-S%20clock_settime%20-F%20a0%3D0x0%20-k%20time-change%0A }}\n        mode: 0600\n        path: /etc/audit/rules.d/75-syscall-clock-settime.rules\n        overwrite: true\n"
				},
				{
					"remediation_id": "audit_rules_time_clock_settime",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# First perform the remediation of the syscall rule\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n\tACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n\tOTHER_FILTERS=\"-F a0=0x0\"\n\tAUID_FILTERS=\"\"\n\tSYSCALL=\"clock_settime\"\n\tKEY=\"time-change\"\n\tSYSCALL_GROUPING=\"\"\n\t# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n# If audit tool is 'augenrules', then check if the audit rule is defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n# If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\ndefault_file=\"/etc/audit/rules.d/$KEY.rules\"\n# As other_filters may include paths, lets use a different delimiter for it\n# The \"F\" script expression tells sed to print the filenames where the expressions matched\nreadarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n# Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\nif [ ${#files_to_inspect[@]} -eq \"0\" ]\nthen\n    file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n    files_to_inspect=(\"$file_to_inspect\")\n    if [ ! -e \"$file_to_inspect\" ]\n    then\n        touch \"$file_to_inspect\"\n        chmod 0640 \"$file_to_inspect\"\n    fi\nfi\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\n\tunset syscall_a\nunset syscall_grouping\nunset syscall_string\nunset syscall\nunset file_to_edit\nunset rule_to_edit\nunset rule_syscalls_to_edit\nunset other_string\nunset auid_string\nunset full_rule\n\n# Load macro arguments into arrays\nread -a syscall_a <<< $SYSCALL\nread -a syscall_grouping <<< $SYSCALL_GROUPING\n\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n#  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n# -----------------------------------------------------------------------------------------\n#        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n# -----------------------------------------------------------------------------------------\n#        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n#        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\n#\nfiles_to_inspect=()\n\n\n\n# If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# file to the list of files to be inspected\ndefault_file=\"/etc/audit/audit.rules\"\nfiles_to_inspect+=('/etc/audit/audit.rules' )\n\n# After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\nskip=1\n\nfor audit_file in \"${files_to_inspect[@]}\"\ndo\n    # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n    # i.e, collect rules that match:\n    # * the action, list and arch, (2-nd argument)\n    # * the other filters, (3-rd argument)\n    # * the auid filters, (4-rd argument)\n    readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n    candidate_rules=()\n    # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n    for s_rule in \"${similar_rules[@]}\"\n    do\n        # Strip all the options and fields we know of,\n        # than check if there was any field left over\n        extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n        grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n    done\n\n    if [[ ${#syscall_a[@]} -ge 1 ]]\n    then\n        # Check if the syscall we want is present in any of the similar existing rules\n        for rule in \"${candidate_rules[@]}\"\n        do\n            rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n            all_syscalls_found=0\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                   # A syscall was not found in the candidate rule\n                   all_syscalls_found=1\n                   }\n            done\n            if [[ $all_syscalls_found -eq 0 ]]\n            then\n                # We found a rule with all the syscall(s) we want; skip rest of macro\n                skip=0\n                break\n            fi\n\n            # Check if this rule can be grouped with our target syscall and keep track of it\n            for syscall_g in \"${syscall_grouping[@]}\"\n            do\n                if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                then\n                    file_to_edit=${audit_file}\n                    rule_to_edit=${rule}\n                    rule_syscalls_to_edit=${rule_syscalls}\n                fi\n            done\n        done\n    else\n        # If there is any candidate rule, it is compliant; skip rest of macro\n        if [ \"${#candidate_rules[@]}\" -gt 0 ]\n        then\n            skip=0\n        fi\n    fi\n\n    if [ \"$skip\" -eq 0 ]; then\n        break\n    fi\ndone\n\nif [ \"$skip\" -ne 0 ]; then\n    # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n    # At this point we know if we need to either append the $full_rule or group\n    # the syscall together with an exsiting rule\n\n    # Append the full_rule if it cannot be grouped to any other rule\n    if [ -z ${rule_to_edit+x} ]\n    then\n        # Build full_rule while avoid adding double spaces when other_filters is empty\n        if [ \"${#syscall_a[@]}\" -gt 0 ]\n        then\n            syscall_string=\"\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                syscall_string+=\" -S $syscall\"\n            done\n        fi\n        other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n        auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n        full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n        echo \"$full_rule\" >> \"$default_file\"\n        chmod o-rwx ${default_file}\n    else\n        # Check if the syscalls are declared as a comma separated list or\n        # as multiple -S parameters\n        if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n        then\n            delimiter=\",\"\n        else\n            delimiter=\" -S \"\n        fi\n        new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n        for syscall in \"${syscall_a[@]}\"\n        do\n            grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n               # A syscall was not found in the candidate rule\n               new_grouped_syscalls+=\"${delimiter}${syscall}\"\n               }\n        done\n\n        # Group the syscall in the rule\n        sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n    fi\nfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_time_clock_settime",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83837-5\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.4.2.b\n  - audit_rules_time_clock_settime\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set architecture for audit tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83837-5\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.4.2.b\n  - audit_rules_time_clock_settime\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for clock_settime for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - clock_settime\n      syscall_grouping: []\n\n  - name: Check existence of clock_settime in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F a0=0x0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/time-change.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/time-change.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F a0=0x0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F a0=0x0 -F\n        key=time-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - clock_settime\n      syscall_grouping: []\n\n  - name: Check existence of clock_settime in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F a0=0x0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F a0=0x0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F a0=0x0 -F\n        key=time-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83837-5\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.4.2.b\n  - audit_rules_time_clock_settime\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for clock_settime for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - clock_settime\n      syscall_grouping: []\n\n  - name: Check existence of clock_settime in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F a0=0x0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/time-change.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/time-change.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F a0=0x0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F a0=0x0 -F\n        key=time-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - clock_settime\n      syscall_grouping: []\n\n  - name: Check existence of clock_settime in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* -F a0=0x0 (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F a0=0x0 (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F a0=0x0 -F\n        key=time-change\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83837-5\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.4.2.b\n  - audit_rules_time_clock_settime\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_time_settimeofday": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_time_settimeofday",
			"title": "Record attempts to alter time through settimeofday",
			"result": "fail",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83836-7"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-001487",
				"CCI-000169",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"AC-6(9)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"Req-10.4.2.b"
			],
			"description": "If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following line to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code>:\n<pre>-a always,exit -F arch=b32 -S settimeofday -F key=audit_time_rules</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S settimeofday -F key=audit_time_rules</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-a always,exit -F arch=b32 -S settimeofday -F key=audit_time_rules</pre>\nIf the system is 64 bit then also add the following line:\n<pre>-a always,exit -F arch=b64 -S settimeofday -F key=audit_time_rules</pre>\nThe -k option allows for the specification of a key in string form that can be\nused for better reporting capability through ausearch and aureport. Multiple\nsystem calls can be defined on the same line to save space if desired, but is\nnot required. See an example of multiple combined syscalls:\n<pre>-a always,exit -F arch=b64 -S adjtimex,settimeofday -F key=audit_time_rules</pre>",
			"rationale": "Arbitrary changes to the system time can be used to obfuscate\nnefarious activities in log files, as well as to confuse network services that\nare highly dependent upon an accurate system time (such as sshd). All changes\nto the system time should be audited.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_time_settimeofday:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_time_settimeofday",
					"system": "urn:xccdf:fix:script:kubernetes",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "---\napiVersion: machineconfiguration.openshift.io/v1\nkind: MachineConfig\nspec:\n  config:\n    ignition:\n      version: 3.1.0\n    storage:\n      files:\n      - contents:\n          source: data:,{{ -a%20always%2Cexit%20-F%20arch%3Db64%20-S%20settimeofday%20-k%20audit_time_rules%0A-a%20always%2Cexit%20-F%20arch%3Db32%20-S%20settimeofday%20-k%20audit_time_rules%0A }}\n        mode: 0600\n        path: /etc/audit/rules.d/75-syscall-settimeofday.rules\n        overwrite: true\n"
				},
				{
					"remediation_id": "audit_rules_time_settimeofday",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n    # Create expected audit group and audit rule form for particular system call & architecture\n    if [ ${ARCH} = \"b32\" ]\n    then\n        ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n        # stime system call is known at 32-bit arch (see e.g \"$ ausyscall i386 stime\" 's output)\n        # so append it to the list of time group system calls to be audited\n        SYSCALL=\"adjtimex settimeofday stime\"\n        SYSCALL_GROUPING=\"adjtimex settimeofday stime\"\n    elif [ ${ARCH} = \"b64\" ]\n    then\n        ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n        # stime system call isn't known at 64-bit arch (see \"$ ausyscall x86_64 stime\" 's output)\n        # therefore don't add it to the list of time group system calls to be audited\n        SYSCALL=\"adjtimex settimeofday\"\n        SYSCALL_GROUPING=\"adjtimex settimeofday\"\n    fi\n    OTHER_FILTERS=\"\"\n    AUID_FILTERS=\"\"\n    KEY=\"audit_time_rules\"\n    # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n    unset syscall_a\n    unset syscall_grouping\n    unset syscall_string\n    unset syscall\n    unset file_to_edit\n    unset rule_to_edit\n    unset rule_syscalls_to_edit\n    unset other_string\n    unset auid_string\n    unset full_rule\n\n    # Load macro arguments into arrays\n    read -a syscall_a <<< $SYSCALL\n    read -a syscall_grouping <<< $SYSCALL_GROUPING\n\n    # Create a list of audit *.rules files that should be inspected for presence and correctness\n    # of a particular audit rule. The scheme is as follows:\n    #\n    # -----------------------------------------------------------------------------------------\n    #  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n    # -----------------------------------------------------------------------------------------\n    #        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n    # -----------------------------------------------------------------------------------------\n    #        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n    #        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n    # -----------------------------------------------------------------------------------------\n    #\n    files_to_inspect=()\n\n\n    # If audit tool is 'augenrules', then check if the audit rule is defined\n    # If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n    # If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\n    default_file=\"/etc/audit/rules.d/$KEY.rules\"\n    # As other_filters may include paths, lets use a different delimiter for it\n    # The \"F\" script expression tells sed to print the filenames where the expressions matched\n    readarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n    # Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\n    if [ ${#files_to_inspect[@]} -eq \"0\" ]\n    then\n        file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n        files_to_inspect=(\"$file_to_inspect\")\n        if [ ! -e \"$file_to_inspect\" ]\n        then\n            touch \"$file_to_inspect\"\n            chmod 0640 \"$file_to_inspect\"\n        fi\n    fi\n\n    # After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\n    skip=1\n\n    for audit_file in \"${files_to_inspect[@]}\"\n    do\n        # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n        # i.e, collect rules that match:\n        # * the action, list and arch, (2-nd argument)\n        # * the other filters, (3-rd argument)\n        # * the auid filters, (4-rd argument)\n        readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n        candidate_rules=()\n        # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n        for s_rule in \"${similar_rules[@]}\"\n        do\n            # Strip all the options and fields we know of,\n            # than check if there was any field left over\n            extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n            grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n        done\n\n        if [[ ${#syscall_a[@]} -ge 1 ]]\n        then\n            # Check if the syscall we want is present in any of the similar existing rules\n            for rule in \"${candidate_rules[@]}\"\n            do\n                rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n                all_syscalls_found=0\n                for syscall in \"${syscall_a[@]}\"\n                do\n                    grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                       # A syscall was not found in the candidate rule\n                       all_syscalls_found=1\n                       }\n                done\n                if [[ $all_syscalls_found -eq 0 ]]\n                then\n                    # We found a rule with all the syscall(s) we want; skip rest of macro\n                    skip=0\n                    break\n                fi\n\n                # Check if this rule can be grouped with our target syscall and keep track of it\n                for syscall_g in \"${syscall_grouping[@]}\"\n                do\n                    if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                    then\n                        file_to_edit=${audit_file}\n                        rule_to_edit=${rule}\n                        rule_syscalls_to_edit=${rule_syscalls}\n                    fi\n                done\n            done\n        else\n            # If there is any candidate rule, it is compliant; skip rest of macro\n            if [ \"${#candidate_rules[@]}\" -gt 0 ]\n            then\n                skip=0\n            fi\n        fi\n\n        if [ \"$skip\" -eq 0 ]; then\n            break\n        fi\n    done\n\n    if [ \"$skip\" -ne 0 ]; then\n        # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n        # At this point we know if we need to either append the $full_rule or group\n        # the syscall together with an exsiting rule\n\n        # Append the full_rule if it cannot be grouped to any other rule\n        if [ -z ${rule_to_edit+x} ]\n        then\n            # Build full_rule while avoid adding double spaces when other_filters is empty\n            if [ \"${#syscall_a[@]}\" -gt 0 ]\n            then\n                syscall_string=\"\"\n                for syscall in \"${syscall_a[@]}\"\n                do\n                    syscall_string+=\" -S $syscall\"\n                done\n            fi\n            other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n            auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n            full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n            echo \"$full_rule\" >> \"$default_file\"\n            chmod o-rwx ${default_file}\n        else\n            # Check if the syscalls are declared as a comma separated list or\n            # as multiple -S parameters\n            if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n            then\n                delimiter=\",\"\n            else\n                delimiter=\" -S \"\n            fi\n            new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n                   # A syscall was not found in the candidate rule\n                   new_grouped_syscalls+=\"${delimiter}${syscall}\"\n                   }\n            done\n\n            # Group the syscall in the rule\n            sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n        fi\n    fi\n    unset syscall_a\n    unset syscall_grouping\n    unset syscall_string\n    unset syscall\n    unset file_to_edit\n    unset rule_to_edit\n    unset rule_syscalls_to_edit\n    unset other_string\n    unset auid_string\n    unset full_rule\n\n    # Load macro arguments into arrays\n    read -a syscall_a <<< $SYSCALL\n    read -a syscall_grouping <<< $SYSCALL_GROUPING\n\n    # Create a list of audit *.rules files that should be inspected for presence and correctness\n    # of a particular audit rule. The scheme is as follows:\n    #\n    # -----------------------------------------------------------------------------------------\n    #  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n    # -----------------------------------------------------------------------------------------\n    #        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n    # -----------------------------------------------------------------------------------------\n    #        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n    #        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n    # -----------------------------------------------------------------------------------------\n    #\n    files_to_inspect=()\n\n\n\n    # If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n    # file to the list of files to be inspected\n    default_file=\"/etc/audit/audit.rules\"\n    files_to_inspect+=('/etc/audit/audit.rules' )\n\n    # After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\n    skip=1\n\n    for audit_file in \"${files_to_inspect[@]}\"\n    do\n        # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n        # i.e, collect rules that match:\n        # * the action, list and arch, (2-nd argument)\n        # * the other filters, (3-rd argument)\n        # * the auid filters, (4-rd argument)\n        readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n        candidate_rules=()\n        # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n        for s_rule in \"${similar_rules[@]}\"\n        do\n            # Strip all the options and fields we know of,\n            # than check if there was any field left over\n            extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n            grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n        done\n\n        if [[ ${#syscall_a[@]} -ge 1 ]]\n        then\n            # Check if the syscall we want is present in any of the similar existing rules\n            for rule in \"${candidate_rules[@]}\"\n            do\n                rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n                all_syscalls_found=0\n                for syscall in \"${syscall_a[@]}\"\n                do\n                    grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                       # A syscall was not found in the candidate rule\n                       all_syscalls_found=1\n                       }\n                done\n                if [[ $all_syscalls_found -eq 0 ]]\n                then\n                    # We found a rule with all the syscall(s) we want; skip rest of macro\n                    skip=0\n                    break\n                fi\n\n                # Check if this rule can be grouped with our target syscall and keep track of it\n                for syscall_g in \"${syscall_grouping[@]}\"\n                do\n                    if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                    then\n                        file_to_edit=${audit_file}\n                        rule_to_edit=${rule}\n                        rule_syscalls_to_edit=${rule_syscalls}\n                    fi\n                done\n            done\n        else\n            # If there is any candidate rule, it is compliant; skip rest of macro\n            if [ \"${#candidate_rules[@]}\" -gt 0 ]\n            then\n                skip=0\n            fi\n        fi\n\n        if [ \"$skip\" -eq 0 ]; then\n            break\n        fi\n    done\n\n    if [ \"$skip\" -ne 0 ]; then\n        # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n        # At this point we know if we need to either append the $full_rule or group\n        # the syscall together with an exsiting rule\n\n        # Append the full_rule if it cannot be grouped to any other rule\n        if [ -z ${rule_to_edit+x} ]\n        then\n            # Build full_rule while avoid adding double spaces when other_filters is empty\n            if [ \"${#syscall_a[@]}\" -gt 0 ]\n            then\n                syscall_string=\"\"\n                for syscall in \"${syscall_a[@]}\"\n                do\n                    syscall_string+=\" -S $syscall\"\n                done\n            fi\n            other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n            auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n            full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n            echo \"$full_rule\" >> \"$default_file\"\n            chmod o-rwx ${default_file}\n        else\n            # Check if the syscalls are declared as a comma separated list or\n            # as multiple -S parameters\n            if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n            then\n                delimiter=\",\"\n            else\n                delimiter=\" -S \"\n            fi\n            new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n                   # A syscall was not found in the candidate rule\n                   new_grouped_syscalls+=\"${delimiter}${syscall}\"\n                   }\n            done\n\n            # Group the syscall in the rule\n            sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n        fi\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_time_settimeofday",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83836-7\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.4.2.b\n  - audit_rules_time_settimeofday\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Set architecture for audit tasks\n  set_fact:\n    audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }}\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83836-7\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.4.2.b\n  - audit_rules_time_settimeofday\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for settimeofday for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - settimeofday\n      syscall_grouping:\n      - adjtimex\n      - settimeofday\n      - stime\n\n  - name: Check existence of settimeofday in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/audit_time_rules.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/audit_time_rules.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_time_rules\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - settimeofday\n      syscall_grouping:\n      - adjtimex\n      - settimeofday\n      - stime\n\n  - name: Check existence of settimeofday in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_time_rules\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83836-7\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.4.2.b\n  - audit_rules_time_settimeofday\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for settimeofday for x86_64 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - settimeofday\n      syscall_grouping:\n      - adjtimex\n      - settimeofday\n      - stime\n\n  - name: Check existence of settimeofday in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/audit_time_rules.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/audit_time_rules.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=audit_time_rules\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - settimeofday\n      syscall_grouping:\n      - adjtimex\n      - settimeofday\n      - stime\n\n  - name: Check existence of settimeofday in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=audit_time_rules\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - audit_arch == \"b64\"\n  tags:\n  - CCE-83836-7\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.4.2.b\n  - audit_rules_time_settimeofday\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_time_stime": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_time_stime",
			"title": "Record Attempts to Alter Time Through stime",
			"result": "fail",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83835-9"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-001487",
				"CCI-000169",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"AC-6(9)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"Req-10.4.2.b"
			],
			"description": "If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the\ndefault), add the following line to a file with suffix <code>.rules</code> in the\ndirectory <code>/etc/audit/rules.d</code> for both 32 bit and 64 bit systems:\n<pre>-a always,exit -F arch=b32 -S stime -F key=audit_time_rules</pre>\nSince the 64 bit version of the &quot;stime&quot; system call is not defined in the audit\nlookup table, the corresponding &quot;-F arch=b64&quot; form of this rule is not expected\nto be defined on 64 bit systems (the aforementioned &quot;-F arch=b32&quot; stime rule\nform itself is sufficient for both 32 bit and 64 bit systems). If the\n<code>auditd</code> daemon is configured to use the <code>auditctl</code> utility to\nread audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file for both 32 bit and 64 bit systems:\n<pre>-a always,exit -F arch=b32 -S stime -F key=audit_time_rules</pre>\nSince the 64 bit version of the &quot;stime&quot; system call is not defined in the audit\nlookup table, the corresponding &quot;-F arch=b64&quot; form of this rule is not expected\nto be defined on 64 bit systems (the aforementioned &quot;-F arch=b32&quot; stime rule\nform itself is sufficient for both 32 bit and 64 bit systems). The -k option\nallows for the specification of a key in string form that can be used for\nbetter reporting capability through ausearch and aureport. Multiple system\ncalls can be defined on the same line to save space if desired, but is not\nrequired. See an example of multiple combined system calls:\n<pre>-a always,exit -F arch=b64 -S adjtimex,settimeofday -F key=audit_time_rules</pre>",
			"rationale": "Arbitrary changes to the system time can be used to obfuscate\nnefarious activities in log files, as well as to confuse network services that\nare highly dependent upon an accurate system time (such as sshd). All changes\nto the system time should be audited.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_time_stime:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_time_stime",
					"system": "urn:xccdf:fix:script:kubernetes",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "---\napiVersion: machineconfiguration.openshift.io/v1\nkind: MachineConfig\nspec:\n  config:\n    ignition:\n      version: 3.1.0\n    storage:\n      files:\n      - contents:\n          source: data:,{{ -a%20always%2Cexit%20-F%20arch%3Db64%20-S%20stime%20-k%20audit_time_rules%0A-a%20always%2Cexit%20-F%20arch%3Db32%20-S%20stime%20-k%20audit_time_rules%0A }}\n        mode: 0600\n        path: /etc/audit/rules.d/75-syscall-stime.rules\n        overwrite: true\n"
				},
				{
					"remediation_id": "audit_rules_time_stime",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# Retrieve hardware architecture of the underlying system\n[ \"$(getconf LONG_BIT)\" = \"32\" ] && RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\")\n\nfor ARCH in \"${RULE_ARCHS[@]}\"\ndo\n    # Create expected audit group and audit rule form for particular system call & architecture\n    if [ ${ARCH} = \"b32\" ]\n    then\n        ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n        # stime system call is known at 32-bit arch (see e.g \"$ ausyscall i386 stime\" 's output)\n        # so append it to the list of time group system calls to be audited\n        SYSCALL=\"adjtimex settimeofday stime\"\n        SYSCALL_GROUPING=\"adjtimex settimeofday stime\"\n    elif [ ${ARCH} = \"b64\" ]\n    then\n        ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"\n        # stime system call isn't known at 64-bit arch (see \"$ ausyscall x86_64 stime\" 's output)\n        # therefore don't add it to the list of time group system calls to be audited\n        SYSCALL=\"adjtimex settimeofday\"\n        SYSCALL_GROUPING=\"adjtimex settimeofday\"\n    fi\n    OTHER_FILTERS=\"\"\n    AUID_FILTERS=\"\"\n    KEY=\"audit_time_rules\"\n    # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n    unset syscall_a\n    unset syscall_grouping\n    unset syscall_string\n    unset syscall\n    unset file_to_edit\n    unset rule_to_edit\n    unset rule_syscalls_to_edit\n    unset other_string\n    unset auid_string\n    unset full_rule\n\n    # Load macro arguments into arrays\n    read -a syscall_a <<< $SYSCALL\n    read -a syscall_grouping <<< $SYSCALL_GROUPING\n\n    # Create a list of audit *.rules files that should be inspected for presence and correctness\n    # of a particular audit rule. The scheme is as follows:\n    #\n    # -----------------------------------------------------------------------------------------\n    #  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n    # -----------------------------------------------------------------------------------------\n    #        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n    # -----------------------------------------------------------------------------------------\n    #        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n    #        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n    # -----------------------------------------------------------------------------------------\n    #\n    files_to_inspect=()\n\n\n    # If audit tool is 'augenrules', then check if the audit rule is defined\n    # If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection\n    # If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection\n    default_file=\"/etc/audit/rules.d/$KEY.rules\"\n    # As other_filters may include paths, lets use a different delimiter for it\n    # The \"F\" script expression tells sed to print the filenames where the expressions matched\n    readarray -t files_to_inspect < <(sed -s -n -e \"/^$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules)\n    # Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet\n    if [ ${#files_to_inspect[@]} -eq \"0\" ]\n    then\n        file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\"\n        files_to_inspect=(\"$file_to_inspect\")\n        if [ ! -e \"$file_to_inspect\" ]\n        then\n            touch \"$file_to_inspect\"\n            chmod 0640 \"$file_to_inspect\"\n        fi\n    fi\n\n    # After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\n    skip=1\n\n    for audit_file in \"${files_to_inspect[@]}\"\n    do\n        # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n        # i.e, collect rules that match:\n        # * the action, list and arch, (2-nd argument)\n        # * the other filters, (3-rd argument)\n        # * the auid filters, (4-rd argument)\n        readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n        candidate_rules=()\n        # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n        for s_rule in \"${similar_rules[@]}\"\n        do\n            # Strip all the options and fields we know of,\n            # than check if there was any field left over\n            extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n            grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n        done\n\n        if [[ ${#syscall_a[@]} -ge 1 ]]\n        then\n            # Check if the syscall we want is present in any of the similar existing rules\n            for rule in \"${candidate_rules[@]}\"\n            do\n                rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n                all_syscalls_found=0\n                for syscall in \"${syscall_a[@]}\"\n                do\n                    grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                       # A syscall was not found in the candidate rule\n                       all_syscalls_found=1\n                       }\n                done\n                if [[ $all_syscalls_found -eq 0 ]]\n                then\n                    # We found a rule with all the syscall(s) we want; skip rest of macro\n                    skip=0\n                    break\n                fi\n\n                # Check if this rule can be grouped with our target syscall and keep track of it\n                for syscall_g in \"${syscall_grouping[@]}\"\n                do\n                    if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                    then\n                        file_to_edit=${audit_file}\n                        rule_to_edit=${rule}\n                        rule_syscalls_to_edit=${rule_syscalls}\n                    fi\n                done\n            done\n        else\n            # If there is any candidate rule, it is compliant; skip rest of macro\n            if [ \"${#candidate_rules[@]}\" -gt 0 ]\n            then\n                skip=0\n            fi\n        fi\n\n        if [ \"$skip\" -eq 0 ]; then\n            break\n        fi\n    done\n\n    if [ \"$skip\" -ne 0 ]; then\n        # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n        # At this point we know if we need to either append the $full_rule or group\n        # the syscall together with an exsiting rule\n\n        # Append the full_rule if it cannot be grouped to any other rule\n        if [ -z ${rule_to_edit+x} ]\n        then\n            # Build full_rule while avoid adding double spaces when other_filters is empty\n            if [ \"${#syscall_a[@]}\" -gt 0 ]\n            then\n                syscall_string=\"\"\n                for syscall in \"${syscall_a[@]}\"\n                do\n                    syscall_string+=\" -S $syscall\"\n                done\n            fi\n            other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n            auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n            full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n            echo \"$full_rule\" >> \"$default_file\"\n            chmod o-rwx ${default_file}\n        else\n            # Check if the syscalls are declared as a comma separated list or\n            # as multiple -S parameters\n            if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n            then\n                delimiter=\",\"\n            else\n                delimiter=\" -S \"\n            fi\n            new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n                   # A syscall was not found in the candidate rule\n                   new_grouped_syscalls+=\"${delimiter}${syscall}\"\n                   }\n            done\n\n            # Group the syscall in the rule\n            sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n        fi\n    fi\n    unset syscall_a\n    unset syscall_grouping\n    unset syscall_string\n    unset syscall\n    unset file_to_edit\n    unset rule_to_edit\n    unset rule_syscalls_to_edit\n    unset other_string\n    unset auid_string\n    unset full_rule\n\n    # Load macro arguments into arrays\n    read -a syscall_a <<< $SYSCALL\n    read -a syscall_grouping <<< $SYSCALL_GROUPING\n\n    # Create a list of audit *.rules files that should be inspected for presence and correctness\n    # of a particular audit rule. The scheme is as follows:\n    #\n    # -----------------------------------------------------------------------------------------\n    #  Tool used to load audit rules | Rule already defined  |  Audit rules file to inspect    |\n    # -----------------------------------------------------------------------------------------\n    #        auditctl                |     Doesn't matter    |  /etc/audit/audit.rules         |\n    # -----------------------------------------------------------------------------------------\n    #        augenrules              |          Yes          |  /etc/audit/rules.d/*.rules     |\n    #        augenrules              |          No           |  /etc/audit/rules.d/$key.rules  |\n    # -----------------------------------------------------------------------------------------\n    #\n    files_to_inspect=()\n\n\n\n    # If audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n    # file to the list of files to be inspected\n    default_file=\"/etc/audit/audit.rules\"\n    files_to_inspect+=('/etc/audit/audit.rules' )\n\n    # After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead\n    skip=1\n\n    for audit_file in \"${files_to_inspect[@]}\"\n    do\n        # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern,\n        # i.e, collect rules that match:\n        # * the action, list and arch, (2-nd argument)\n        # * the other filters, (3-rd argument)\n        # * the auid filters, (4-rd argument)\n        readarray -t similar_rules < <(sed -e \"/^$ACTION_ARCH_FILTERS/!d\"  -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\")\n\n        candidate_rules=()\n        # Filter out rules that have more fields then required. This will remove rules more specific than the required scope\n        for s_rule in \"${similar_rules[@]}\"\n        do\n            # Strip all the options and fields we know of,\n            # than check if there was any field left over\n            extra_fields=$(sed -E -e \"s/^$ACTION_ARCH_FILTERS//\"  -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"<<< \"$s_rule\")\n            grep -q -- \"-F\" <<< \"$extra_fields\" || candidate_rules+=(\"$s_rule\")\n        done\n\n        if [[ ${#syscall_a[@]} -ge 1 ]]\n        then\n            # Check if the syscall we want is present in any of the similar existing rules\n            for rule in \"${candidate_rules[@]}\"\n            do\n                rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs)\n                all_syscalls_found=0\n                for syscall in \"${syscall_a[@]}\"\n                do\n                    grep -q -- \"\\b${syscall}\\b\" <<< \"$rule_syscalls\" || {\n                       # A syscall was not found in the candidate rule\n                       all_syscalls_found=1\n                       }\n                done\n                if [[ $all_syscalls_found -eq 0 ]]\n                then\n                    # We found a rule with all the syscall(s) we want; skip rest of macro\n                    skip=0\n                    break\n                fi\n\n                # Check if this rule can be grouped with our target syscall and keep track of it\n                for syscall_g in \"${syscall_grouping[@]}\"\n                do\n                    if grep -q -- \"\\b${syscall_g}\\b\" <<< \"$rule_syscalls\"\n                    then\n                        file_to_edit=${audit_file}\n                        rule_to_edit=${rule}\n                        rule_syscalls_to_edit=${rule_syscalls}\n                    fi\n                done\n            done\n        else\n            # If there is any candidate rule, it is compliant; skip rest of macro\n            if [ \"${#candidate_rules[@]}\" -gt 0 ]\n            then\n                skip=0\n            fi\n        fi\n\n        if [ \"$skip\" -eq 0 ]; then\n            break\n        fi\n    done\n\n    if [ \"$skip\" -ne 0 ]; then\n        # We checked all rules that matched the expected resemblance pattern (action, arch & auid)\n        # At this point we know if we need to either append the $full_rule or group\n        # the syscall together with an exsiting rule\n\n        # Append the full_rule if it cannot be grouped to any other rule\n        if [ -z ${rule_to_edit+x} ]\n        then\n            # Build full_rule while avoid adding double spaces when other_filters is empty\n            if [ \"${#syscall_a[@]}\" -gt 0 ]\n            then\n                syscall_string=\"\"\n                for syscall in \"${syscall_a[@]}\"\n                do\n                    syscall_string+=\" -S $syscall\"\n                done\n            fi\n            other_string=$([[ $OTHER_FILTERS ]] && echo \" $OTHER_FILTERS\") || /bin/true\n            auid_string=$([[ $AUID_FILTERS ]] && echo \" $AUID_FILTERS\") || /bin/true\n            full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" || /bin/true\n            echo \"$full_rule\" >> \"$default_file\"\n            chmod o-rwx ${default_file}\n        else\n            # Check if the syscalls are declared as a comma separated list or\n            # as multiple -S parameters\n            if grep -q -- \",\" <<< \"${rule_syscalls_to_edit}\"\n            then\n                delimiter=\",\"\n            else\n                delimiter=\" -S \"\n            fi\n            new_grouped_syscalls=\"${rule_syscalls_to_edit}\"\n            for syscall in \"${syscall_a[@]}\"\n            do\n                grep -q -- \"\\b${syscall}\\b\" <<< \"${rule_syscalls_to_edit}\" || {\n                   # A syscall was not found in the candidate rule\n                   new_grouped_syscalls+=\"${delimiter}${syscall}\"\n                   }\n            done\n\n            # Group the syscall in the rule\n            sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\"\n        fi\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_time_stime",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83835-9\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.4.2.b\n  - audit_rules_time_stime\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Perform remediation of Audit rules for stime syscall for x86 platform\n  block:\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - stime\n      syscall_grouping:\n      - adjtimex\n      - settimeofday\n      - stime\n\n  - name: Check existence of stime in /etc/audit/rules.d/\n    find:\n      paths: /etc/audit/rules.d\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: '*.rules'\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Reset syscalls found per file\n    set_fact:\n      syscalls_per_file: {}\n      found_paths_dict: {}\n\n  - name: Declare syscalls found per file\n    set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path\n      :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\"\n    loop: '{{ find_command.results | selectattr(''matched'') | list }}'\n\n  - name: Declare files where syscalls were found\n    set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten\n      | map(attribute='path') | list }}\"\n\n  - name: Count occurrences of syscalls in paths\n    set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item,\n      0) }) }}\"\n    loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'')\n      | list }}'\n\n  - name: Get path with most syscalls\n    set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value')\n      | last).key }}\"\n    when: found_paths | length >= 1\n\n  - name: No file with syscall found, set path to /etc/audit/rules.d/audit_time_rules.rules\n    set_fact: audit_file=\"/etc/audit/rules.d/audit_time_rules.rules\"\n    when: found_paths | length == 0\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file]\n        | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_time_rules\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n\n  - name: Declare list of syscalls\n    set_fact:\n      syscalls:\n      - stime\n      syscall_grouping:\n      - adjtimex\n      - settimeofday\n      - stime\n\n  - name: Check existence of stime in /etc/audit/audit.rules\n    find:\n      paths: /etc/audit\n      contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S\n        |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$\n      patterns: audit.rules\n    register: find_command\n    loop: '{{ (syscall_grouping + syscalls) | unique }}'\n\n  - name: Set path to /etc/audit/audit.rules\n    set_fact: audit_file=\"/etc/audit/audit.rules\"\n\n  - name: Declare found syscalls\n    set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item')\n      | list }}\"\n\n  - name: Declare missing syscalls\n    set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\"\n\n  - name: Replace the audit rule in {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found |\n        join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+)\n      line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4\n      backrefs: true\n      state: present\n    when: syscalls_found | length > 0 and missing_syscalls | length > 0\n\n  - name: Add the audit rule to {{ audit_file }}\n    lineinfile:\n      path: '{{ audit_file }}'\n      line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_time_rules\n      create: true\n      mode: o-rwx\n      state: present\n    when: syscalls_found | length == 0\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83835-9\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.4.2.b\n  - audit_rules_time_stime\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_audit_rules_time_watch_localtime": {
			"rule_id": "xccdf_org.ssgproject.content_rule_audit_rules_time_watch_localtime",
			"title": "Record Attempts to Alter the localtime File",
			"result": "fail",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83839-1"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"9",
				"5.4.1.1",
				"APO10.01",
				"APO10.03",
				"APO10.04",
				"APO10.05",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI08.02",
				"DSS01.03",
				"DSS01.04",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS03.05",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"DSS05.05",
				"DSS05.07",
				"MEA01.01",
				"MEA01.02",
				"MEA01.03",
				"MEA01.04",
				"MEA01.05",
				"MEA02.01",
				"3.1.7",
				"CCI-001487",
				"CCI-000169",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(3)(ii)(A)",
				"164.308(a)(5)(ii)(C)",
				"164.312(a)(2)(i)",
				"164.312(b)",
				"164.312(d)",
				"164.312(e)",
				"4.2.3.10",
				"4.3.2.6.7",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.3.6.6",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 1.13",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.6",
				"SR 2.8",
				"SR 2.9",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 6.1",
				"SR 6.2",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.6",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.14.2.7",
				"A.15.2.1",
				"A.15.2.2",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.6.2.1",
				"A.6.2.2",
				"AU-2(d)",
				"AU-12(c)",
				"AC-6(9)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"DE.CM-1",
				"DE.CM-3",
				"DE.CM-7",
				"ID.SC-4",
				"PR.AC-3",
				"PR.PT-1",
				"PR.PT-4",
				"RS.AN-1",
				"RS.AN-4",
				"Req-10.4.2.b"
			],
			"description": "If the <code>auditd</code> daemon is configured to use the\n<code>augenrules</code> program to read audit rules during daemon startup (the default),\nadd the following line to a file with suffix <code>.rules</code> in the directory\n<code>/etc/audit/rules.d</code>:\n<pre>-w /etc/localtime -p wa -k audit_time_rules</pre>\nIf the <code>auditd</code> daemon is configured to use the <code>auditctl</code>\nutility to read audit rules during daemon startup, add the following line to\n<code>/etc/audit/audit.rules</code> file:\n<pre>-w /etc/localtime -p wa -k audit_time_rules</pre>\nThe -k option allows for the specification of a key in string form that can\nbe used for better reporting capability through ausearch and aureport and\nshould always be used.",
			"rationale": "Arbitrary changes to the system time can be used to obfuscate\nnefarious activities in log files, as well as to confuse network services that\nare highly dependent upon an accurate system time (such as sshd). All changes\nto the system time should be audited.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-audit_rules_time_watch_localtime:def:1",
			"remediations": [
				{
					"remediation_id": "audit_rules_time_watch_localtime",
					"system": "urn:xccdf:fix:script:kubernetes",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "---\napiVersion: machineconfiguration.openshift.io/v1\nkind: MachineConfig\nspec:\n  config:\n    ignition:\n      version: 3.1.0\n    storage:\n      files:\n      - contents:\n          source: data:,{{ -w%20/etc/localtime%20-p%20wa%20-k%20audit_time_rules%0A }}\n        mode: 0600\n        path: /etc/audit/rules.d/75-etclocaltime-wa-audit_time_rules.rules\n        overwrite: true\n"
				},
				{
					"remediation_id": "audit_rules_time_watch_localtime",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\n# Perform the remediation for both possible tools: 'auditctl' and 'augenrules'\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n\n# If the audit tool is 'auditctl', then add '/etc/audit/audit.rules'\n# into the list of files to be inspected\nfiles_to_inspect+=('/etc/audit/audit.rules')\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/localtime\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/localtime $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/localtime$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/localtime -p wa -k audit_time_rules\" >> \"$audit_rules_file\"\n    fi\ndone\n# Create a list of audit *.rules files that should be inspected for presence and correctness\n# of a particular audit rule. The scheme is as follows:\n#\n# -----------------------------------------------------------------------------------------\n# Tool used to load audit rules\t| Rule already defined\t|  Audit rules file to inspect\t  |\n# -----------------------------------------------------------------------------------------\n#\tauditctl\t\t|     Doesn't matter\t|  /etc/audit/audit.rules\t  |\n# -----------------------------------------------------------------------------------------\n# \taugenrules\t\t|          Yes\t\t|  /etc/audit/rules.d/*.rules\t  |\n# \taugenrules\t\t|          No\t\t|  /etc/audit/rules.d/$key.rules  |\n# -----------------------------------------------------------------------------------------\nfiles_to_inspect=()\n\n# If the audit is 'augenrules', then check if rule is already defined\n# If rule is defined, add '/etc/audit/rules.d/*.rules' to list of files for inspection.\n# If rule isn't defined, add '/etc/audit/rules.d/audit_time_rules.rules' to list of files for inspection.\nreadarray -t matches < <(grep -HP \"[\\s]*-w[\\s]+/etc/localtime\" /etc/audit/rules.d/*.rules)\n\n# For each of the matched entries\nfor match in \"${matches[@]}\"\ndo\n    # Extract filepath from the match\n    rulesd_audit_file=$(echo $match | cut -f1 -d ':')\n    # Append that path into list of files for inspection\n    files_to_inspect+=(\"$rulesd_audit_file\")\ndone\n# Case when particular audit rule isn't defined yet\nif [ \"${#files_to_inspect[@]}\" -eq \"0\" ]\nthen\n    # Append '/etc/audit/rules.d/audit_time_rules.rules' into list of files for inspection\n    key_rule_file=\"/etc/audit/rules.d/audit_time_rules.rules\"\n    # If the audit_time_rules.rules file doesn't exist yet, create it with correct permissions\n    if [ ! -e \"$key_rule_file\" ]\n    then\n        touch \"$key_rule_file\"\n        chmod 0640 \"$key_rule_file\"\n    fi\n    files_to_inspect+=(\"$key_rule_file\")\nfi\n\n# Finally perform the inspection and possible subsequent audit rule\n# correction for each of the files previously identified for inspection\nfor audit_rules_file in \"${files_to_inspect[@]}\"\ndo\n    # Check if audit watch file system object rule for given path already present\n    if grep -q -P -- \"^[\\s]*-w[\\s]+/etc/localtime\" \"$audit_rules_file\"\n    then\n        # Rule is found => verify yet if existing rule definition contains\n        # all of the required access type bits\n\n        # Define BRE whitespace class shortcut\n        sp=\"[[:space:]]\"\n        # Extract current permission access types (e.g. -p [r|w|x|a] values) from audit rule\n        current_access_bits=$(sed -ne \"s#$sp*-w$sp\\+/etc/localtime $sp\\+-p$sp\\+\\([rxwa]\\{1,4\\}\\).*#\\1#p\" \"$audit_rules_file\")\n        # Split required access bits string into characters array\n        # (to check bit's presence for one bit at a time)\n        for access_bit in $(echo \"wa\" | grep -o .)\n        do\n            # For each from the required access bits (e.g. 'w', 'a') check\n            # if they are already present in current access bits for rule.\n            # If not, append that bit at the end\n            if ! grep -q \"$access_bit\" <<< \"$current_access_bits\"\n            then\n                # Concatenate the existing mask with the missing bit\n                current_access_bits=\"$current_access_bits$access_bit\"\n            fi\n        done\n        # Propagate the updated rule's access bits (original + the required\n        # ones) back into the /etc/audit/audit.rules file for that rule\n        sed -i \"s#\\($sp*-w$sp\\+/etc/localtime$sp\\+-p$sp\\+\\)\\([rxwa]\\{1,4\\}\\)\\(.*\\)#\\1$current_access_bits\\3#\" \"$audit_rules_file\"\n    else\n        # Rule isn't present yet. Append it at the end of $audit_rules_file file\n        # with proper key\n\n        echo \"-w /etc/localtime -p wa -k audit_time_rules\" >> \"$audit_rules_file\"\n    fi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "audit_rules_time_watch_localtime",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83839-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.4.2.b\n  - audit_rules_time_watch_localtime\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Check if watch rule for /etc/localtime already exists in /etc/audit/rules.d/\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^\\s*-w\\s+/etc/localtime\\s+-p\\s+wa(\\s|$)+\n    patterns: '*.rules'\n  register: find_existing_watch_rules_d\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83839-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.4.2.b\n  - audit_rules_time_watch_localtime\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Search /etc/audit/rules.d for other rules with specified key audit_time_rules\n  find:\n    paths: /etc/audit/rules.d\n    contains: ^.*(?:-F key=|-k\\s+)audit_time_rules$\n    patterns: '*.rules'\n  register: find_watch_key\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CCE-83839-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.4.2.b\n  - audit_rules_time_watch_localtime\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Use /etc/audit/rules.d/audit_time_rules.rules as the recipient for the rule\n  set_fact:\n    all_files:\n    - /etc/audit/rules.d/audit_time_rules.rules\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CCE-83839-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.4.2.b\n  - audit_rules_time_watch_localtime\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Use matched file as the recipient for the rule\n  set_fact:\n    all_files:\n    - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched\n    is defined and find_existing_watch_rules_d.matched == 0\n  tags:\n  - CCE-83839-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.4.2.b\n  - audit_rules_time_watch_localtime\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Add watch rule for /etc/localtime in /etc/audit/rules.d/\n  lineinfile:\n    path: '{{ all_files[0] }}'\n    line: -w /etc/localtime -p wa -k audit_time_rules\n    create: true\n    mode: '0640'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched\n    == 0\n  tags:\n  - CCE-83839-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.4.2.b\n  - audit_rules_time_watch_localtime\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Check if watch rule for /etc/localtime already exists in /etc/audit/audit.rules\n  find:\n    paths: /etc/audit/\n    contains: ^\\s*-w\\s+/etc/localtime\\s+-p\\s+wa(\\s|$)+\n    patterns: audit.rules\n  register: find_existing_watch_audit_rules\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83839-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.4.2.b\n  - audit_rules_time_watch_localtime\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n\n- name: Add watch rule for /etc/localtime in /etc/audit/audit.rules\n  lineinfile:\n    line: -w /etc/localtime -p wa -k audit_time_rules\n    state: present\n    dest: /etc/audit/audit.rules\n    create: true\n    mode: '0640'\n  when:\n  - '\"audit\" in ansible_facts.packages'\n  - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched\n    == 0\n  tags:\n  - CCE-83839-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.1.7\n  - NIST-800-53-AC-6(9)\n  - NIST-800-53-AU-12(c)\n  - NIST-800-53-AU-2(d)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.4.2.b\n  - audit_rules_time_watch_localtime\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_auditd_audispd_syslog_plugin_activated": {
			"rule_id": "xccdf_org.ssgproject.content_rule_auditd_audispd_syslog_plugin_activated",
			"title": "Configure auditd to use audispd's syslog plugin",
			"result": "fail",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83695-7"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"5.4.1.1",
				"APO11.04",
				"APO12.06",
				"BAI03.05",
				"BAI08.02",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS05.04",
				"DSS05.07",
				"MEA02.01",
				"3.3.1",
				"CCI-000136",
				"164.308(a)(1)(ii)(D)",
				"164.308(a)(5)(ii)(B)",
				"164.308(a)(5)(ii)(C)",
				"164.308(a)(6)(ii)",
				"164.308(a)(8)",
				"164.310(d)(2)(iii)",
				"164.312(b)",
				"164.314(a)(2)(i)(C)",
				"164.314(a)(2)(iii)",
				"4.2.3.10",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.8",
				"SR 2.9",
				"SR 6.1",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"AU-4(1)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"PR.PT-1",
				"RS.AN-1",
				"RS.AN-4",
				"FAU_GEN.1.1.c",
				"Req-10.5.3",
				"SRG-OS-000479-GPOS-00224",
				"SRG-OS-000342-GPOS-00133",
				"SRG-OS-000051-VMM-000230",
				"SRG-OS-000058-VMM-000270",
				"SRG-OS-000059-VMM-000280",
				"SRG-OS-000479-VMM-001990",
				"SRG-OS-000479-VMM-001990"
			],
			"description": "To configure the <code>auditd</code> service to use the\n<code>syslog</code> plug-in of the <code>audispd</code> audit event multiplexor, set\nthe <code>active</code> line in <code>/etc/audit/plugins.d/syslog.conf</code> to <code>yes</code>.\nRestart the <code>auditd</code> service:\n<pre>$ sudo service auditd restart</pre>",
			"rationale": "The auditd service does not include the ability to send audit\nrecords to a centralized server for management directly. It does, however,\ninclude a plug-in for audit event multiplexor (audispd) to pass audit records\nto the local syslog server.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-auditd_audispd_syslog_plugin_activated:def:1",
			"remediations": [
				{
					"remediation_id": "auditd_audispd_syslog_plugin_activated",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\nvar_syslog_active=\"yes\"\n\nAUDISP_SYSLOGCONFIG=/etc/audit/plugins.d/syslog.conf\n\n# Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed.\n# Otherwise, regular sed command will do.\nsed_command=('sed' '-i')\nif test -L \"$AUDISP_SYSLOGCONFIG\"; then\n    sed_command+=('--follow-symlinks')\nfi\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^active\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_syslog_active\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^active\\\\>\" \"$AUDISP_SYSLOGCONFIG\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    \"${sed_command[@]}\" \"s/^active\\\\>.*/$escaped_formatted_output/gi\" \"$AUDISP_SYSLOGCONFIG\"\nelse\n    # \\n is precaution for case where file ends without trailing newline\n    cce=\"CCE-83695-7\"\n    printf '\\n# Per %s: Set %s in %s\\n' \"$cce\" \"$formatted_output\" \"$AUDISP_SYSLOGCONFIG\" >> \"$AUDISP_SYSLOGCONFIG\"\n    printf '%s\\n' \"$formatted_output\" >> \"$AUDISP_SYSLOGCONFIG\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "auditd_audispd_syslog_plugin_activated",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83695-7\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.3.1\n  - NIST-800-53-AU-4(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.3\n  - auditd_audispd_syslog_plugin_activated\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: enable syslog plugin\n  lineinfile:\n    dest: /etc/audit/plugins.d/syslog.conf\n    regexp: ^active\n    line: active = yes\n    create: true\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83695-7\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.3.1\n  - NIST-800-53-AU-4(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.3\n  - auditd_audispd_syslog_plugin_activated\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_auditd_data_retention_action_mail_acct": {
			"rule_id": "xccdf_org.ssgproject.content_rule_auditd_data_retention_action_mail_acct",
			"title": "Configure auditd mail_acct Action on Low Disk Space",
			"result": "fail",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83698-1"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"5.4.1.1",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI04.04",
				"BAI08.02",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS05.04",
				"DSS05.07",
				"MEA02.01",
				"3.3.1",
				"CCI-000139",
				"CCI-001855",
				"164.312(a)(2)(ii)",
				"4.2.3.10",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.8",
				"SR 2.9",
				"SR 6.1",
				"SR 7.1",
				"SR 7.2",
				"A.12.1.3",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.17.2.1",
				"CIP-003-8 R1.3",
				"CIP-003-8 R3",
				"CIP-003-8 R3.1",
				"CIP-003-8 R3.2",
				"CIP-003-8 R3.3",
				"CIP-003-8 R5.1.1",
				"CIP-003-8 R5.3",
				"CIP-004-6 R2.2.3",
				"CIP-004-6 R2.3",
				"CIP-007-3 R5.1",
				"CIP-007-3 R5.1.2",
				"CIP-007-3 R5.2",
				"CIP-007-3 R5.3.1",
				"CIP-007-3 R5.3.2",
				"CIP-007-3 R5.3.3",
				"IA-5(1)",
				"AU-5(a)",
				"AU-5(2)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"PR.DS-4",
				"PR.PT-1",
				"RS.AN-1",
				"RS.AN-4",
				"Req-10.7.a",
				"SRG-OS-000046-GPOS-00022",
				"SRG-OS-000343-GPOS-00134",
				"SRG-OS-000046-VMM-000210",
				"SRG-OS-000343-VMM-001240"
			],
			"description": "The <code>auditd</code> service can be configured to send email to\na designated account in certain situations. Add or correct the following line\nin <code>/etc/audit/auditd.conf</code> to ensure that administrators are notified\nvia email for those situations:\n<pre>action_mail_acct = root</pre>",
			"rationale": "Email sent to the root account is typically aliased to the\nadministrators of the system, who can take appropriate action.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-auditd_data_retention_action_mail_acct:def:1",
			"remediations": [
				{
					"remediation_id": "auditd_data_retention_action_mail_acct",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\nvar_auditd_action_mail_acct='root'\n\n\nAUDITCONFIG=/etc/audit/auditd.conf\n\n# Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed.\n# Otherwise, regular sed command will do.\nsed_command=('sed' '-i')\nif test -L \"$AUDITCONFIG\"; then\n    sed_command+=('--follow-symlinks')\nfi\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^action_mail_acct\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_auditd_action_mail_acct\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^action_mail_acct\\\\>\" \"$AUDITCONFIG\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    \"${sed_command[@]}\" \"s/^action_mail_acct\\\\>.*/$escaped_formatted_output/gi\" \"$AUDITCONFIG\"\nelse\n    # \\n is precaution for case where file ends without trailing newline\n    cce=\"CCE-83698-1\"\n    printf '\\n# Per %s: Set %s in %s\\n' \"$cce\" \"$formatted_output\" \"$AUDITCONFIG\" >> \"$AUDITCONFIG\"\n    printf '%s\\n' \"$formatted_output\" >> \"$AUDITCONFIG\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "auditd_data_retention_action_mail_acct",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83698-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.3.1\n  - NIST-800-53-AU-5(2)\n  - NIST-800-53-AU-5(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)\n  - PCI-DSS-Req-10.7.a\n  - auditd_data_retention_action_mail_acct\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_auditd_action_mail_acct # promote to variable\n  set_fact:\n    var_auditd_action_mail_acct: !!str root\n  tags:\n    - always\n\n- name: Configure auditd mail_acct Action on Low Disk Space\n  lineinfile:\n    dest: /etc/audit/auditd.conf\n    line: action_mail_acct = {{ var_auditd_action_mail_acct }}\n    state: present\n    create: true\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83698-1\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.3.1\n  - NIST-800-53-AU-5(2)\n  - NIST-800-53-AU-5(a)\n  - NIST-800-53-CM-6(a)\n  - NIST-800-53-IA-5(1)\n  - PCI-DSS-Req-10.7.a\n  - auditd_data_retention_action_mail_acct\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_auditd_data_retention_admin_space_left_action": {
			"rule_id": "xccdf_org.ssgproject.content_rule_auditd_data_retention_admin_space_left_action",
			"title": "Configure auditd admin_space_left Action on Low Disk Space",
			"result": "fail",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83700-5"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"5.4.1.1",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI04.04",
				"BAI08.02",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS05.04",
				"DSS05.07",
				"MEA02.01",
				"3.3.1",
				"CCI-000140",
				"CCI-001343",
				"CCI-001855",
				"164.312(a)(2)(ii)",
				"4.2.3.10",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.8",
				"SR 2.9",
				"SR 6.1",
				"SR 7.1",
				"SR 7.2",
				"A.12.1.3",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.17.2.1",
				"AU-5(b)",
				"AU-5(2)",
				"AU-5(1)",
				"AU-5(4)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"PR.DS-4",
				"PR.PT-1",
				"RS.AN-1",
				"RS.AN-4",
				"Req-10.7",
				"SRG-OS-000343-GPOS-00134"
			],
			"description": "The <code>auditd</code> service can be configured to take an action\nwhen disk space is running low but prior to running out of space completely.\nEdit the file <code>/etc/audit/auditd.conf</code>. Add or modify the following line,\nsubstituting <i>ACTION</i> appropriately:\n<pre>admin_space_left_action = <i>ACTION</i></pre>\nSet this value to <code>single</code> to cause the system to switch to single user\nmode for corrective action. Acceptable values also include <code>suspend</code> and\n<code>halt</code>. For certain systems, the need for availability\noutweighs the need to log all actions, and a different setting should be\ndetermined. Details regarding all possible values for <i>ACTION</i> are described in the\n<code>auditd.conf</code> man page.",
			"rationale": "Administrators should be made aware of an inability to record\naudit records. If a separate partition or logical volume of adequate size\nis used, running low on space for audit records should never occur.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-auditd_data_retention_admin_space_left_action:def:1",
			"remediations": [
				{
					"remediation_id": "auditd_data_retention_admin_space_left_action",
					"system": "urn:xccdf:fix:script:kubernetes",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "---\napiVersion: machineconfiguration.openshift.io/v1\nkind: MachineConfig\nspec:\n  config:\n    ignition:\n      version: 3.1.0\n    storage:\n      files:\n      - contents:\n          source: data:,{{ %23%0A%23%20This%20file%20controls%20the%20configuration%20of%20the%20audit%20daemon%0A%23%0A%0Alocal_events%20%3D%20yes%0Awrite_logs%20%3D%20yes%0Alog_file%20%3D%20/var/log/audit/audit.log%0Alog_group%20%3D%20root%0Alog_format%20%3D%20ENRICHED%0Aflush%20%3D%20%7B%7B.var_auditd_flush%7D%7D%0Afreq%20%3D%2050%0Amax_log_file%20%3D%20%7B%7B.var_auditd_max_log_file%7D%7D%0Anum_logs%20%3D%20%7B%7B.var_auditd_num_logs%7D%7D%0Apriority_boost%20%3D%204%0Aname_format%20%3D%20hostname%0A%23%23name%20%3D%20mydomain%0Amax_log_file_action%20%3D%20%7B%7B.var_auditd_max_log_file_action%7D%7D%0Aspace_left%20%3D%20%7B%7B.var_auditd_space_left%7D%7D%0Aspace_left_action%20%3D%20%7B%7B.var_auditd_space_left_action%7D%7D%0Averify_email%20%3D%20yes%0Aaction_mail_acct%20%3D%20%7B%7B.var_auditd_action_mail_acct%7D%7D%0Aadmin_space_left%20%3D%2050%0Aadmin_space_left_action%20%3D%20syslog%0Adisk_full_action%20%3D%20%7B%7B.var_auditd_disk_full_action%7D%7D%0Adisk_error_action%20%3D%20%7B%7B.var_auditd_disk_error_action%7D%7D%0Ause_libwrap%20%3D%20yes%0A%23%23tcp_listen_port%20%3D%2060%0Atcp_listen_queue%20%3D%205%0Atcp_max_per_addr%20%3D%201%0A%23%23tcp_client_ports%20%3D%201024-65535%0Atcp_client_max_idle%20%3D%200%0Atransport%20%3D%20TCP%0Akrb5_principal%20%3D%20auditd%0A%23%23krb5_key_file%20%3D%20/etc/audit/audit.key%0Adistribute_network%20%3D%20no%0Aq_depth%20%3D%20400%0Aoverflow_action%20%3D%20syslog%0Amax_restarts%20%3D%2010%0Aplugin_dir%20%3D%20/etc/audit/plugins.d }}\n        mode: 0640\n        path: /etc/audit/auditd.conf\n        overwrite: true\n"
				},
				{
					"remediation_id": "auditd_data_retention_admin_space_left_action",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\nvar_auditd_admin_space_left_action='single'\n\n\nAUDITCONFIG=/etc/audit/auditd.conf\n\n# Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed.\n# Otherwise, regular sed command will do.\nsed_command=('sed' '-i')\nif test -L \"$AUDITCONFIG\"; then\n    sed_command+=('--follow-symlinks')\nfi\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^admin_space_left_action\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_auditd_admin_space_left_action\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^admin_space_left_action\\\\>\" \"$AUDITCONFIG\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    \"${sed_command[@]}\" \"s/^admin_space_left_action\\\\>.*/$escaped_formatted_output/gi\" \"$AUDITCONFIG\"\nelse\n    # \\n is precaution for case where file ends without trailing newline\n    cce=\"CCE-83700-5\"\n    printf '\\n# Per %s: Set %s in %s\\n' \"$cce\" \"$formatted_output\" \"$AUDITCONFIG\" >> \"$AUDITCONFIG\"\n    printf '%s\\n' \"$formatted_output\" >> \"$AUDITCONFIG\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "auditd_data_retention_admin_space_left_action",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83700-5\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.3.1\n  - NIST-800-53-AU-5(1)\n  - NIST-800-53-AU-5(2)\n  - NIST-800-53-AU-5(4)\n  - NIST-800-53-AU-5(b)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.7\n  - auditd_data_retention_admin_space_left_action\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_auditd_admin_space_left_action # promote to variable\n  set_fact:\n    var_auditd_admin_space_left_action: !!str single\n  tags:\n    - always\n\n- name: Configure auditd admin_space_left Action on Low Disk Space\n  lineinfile:\n    dest: /etc/audit/auditd.conf\n    line: admin_space_left_action = {{ var_auditd_admin_space_left_action }}\n    regexp: ^\\s*admin_space_left_action\\s*=\\s*.*$\n    state: present\n    create: true\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83700-5\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.3.1\n  - NIST-800-53-AU-5(1)\n  - NIST-800-53-AU-5(2)\n  - NIST-800-53-AU-5(4)\n  - NIST-800-53-AU-5(b)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.7\n  - auditd_data_retention_admin_space_left_action\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_auditd_data_retention_max_log_file": {
			"rule_id": "xccdf_org.ssgproject.content_rule_auditd_data_retention_max_log_file",
			"title": "Configure auditd Max Log File Size",
			"result": "fail",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83683-3"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"5.4.1.1",
				"APO11.04",
				"APO12.06",
				"BAI03.05",
				"BAI08.02",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS05.04",
				"DSS05.07",
				"MEA02.01",
				"4.2.3.10",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.8",
				"SR 2.9",
				"SR 6.1",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"CIP-004-6 R2.2.3",
				"CIP-004-6 R3.3",
				"CIP-007-3 R5.2",
				"CIP-007-3 R5.3.1",
				"CIP-007-3 R5.3.2",
				"CIP-007-3 R5.3.3",
				"CIP-007-3 R6.5",
				"AU-11",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"PR.PT-1",
				"RS.AN-1",
				"RS.AN-4",
				"Req-10.7"
			],
			"description": "Determine the amount of audit data (in megabytes)\nwhich should be retained in each log file. Edit the file\n<code>/etc/audit/auditd.conf</code>. Add or modify the following line, substituting\nthe correct value of 6 for <i>STOREMB</i>:\n<pre>max_log_file = <i>STOREMB</i></pre>\nSet the value to <code>6</code> (MB) or higher for general-purpose systems.\nLarger values, of course,\nsupport retention of even more audit data.",
			"rationale": "The total storage for audit log files must be large enough to retain\nlog information over the period required. This is a function of the maximum\nlog file size and the number of logs retained.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-auditd_data_retention_max_log_file:def:1",
			"remediations": [
				{
					"remediation_id": "auditd_data_retention_max_log_file",
					"system": "urn:xccdf:fix:script:kubernetes",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "---\napiVersion: machineconfiguration.openshift.io/v1\nkind: MachineConfig\nspec:\n  config:\n    ignition:\n      version: 3.1.0\n    storage:\n      files:\n      - contents:\n          source: data:,{{ %23%0A%23%20This%20file%20controls%20the%20configuration%20of%20the%20audit%20daemon%0A%23%0A%0Alocal_events%20%3D%20yes%0Awrite_logs%20%3D%20yes%0Alog_file%20%3D%20/var/log/audit/audit.log%0Alog_group%20%3D%20root%0Alog_format%20%3D%20ENRICHED%0Aflush%20%3D%20%7B%7B.var_auditd_flush%7D%7D%0Afreq%20%3D%2050%0Amax_log_file%20%3D%20%7B%7B.var_auditd_max_log_file%7D%7D%0Anum_logs%20%3D%20%7B%7B.var_auditd_num_logs%7D%7D%0Apriority_boost%20%3D%204%0Aname_format%20%3D%20hostname%0A%23%23name%20%3D%20mydomain%0Amax_log_file_action%20%3D%20%7B%7B.var_auditd_max_log_file_action%7D%7D%0Aspace_left%20%3D%20%7B%7B.var_auditd_space_left%7D%7D%0Aspace_left_action%20%3D%20%7B%7B.var_auditd_space_left_action%7D%7D%0Averify_email%20%3D%20yes%0Aaction_mail_acct%20%3D%20%7B%7B.var_auditd_action_mail_acct%7D%7D%0Aadmin_space_left%20%3D%2050%0Aadmin_space_left_action%20%3D%20syslog%0Adisk_full_action%20%3D%20%7B%7B.var_auditd_disk_full_action%7D%7D%0Adisk_error_action%20%3D%20%7B%7B.var_auditd_disk_error_action%7D%7D%0Ause_libwrap%20%3D%20yes%0A%23%23tcp_listen_port%20%3D%2060%0Atcp_listen_queue%20%3D%205%0Atcp_max_per_addr%20%3D%201%0A%23%23tcp_client_ports%20%3D%201024-65535%0Atcp_client_max_idle%20%3D%200%0Atransport%20%3D%20TCP%0Akrb5_principal%20%3D%20auditd%0A%23%23krb5_key_file%20%3D%20/etc/audit/audit.key%0Adistribute_network%20%3D%20no%0Aq_depth%20%3D%20400%0Aoverflow_action%20%3D%20syslog%0Amax_restarts%20%3D%2010%0Aplugin_dir%20%3D%20/etc/audit/plugins.d }}\n        mode: 0640\n        path: /etc/audit/auditd.conf\n        overwrite: true\n"
				},
				{
					"remediation_id": "auditd_data_retention_max_log_file",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\nvar_auditd_max_log_file='6'\n\n\nAUDITCONFIG=/etc/audit/auditd.conf\n\n# Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed.\n# Otherwise, regular sed command will do.\nsed_command=('sed' '-i')\nif test -L \"$AUDITCONFIG\"; then\n    sed_command+=('--follow-symlinks')\nfi\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^max_log_file\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_auditd_max_log_file\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^max_log_file\\\\>\" \"$AUDITCONFIG\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    \"${sed_command[@]}\" \"s/^max_log_file\\\\>.*/$escaped_formatted_output/gi\" \"$AUDITCONFIG\"\nelse\n    # \\n is precaution for case where file ends without trailing newline\n    cce=\"CCE-83683-3\"\n    printf '\\n# Per %s: Set %s in %s\\n' \"$cce\" \"$formatted_output\" \"$AUDITCONFIG\" >> \"$AUDITCONFIG\"\n    printf '%s\\n' \"$formatted_output\" >> \"$AUDITCONFIG\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "auditd_data_retention_max_log_file",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83683-3\n  - CJIS-5.4.1.1\n  - NIST-800-53-AU-11\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.7\n  - auditd_data_retention_max_log_file\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_auditd_max_log_file # promote to variable\n  set_fact:\n    var_auditd_max_log_file: !!str 6\n  tags:\n    - always\n\n- name: Configure auditd Max Log File Size\n  lineinfile:\n    dest: /etc/audit/auditd.conf\n    regexp: ^\\s*max_log_file\\s*=\\s*.*$\n    line: max_log_file = {{ var_auditd_max_log_file }}\n    state: present\n    create: true\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83683-3\n  - CJIS-5.4.1.1\n  - NIST-800-53-AU-11\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.7\n  - auditd_data_retention_max_log_file\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_auditd_data_retention_max_log_file_action": {
			"rule_id": "xccdf_org.ssgproject.content_rule_auditd_data_retention_max_log_file_action",
			"title": "Configure auditd max_log_file_action Upon Reaching Maximum Log Size",
			"result": "fail",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83701-3"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"5.4.1.1",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI04.04",
				"BAI08.02",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS05.04",
				"DSS05.07",
				"MEA02.01",
				"CCI-000140",
				"164.312(a)(2)(ii)",
				"4.2.3.10",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.8",
				"SR 2.9",
				"SR 6.1",
				"SR 7.1",
				"SR 7.2",
				"A.12.1.3",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.17.2.1",
				"AU-5(b)",
				"AU-5(2)",
				"AU-5(1)",
				"AU-5(4)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"PR.DS-4",
				"PR.PT-1",
				"RS.AN-1",
				"RS.AN-4",
				"Req-10.7",
				"SRG-OS-000047-GPOS-00023"
			],
			"description": "The default action to take when the logs reach their maximum size\nis to rotate the log files, discarding the oldest one. To configure the action taken\nby <code>auditd</code>, add or correct the line in <code>/etc/audit/auditd.conf</code>:\n<pre>max_log_file_action = <i>ACTION</i></pre>\nPossible values for <i>ACTION</i> are described in the <code>auditd.conf</code> man\npage. These include:\n<ul><li><code>ignore</code></li><li><code>syslog</code></li><li><code>suspend</code></li><li><code>rotate</code></li><li><code>keep_logs</code></li></ul>\nSet the <code><i>ACTION</i></code> to <code>rotate</code> to ensure log rotation\noccurs. This is the default. The setting is case-insensitive.",
			"rationale": "Automatically rotating logs (by setting this to <code>rotate</code>)\nminimizes the chances of the system unexpectedly running out of disk space by\nbeing overwhelmed with log data. However, for systems that must never discard\nlog data, or which use external processes to transfer it and reclaim space,\n<code>keep_logs</code> can be employed.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-auditd_data_retention_max_log_file_action:def:1",
			"remediations": [
				{
					"remediation_id": "auditd_data_retention_max_log_file_action",
					"system": "urn:xccdf:fix:script:kubernetes",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "---\napiVersion: machineconfiguration.openshift.io/v1\nkind: MachineConfig\nspec:\n  config:\n    ignition:\n      version: 3.1.0\n    storage:\n      files:\n      - contents:\n          source: data:,{{ %23%0A%23%20This%20file%20controls%20the%20configuration%20of%20the%20audit%20daemon%0A%23%0A%0Alocal_events%20%3D%20yes%0Awrite_logs%20%3D%20yes%0Alog_file%20%3D%20/var/log/audit/audit.log%0Alog_group%20%3D%20root%0Alog_format%20%3D%20ENRICHED%0Aflush%20%3D%20%7B%7B.var_auditd_flush%7D%7D%0Afreq%20%3D%2050%0Amax_log_file%20%3D%20%7B%7B.var_auditd_max_log_file%7D%7D%0Anum_logs%20%3D%20%7B%7B.var_auditd_num_logs%7D%7D%0Apriority_boost%20%3D%204%0Aname_format%20%3D%20hostname%0A%23%23name%20%3D%20mydomain%0Amax_log_file_action%20%3D%20%7B%7B.var_auditd_max_log_file_action%7D%7D%0Aspace_left%20%3D%20%7B%7B.var_auditd_space_left%7D%7D%0Aspace_left_action%20%3D%20%7B%7B.var_auditd_space_left_action%7D%7D%0Averify_email%20%3D%20yes%0Aaction_mail_acct%20%3D%20%7B%7B.var_auditd_action_mail_acct%7D%7D%0Aadmin_space_left%20%3D%2050%0Aadmin_space_left_action%20%3D%20syslog%0Adisk_full_action%20%3D%20%7B%7B.var_auditd_disk_full_action%7D%7D%0Adisk_error_action%20%3D%20%7B%7B.var_auditd_disk_error_action%7D%7D%0Ause_libwrap%20%3D%20yes%0A%23%23tcp_listen_port%20%3D%2060%0Atcp_listen_queue%20%3D%205%0Atcp_max_per_addr%20%3D%201%0A%23%23tcp_client_ports%20%3D%201024-65535%0Atcp_client_max_idle%20%3D%200%0Atransport%20%3D%20TCP%0Akrb5_principal%20%3D%20auditd%0A%23%23krb5_key_file%20%3D%20/etc/audit/audit.key%0Adistribute_network%20%3D%20no%0Aq_depth%20%3D%20400%0Aoverflow_action%20%3D%20syslog%0Amax_restarts%20%3D%2010%0Aplugin_dir%20%3D%20/etc/audit/plugins.d }}\n        mode: 0640\n        path: /etc/audit/auditd.conf\n        overwrite: true\n"
				},
				{
					"remediation_id": "auditd_data_retention_max_log_file_action",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\nvar_auditd_max_log_file_action='rotate'\n\n\nAUDITCONFIG=/etc/audit/auditd.conf\n\n# Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed.\n# Otherwise, regular sed command will do.\nsed_command=('sed' '-i')\nif test -L \"$AUDITCONFIG\"; then\n    sed_command+=('--follow-symlinks')\nfi\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^max_log_file_action\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_auditd_max_log_file_action\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^max_log_file_action\\\\>\" \"$AUDITCONFIG\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    \"${sed_command[@]}\" \"s/^max_log_file_action\\\\>.*/$escaped_formatted_output/gi\" \"$AUDITCONFIG\"\nelse\n    # \\n is precaution for case where file ends without trailing newline\n    cce=\"CCE-83701-3\"\n    printf '\\n# Per %s: Set %s in %s\\n' \"$cce\" \"$formatted_output\" \"$AUDITCONFIG\" >> \"$AUDITCONFIG\"\n    printf '%s\\n' \"$formatted_output\" >> \"$AUDITCONFIG\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "auditd_data_retention_max_log_file_action",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83701-3\n  - CJIS-5.4.1.1\n  - NIST-800-53-AU-5(1)\n  - NIST-800-53-AU-5(2)\n  - NIST-800-53-AU-5(4)\n  - NIST-800-53-AU-5(b)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.7\n  - auditd_data_retention_max_log_file_action\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_auditd_max_log_file_action # promote to variable\n  set_fact:\n    var_auditd_max_log_file_action: !!str rotate\n  tags:\n    - always\n\n- name: Configure auditd max_log_file_action Upon Reaching Maximum Log Size\n  lineinfile:\n    dest: /etc/audit/auditd.conf\n    line: max_log_file_action = {{ var_auditd_max_log_file_action }}\n    regexp: ^\\s*max_log_file_action\\s*=\\s*.*$\n    state: present\n    create: true\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83701-3\n  - CJIS-5.4.1.1\n  - NIST-800-53-AU-5(1)\n  - NIST-800-53-AU-5(2)\n  - NIST-800-53-AU-5(4)\n  - NIST-800-53-AU-5(b)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.7\n  - auditd_data_retention_max_log_file_action\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_auditd_data_retention_num_logs": {
			"rule_id": "xccdf_org.ssgproject.content_rule_auditd_data_retention_num_logs",
			"title": "Configure auditd Number of Logs Retained",
			"result": "fail",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83688-2"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"5.4.1.1",
				"APO11.04",
				"APO12.06",
				"BAI03.05",
				"BAI08.02",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS05.04",
				"DSS05.07",
				"MEA02.01",
				"3.3.1",
				"4.2.3.10",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.8",
				"SR 2.9",
				"SR 6.1",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"CIP-004-6 R2.2.3",
				"CIP-004-6 R3.3",
				"CIP-007-3 R5.2",
				"CIP-007-3 R5.3.1",
				"CIP-007-3 R5.3.2",
				"CIP-007-3 R5.3.3",
				"CIP-007-3 R6.5",
				"AU-11",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"PR.PT-1",
				"RS.AN-1",
				"RS.AN-4",
				"Req-10.7"
			],
			"description": "Determine how many log files\n<code>auditd</code> should retain when it rotates logs.\nEdit the file <code>/etc/audit/auditd.conf</code>. Add or modify the following\nline, substituting <i>NUMLOGS</i> with the correct value of 5:\n<pre>num_logs = <i>NUMLOGS</i></pre>\nSet the value to 5 for general-purpose systems.\nNote that values less than 2 result in no log rotation.",
			"rationale": "The total storage for audit log files must be large enough to retain\nlog information over the period required. This is a function of the maximum log\nfile size and the number of logs retained.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-auditd_data_retention_num_logs:def:1",
			"remediations": [
				{
					"remediation_id": "auditd_data_retention_num_logs",
					"system": "urn:xccdf:fix:script:kubernetes",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "---\napiVersion: machineconfiguration.openshift.io/v1\nkind: MachineConfig\nspec:\n  config:\n    ignition:\n      version: 3.1.0\n    storage:\n      files:\n      - contents:\n          source: data:,{{ %23%0A%23%20This%20file%20controls%20the%20configuration%20of%20the%20audit%20daemon%0A%23%0A%0Alocal_events%20%3D%20yes%0Awrite_logs%20%3D%20yes%0Alog_file%20%3D%20/var/log/audit/audit.log%0Alog_group%20%3D%20root%0Alog_format%20%3D%20ENRICHED%0Aflush%20%3D%20%7B%7B.var_auditd_flush%7D%7D%0Afreq%20%3D%2050%0Amax_log_file%20%3D%20%7B%7B.var_auditd_max_log_file%7D%7D%0Anum_logs%20%3D%20%7B%7B.var_auditd_num_logs%7D%7D%0Apriority_boost%20%3D%204%0Aname_format%20%3D%20hostname%0A%23%23name%20%3D%20mydomain%0Amax_log_file_action%20%3D%20%7B%7B.var_auditd_max_log_file_action%7D%7D%0Aspace_left%20%3D%20%7B%7B.var_auditd_space_left%7D%7D%0Aspace_left_action%20%3D%20%7B%7B.var_auditd_space_left_action%7D%7D%0Averify_email%20%3D%20yes%0Aaction_mail_acct%20%3D%20%7B%7B.var_auditd_action_mail_acct%7D%7D%0Aadmin_space_left%20%3D%2050%0Aadmin_space_left_action%20%3D%20syslog%0Adisk_full_action%20%3D%20%7B%7B.var_auditd_disk_full_action%7D%7D%0Adisk_error_action%20%3D%20%7B%7B.var_auditd_disk_error_action%7D%7D%0Ause_libwrap%20%3D%20yes%0A%23%23tcp_listen_port%20%3D%2060%0Atcp_listen_queue%20%3D%205%0Atcp_max_per_addr%20%3D%201%0A%23%23tcp_client_ports%20%3D%201024-65535%0Atcp_client_max_idle%20%3D%200%0Atransport%20%3D%20TCP%0Akrb5_principal%20%3D%20auditd%0A%23%23krb5_key_file%20%3D%20/etc/audit/audit.key%0Adistribute_network%20%3D%20no%0Aq_depth%20%3D%20400%0Aoverflow_action%20%3D%20syslog%0Amax_restarts%20%3D%2010%0Aplugin_dir%20%3D%20/etc/audit/plugins.d }}\n        mode: 0640\n        path: /etc/audit/auditd.conf\n        overwrite: true\n"
				},
				{
					"remediation_id": "auditd_data_retention_num_logs",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\nvar_auditd_num_logs='5'\n\n\nAUDITCONFIG=/etc/audit/auditd.conf\n\n# Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed.\n# Otherwise, regular sed command will do.\nsed_command=('sed' '-i')\nif test -L \"$AUDITCONFIG\"; then\n    sed_command+=('--follow-symlinks')\nfi\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^num_logs\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_auditd_num_logs\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^num_logs\\\\>\" \"$AUDITCONFIG\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    \"${sed_command[@]}\" \"s/^num_logs\\\\>.*/$escaped_formatted_output/gi\" \"$AUDITCONFIG\"\nelse\n    # \\n is precaution for case where file ends without trailing newline\n    cce=\"CCE-83688-2\"\n    printf '\\n# Per %s: Set %s in %s\\n' \"$cce\" \"$formatted_output\" \"$AUDITCONFIG\" >> \"$AUDITCONFIG\"\n    printf '%s\\n' \"$formatted_output\" >> \"$AUDITCONFIG\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "auditd_data_retention_num_logs",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83688-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.3.1\n  - NIST-800-53-AU-11\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.7\n  - auditd_data_retention_num_logs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_auditd_num_logs # promote to variable\n  set_fact:\n    var_auditd_num_logs: !!str 5\n  tags:\n    - always\n\n- name: Configure auditd Number of Logs Retained\n  lineinfile:\n    dest: /etc/audit/auditd.conf\n    line: num_logs = {{ var_auditd_num_logs }}\n    regexp: ^\\s*num_logs\\s*=\\s*.*$\n    state: present\n    create: true\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83688-2\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.3.1\n  - NIST-800-53-AU-11\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.7\n  - auditd_data_retention_num_logs\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_auditd_data_retention_space_left_action": {
			"rule_id": "xccdf_org.ssgproject.content_rule_auditd_data_retention_space_left_action",
			"title": "Configure auditd space_left Action on Low Disk Space",
			"result": "fail",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83703-9"
			],
			"references": [
				"1",
				"11",
				"12",
				"13",
				"14",
				"15",
				"16",
				"19",
				"2",
				"3",
				"4",
				"5",
				"6",
				"7",
				"8",
				"5.4.1.1",
				"APO11.04",
				"APO12.06",
				"APO13.01",
				"BAI03.05",
				"BAI04.04",
				"BAI08.02",
				"DSS02.02",
				"DSS02.04",
				"DSS02.07",
				"DSS03.01",
				"DSS05.04",
				"DSS05.07",
				"MEA02.01",
				"3.3.1",
				"CCI-001855",
				"164.312(a)(2)(ii)",
				"4.2.3.10",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.4.4.7",
				"4.3.4.5.6",
				"4.3.4.5.7",
				"4.3.4.5.8",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.8",
				"SR 2.9",
				"SR 6.1",
				"SR 7.1",
				"SR 7.2",
				"A.12.1.3",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"A.16.1.4",
				"A.16.1.5",
				"A.16.1.7",
				"A.17.2.1",
				"AU-5(b)",
				"AU-5(2)",
				"AU-5(1)",
				"AU-5(4)",
				"CM-6(a)",
				"DE.AE-3",
				"DE.AE-5",
				"PR.DS-4",
				"PR.PT-1",
				"RS.AN-1",
				"RS.AN-4",
				"Req-10.7",
				"SRG-OS-000343-GPOS-00134",
				"SRG-OS-000343-VMM-001240"
			],
			"description": "The <code>auditd</code> service can be configured to take an action\nwhen disk space <i>starts</i> to run low.\nEdit the file <code>/etc/audit/auditd.conf</code>. Modify the following line,\nsubstituting <i>ACTION</i> appropriately:\n<pre>space_left_action = <i>ACTION</i></pre>\nPossible values for <i>ACTION</i> are described in the <code>auditd.conf</code> man page.\nThese include:\n<ul><li><code>syslog</code></li><li><code>email</code></li><li><code>exec</code></li><li><code>suspend</code></li><li><code>single</code></li><li><code>halt</code></li></ul>\nSet this to <code>email</code> (instead of the default,\nwhich is <code>suspend</code>) as it is more likely to get prompt attention. Acceptable values\nalso include <code>suspend</code>, <code>single</code>, and <code>halt</code>.",
			"rationale": "Notifying administrators of an impending disk space problem may\nallow them to take corrective action prior to any disruption.",
			"platforms": [
				"#audit"
			],
			"oval_definition_id": "oval:ssg-auditd_data_retention_space_left_action:def:1",
			"remediations": [
				{
					"remediation_id": "auditd_data_retention_space_left_action",
					"system": "urn:xccdf:fix:script:kubernetes",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "---\napiVersion: machineconfiguration.openshift.io/v1\nkind: MachineConfig\nspec:\n  config:\n    ignition:\n      version: 3.1.0\n    storage:\n      files:\n      - contents:\n          source: data:,{{ %23%0A%23%20This%20file%20controls%20the%20configuration%20of%20the%20audit%20daemon%0A%23%0A%0Alocal_events%20%3D%20yes%0Awrite_logs%20%3D%20yes%0Alog_file%20%3D%20/var/log/audit/audit.log%0Alog_group%20%3D%20root%0Alog_format%20%3D%20ENRICHED%0Aflush%20%3D%20%7B%7B.var_auditd_flush%7D%7D%0Afreq%20%3D%2050%0Amax_log_file%20%3D%20%7B%7B.var_auditd_max_log_file%7D%7D%0Anum_logs%20%3D%20%7B%7B.var_auditd_num_logs%7D%7D%0Apriority_boost%20%3D%204%0Aname_format%20%3D%20hostname%0A%23%23name%20%3D%20mydomain%0Amax_log_file_action%20%3D%20%7B%7B.var_auditd_max_log_file_action%7D%7D%0Aspace_left%20%3D%20%7B%7B.var_auditd_space_left%7D%7D%0Aspace_left_action%20%3D%20%7B%7B.var_auditd_space_left_action%7D%7D%0Averify_email%20%3D%20yes%0Aaction_mail_acct%20%3D%20%7B%7B.var_auditd_action_mail_acct%7D%7D%0Aadmin_space_left%20%3D%2050%0Aadmin_space_left_action%20%3D%20syslog%0Adisk_full_action%20%3D%20%7B%7B.var_auditd_disk_full_action%7D%7D%0Adisk_error_action%20%3D%20%7B%7B.var_auditd_disk_error_action%7D%7D%0Ause_libwrap%20%3D%20yes%0A%23%23tcp_listen_port%20%3D%2060%0Atcp_listen_queue%20%3D%205%0Atcp_max_per_addr%20%3D%201%0A%23%23tcp_client_ports%20%3D%201024-65535%0Atcp_client_max_idle%20%3D%200%0Atransport%20%3D%20TCP%0Akrb5_principal%20%3D%20auditd%0A%23%23krb5_key_file%20%3D%20/etc/audit/audit.key%0Adistribute_network%20%3D%20no%0Aq_depth%20%3D%20400%0Aoverflow_action%20%3D%20syslog%0Amax_restarts%20%3D%2010%0Aplugin_dir%20%3D%20/etc/audit/plugins.d }}\n        mode: 0640\n        path: /etc/audit/auditd.conf\n        overwrite: true\n"
				},
				{
					"remediation_id": "auditd_data_retention_space_left_action",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q audit; then\n\nvar_auditd_space_left_action='email'\n\n\n#\n# If space_left_action present in /etc/audit/auditd.conf, change value\n# to var_auditd_space_left_action, else\n# add \"space_left_action = $var_auditd_space_left_action\" to /etc/audit/auditd.conf\n#\n\nAUDITCONFIG=/etc/audit/auditd.conf\n\n# Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed.\n# Otherwise, regular sed command will do.\nsed_command=('sed' '-i')\nif test -L \"$AUDITCONFIG\"; then\n    sed_command+=('--follow-symlinks')\nfi\n\n# Strip any search characters in the key arg so that the key can be replaced without\n# adding any search characters to the config file.\nstripped_key=$(sed 's/[\\^=\\$,;+]*//g' <<< \"^space_left_action\")\n\n# shellcheck disable=SC2059\nprintf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_auditd_space_left_action\"\n\n# If the key exists, change it. Otherwise, add it to the config_file.\n# We search for the key string followed by a word boundary (matched by \\>),\n# so if we search for 'setting', 'setting2' won't match.\nif LC_ALL=C grep -q -m 1 -i -e \"^space_left_action\\\\>\" \"$AUDITCONFIG\"; then\n    escaped_formatted_output=$(sed -e 's|/|\\\\/|g' <<< \"$formatted_output\")\n    \"${sed_command[@]}\" \"s/^space_left_action\\\\>.*/$escaped_formatted_output/gi\" \"$AUDITCONFIG\"\nelse\n    # \\n is precaution for case where file ends without trailing newline\n    cce=\"CCE-83703-9\"\n    printf '\\n# Per %s: Set %s in %s\\n' \"$cce\" \"$formatted_output\" \"$AUDITCONFIG\" >> \"$AUDITCONFIG\"\n    printf '%s\\n' \"$formatted_output\" >> \"$AUDITCONFIG\"\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "auditd_data_retention_space_left_action",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-83703-9\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.3.1\n  - NIST-800-53-AU-5(1)\n  - NIST-800-53-AU-5(2)\n  - NIST-800-53-AU-5(4)\n  - NIST-800-53-AU-5(b)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.7\n  - auditd_data_retention_space_left_action\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n- name: XCCDF Value var_auditd_space_left_action # promote to variable\n  set_fact:\n    var_auditd_space_left_action: !!str email\n  tags:\n    - always\n\n- name: Configure auditd space_left Action on Low Disk Space\n  lineinfile:\n    dest: /etc/audit/auditd.conf\n    line: space_left_action = {{ var_auditd_space_left_action }}\n    regexp: ^\\s*space_left_action\\s*=\\s*.*$\n    state: present\n    create: true\n  when: '\"audit\" in ansible_facts.packages'\n  tags:\n  - CCE-83703-9\n  - CJIS-5.4.1.1\n  - NIST-800-171-3.3.1\n  - NIST-800-53-AU-5(1)\n  - NIST-800-53-AU-5(2)\n  - NIST-800-53-AU-5(4)\n  - NIST-800-53-AU-5(b)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.7\n  - auditd_data_retention_space_left_action\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - restrict_strategy\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_file_groupowner_grub2_cfg": {
			"rule_id": "xccdf_org.ssgproject.content_rule_file_groupowner_grub2_cfg",
			"title": "Verify /boot/grub2/grub.cfg Group Ownership",
			"result": "pass",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83848-2"
			],
			"references": [
				"12",
				"13",
				"14",
				"15",
				"16",
				"18",
				"3",
				"5",
				"5.5.2.2",
				"APO01.06",
				"DSS05.04",
				"DSS05.07",
				"DSS06.02",
				"3.4.5",
				"CCI-000225",
				"164.308(a)(1)(ii)(B)",
				"164.308(a)(7)(i)",
				"164.308(a)(7)(ii)(A)",
				"164.310(a)(1)",
				"164.310(a)(2)(i)",
				"164.310(a)(2)(ii)",
				"164.310(a)(2)(iii)",
				"164.310(b)",
				"164.310(c)",
				"164.310(d)(1)",
				"164.310(d)(2)(iii)",
				"4.3.3.7.3",
				"SR 2.1",
				"SR 5.2",
				"A.10.1.1",
				"A.11.1.4",
				"A.11.1.5",
				"A.11.2.1",
				"A.13.1.1",
				"A.13.1.3",
				"A.13.2.1",
				"A.13.2.3",
				"A.13.2.4",
				"A.14.1.2",
				"A.14.1.3",
				"A.6.1.2",
				"A.7.1.1",
				"A.7.1.2",
				"A.7.3.1",
				"A.8.2.2",
				"A.8.2.3",
				"A.9.1.1",
				"A.9.1.2",
				"A.9.2.3",
				"A.9.4.1",
				"A.9.4.4",
				"A.9.4.5",
				"CM-6(a)",
				"AC-6(1)",
				"PR.AC-4",
				"PR.DS-5",
				"Req-7.1",
				"SRG-OS-000480-GPOS-00227"
			],
			"description": "The file <code>/boot/grub2/grub.cfg</code> should\nbe group-owned by the <code>root</code> group to prevent\ndestruction or modification of the file.\n\nTo properly set the group owner of <code>/boot/grub2/grub.cfg</code>, run the command:\n<pre>$ sudo chgrp root /boot/grub2/grub.cfg</pre>",
			"rationale": "The <code>root</code> group is a highly-privileged group. Furthermore, the group-owner of this\nfile should not have any access privileges anyway.",
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-file_groupowner_grub2_cfg:def:1",
			"remediations": [
				{
					"remediation_id": "file_groupowner_grub2_cfg",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nchgrp 0 /boot/grub2/grub.cfg\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "file_groupowner_grub2_cfg",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "- name: Test for existence /boot/grub2/grub.cfg\n  stat:\n    path: /boot/grub2/grub.cfg\n  register: file_exists\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-83848-2\n  - CJIS-5.5.2.2\n  - NIST-800-171-3.4.5\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-7.1\n  - configure_strategy\n  - file_groupowner_grub2_cfg\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner 0 on /boot/grub2/grub.cfg\n  file:\n    path: /boot/grub2/grub.cfg\n    group: '0'\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - CCE-83848-2\n  - CJIS-5.5.2.2\n  - NIST-800-171-3.4.5\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-7.1\n  - configure_strategy\n  - file_groupowner_grub2_cfg\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_file_owner_grub2_cfg": {
			"rule_id": "xccdf_org.ssgproject.content_rule_file_owner_grub2_cfg",
			"title": "Verify /boot/grub2/grub.cfg User Ownership",
			"result": "pass",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83845-8"
			],
			"references": [
				"12",
				"13",
				"14",
				"15",
				"16",
				"18",
				"3",
				"5",
				"5.5.2.2",
				"APO01.06",
				"DSS05.04",
				"DSS05.07",
				"DSS06.02",
				"3.4.5",
				"CCI-000225",
				"164.308(a)(1)(ii)(B)",
				"164.308(a)(7)(i)",
				"164.308(a)(7)(ii)(A)",
				"164.310(a)(1)",
				"164.310(a)(2)(i)",
				"164.310(a)(2)(ii)",
				"164.310(a)(2)(iii)",
				"164.310(b)",
				"164.310(c)",
				"164.310(d)(1)",
				"164.310(d)(2)(iii)",
				"4.3.3.7.3",
				"SR 2.1",
				"SR 5.2",
				"A.10.1.1",
				"A.11.1.4",
				"A.11.1.5",
				"A.11.2.1",
				"A.13.1.1",
				"A.13.1.3",
				"A.13.2.1",
				"A.13.2.3",
				"A.13.2.4",
				"A.14.1.2",
				"A.14.1.3",
				"A.6.1.2",
				"A.7.1.1",
				"A.7.1.2",
				"A.7.3.1",
				"A.8.2.2",
				"A.8.2.3",
				"A.9.1.1",
				"A.9.1.2",
				"A.9.2.3",
				"A.9.4.1",
				"A.9.4.4",
				"A.9.4.5",
				"CM-6(a)",
				"AC-6(1)",
				"PR.AC-4",
				"PR.DS-5",
				"Req-7.1"
			],
			"description": "The file <code>/boot/grub2/grub.cfg</code> should\nbe owned by the <code>root</code> user to prevent destruction\nor modification of the file.\n\nTo properly set the owner of <code>/boot/grub2/grub.cfg</code>, run the command:\n<pre>$ sudo chown root /boot/grub2/grub.cfg </pre>",
			"rationale": "Only root should be able to modify important boot parameters.",
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-file_owner_grub2_cfg:def:1",
			"remediations": [
				{
					"remediation_id": "file_owner_grub2_cfg",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nchown 0 /boot/grub2/grub.cfg\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "file_owner_grub2_cfg",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "- name: Test for existence /boot/grub2/grub.cfg\n  stat:\n    path: /boot/grub2/grub.cfg\n  register: file_exists\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-83845-8\n  - CJIS-5.5.2.2\n  - NIST-800-171-3.4.5\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-7.1\n  - configure_strategy\n  - file_owner_grub2_cfg\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner 0 on /boot/grub2/grub.cfg\n  file:\n    path: /boot/grub2/grub.cfg\n    owner: '0'\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - CCE-83845-8\n  - CJIS-5.5.2.2\n  - NIST-800-171-3.4.5\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-7.1\n  - configure_strategy\n  - file_owner_grub2_cfg\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_rsyslog_files_groupownership": {
			"rule_id": "xccdf_org.ssgproject.content_rule_rsyslog_files_groupownership",
			"title": "Ensure Log Files Are Owned By Appropriate Group",
			"result": "pass",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83834-2"
			],
			"references": [
				"BP28(R46)",
				"BP28(R5)",
				"12",
				"13",
				"14",
				"15",
				"16",
				"18",
				"3",
				"5",
				"APO01.06",
				"DSS05.04",
				"DSS05.07",
				"DSS06.02",
				"CCI-001314",
				"4.3.3.7.3",
				"SR 2.1",
				"SR 5.2",
				"0988",
				"1405",
				"A.10.1.1",
				"A.11.1.4",
				"A.11.1.5",
				"A.11.2.1",
				"A.13.1.1",
				"A.13.1.3",
				"A.13.2.1",
				"A.13.2.3",
				"A.13.2.4",
				"A.14.1.2",
				"A.14.1.3",
				"A.6.1.2",
				"A.7.1.1",
				"A.7.1.2",
				"A.7.3.1",
				"A.8.2.2",
				"A.8.2.3",
				"A.9.1.1",
				"A.9.1.2",
				"A.9.2.3",
				"A.9.4.1",
				"A.9.4.4",
				"A.9.4.5",
				"CIP-003-8 R5.1.1",
				"CIP-003-8 R5.3",
				"CIP-004-6 R2.3",
				"CIP-007-3 R2.1",
				"CIP-007-3 R2.2",
				"CIP-007-3 R2.3",
				"CIP-007-3 R5.1",
				"CIP-007-3 R5.1.1",
				"CIP-007-3 R5.1.2",
				"CM-6(a)",
				"AC-6(1)",
				"PR.AC-4",
				"PR.DS-5",
				"Req-10.5.1",
				"Req-10.5.2"
			],
			"description": "The group-owner of all log files written by\n<code>rsyslog</code> should be <code>root</code>.\nThese log files are determined by the second part of each Rule line in\n<code>/etc/rsyslog.conf</code> and typically all appear in <code>/var/log</code>.\nFor each log file <i>LOGFILE</i> referenced in <code>/etc/rsyslog.conf</code>,\nrun the following command to inspect the file&#x27;s group owner:\n<pre>$ ls -l <i>LOGFILE</i></pre>\nIf the owner is not <code>root</code>, run the following command to\ncorrect this:\n<pre>$ sudo chgrp root <i>LOGFILE</i></pre>",
			"rationale": "The log files generated by rsyslog contain valuable information regarding system\nconfiguration, user authentication, and other such information. Log files should be\nprotected from unauthorized access.",
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-rsyslog_files_groupownership:def:1"
		},
		"xccdf_org.ssgproject.content_rule_rsyslog_files_ownership": {
			"rule_id": "xccdf_org.ssgproject.content_rule_rsyslog_files_ownership",
			"title": "Ensure Log Files Are Owned By Appropriate User",
			"result": "pass",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83946-4"
			],
			"references": [
				"BP28(R46)",
				"BP28(R5)",
				"12",
				"13",
				"14",
				"15",
				"16",
				"18",
				"3",
				"5",
				"APO01.06",
				"DSS05.04",
				"DSS05.07",
				"DSS06.02",
				"CCI-001314",
				"4.3.3.7.3",
				"SR 2.1",
				"SR 5.2",
				"0988",
				"1405",
				"A.10.1.1",
				"A.11.1.4",
				"A.11.1.5",
				"A.11.2.1",
				"A.13.1.1",
				"A.13.1.3",
				"A.13.2.1",
				"A.13.2.3",
				"A.13.2.4",
				"A.14.1.2",
				"A.14.1.3",
				"A.6.1.2",
				"A.7.1.1",
				"A.7.1.2",
				"A.7.3.1",
				"A.8.2.2",
				"A.8.2.3",
				"A.9.1.1",
				"A.9.1.2",
				"A.9.2.3",
				"A.9.4.1",
				"A.9.4.4",
				"A.9.4.5",
				"CIP-003-8 R5.1.1",
				"CIP-003-8 R5.3",
				"CIP-004-6 R2.3",
				"CIP-007-3 R2.1",
				"CIP-007-3 R2.2",
				"CIP-007-3 R2.3",
				"CIP-007-3 R5.1",
				"CIP-007-3 R5.1.1",
				"CIP-007-3 R5.1.2",
				"CM-6(a)",
				"AC-6(1)",
				"PR.AC-4",
				"PR.DS-5",
				"Req-10.5.1",
				"Req-10.5.2"
			],
			"description": "The owner of all log files written by\n<code>rsyslog</code> should be <code>root</code>.\nThese log files are determined by the second part of each Rule line in\n<code>/etc/rsyslog.conf</code> and typically all appear in <code>/var/log</code>.\nFor each log file <i>LOGFILE</i> referenced in <code>/etc/rsyslog.conf</code>,\nrun the following command to inspect the file&#x27;s owner:\n<pre>$ ls -l <i>LOGFILE</i></pre>\nIf the owner is not <code>root</code>, run the following command to\ncorrect this:\n<pre>$ sudo chown root <i>LOGFILE</i></pre>",
			"rationale": "The log files generated by rsyslog contain valuable information regarding system\nconfiguration, user authentication, and other such information. Log files should be\nprotected from unauthorized access.",
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-rsyslog_files_ownership:def:1"
		},
		"xccdf_org.ssgproject.content_rule_rsyslog_files_permissions": {
			"rule_id": "xccdf_org.ssgproject.content_rule_rsyslog_files_permissions",
			"title": "Ensure System Log Files Have Correct Permissions",
			"result": "pass",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83689-0"
			],
			"references": [
				"BP28(R36)",
				"CCI-001314",
				"0988",
				"1405",
				"CIP-003-8 R5.1.1",
				"CIP-003-8 R5.3",
				"CIP-004-6 R2.3",
				"CIP-007-3 R2.1",
				"CIP-007-3 R2.2",
				"CIP-007-3 R2.3",
				"CIP-007-3 R5.1",
				"CIP-007-3 R5.1.1",
				"CIP-007-3 R5.1.2",
				"CM-6(a)",
				"AC-6(1)",
				"Req-10.5.1",
				"Req-10.5.2"
			],
			"description": "The file permissions for all log files written by <code>rsyslog</code> should\nbe set to 600, or more restrictive. These log files are determined by the\nsecond part of each Rule line in <code>/etc/rsyslog.conf</code> and typically\nall appear in <code>/var/log</code>. For each log file <i>LOGFILE</i>\nreferenced in <code>/etc/rsyslog.conf</code>, run the following command to\ninspect the file&#x27;s permissions:\n<pre>$ ls -l <i>LOGFILE</i></pre>\nIf the permissions are not 600 or more restrictive, run the following\ncommand to correct this:\n<pre>$ sudo chmod 0600 <i>LOGFILE</i></pre>&quot;",
			"rationale": "Log files can contain valuable information regarding system\nconfiguration. If the system log files are not protected unauthorized\nusers could change the logged data, eliminating their forensic value.",
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-rsyslog_files_permissions:def:1",
			"remediations": [
				{
					"remediation_id": "rsyslog_files_permissions",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\n# List of log file paths to be inspected for correct permissions\n# * Primarily inspect log file paths listed in /etc/rsyslog.conf\nRSYSLOG_ETC_CONFIG=\"/etc/rsyslog.conf\"\n# * And also the log file paths listed after rsyslog's $IncludeConfig directive\n#   (store the result into array for the case there's shell glob used as value of IncludeConfig)\nreadarray -t RSYSLOG_INCLUDE_CONFIG < <(grep -e \"\\$IncludeConfig[[:space:]]\\+[^[:space:];]\\+\" /etc/rsyslog.conf | cut -d ' ' -f 2)\nreadarray -t RSYSLOG_INCLUDE < <(awk '/)/{f=0} /include\\(/{f=1} f{nf=gensub(\"^(include\\\\(|\\\\s*)file=\\\"(\\\\S+)\\\".*\",\"\\\\2\",1); if($0!=nf){print nf}}' /etc/rsyslog.conf)\n\n# Declare an array to hold the final list of different log file paths\ndeclare -a LOG_FILE_PATHS\n\nRSYSLOG_CONFIGS=()\nRSYSLOG_CONFIGS=(\"${RSYSLOG_ETC_CONFIG}\" \"${RSYSLOG_INCLUDE_CONFIG[@]}\" \"${RSYSLOG_INCLUDE[@]}\")\n\n# Get full list of files to be checked\n# RSYSLOG_CONFIGS may contain globs such as \n# /etc/rsyslog.d/*.conf /etc/rsyslog.d/*.frule\n# So, loop over the entries in RSYSLOG_CONFIGS and use find to get the list of included files.\nRSYSLOG_FILES=()\nfor ENTRY in \"${RSYSLOG_CONFIGS[@]}\"\ndo\n     mapfile -t FINDOUT < <(find \"$(dirname \"${ENTRY}\")\" -maxdepth 1 -name \"$(basename \"${ENTRY}\")\")\n     RSYSLOG_FILES+=(\"${FINDOUT[@]}\")\ndone\n\n# Check file and fix if needed.\nfor LOG_FILE in \"${RSYSLOG_FILES[@]}\"\ndo\n\t# From each of these files extract just particular log file path(s), thus:\n\t# * Ignore lines starting with space (' '), comment ('#\"), or variable syntax ('$') characters,\n\t# * Ignore empty lines,\n\t# * Strip quotes and closing brackets from paths.\n\t# * Ignore paths that match /dev|/etc.*\\.conf, as those are paths, but likely not log files\n\t# * From the remaining valid rows select only fields constituting a log file path\n\t# Text file column is understood to represent a log file path if and only if all of the following are met:\n\t# * it contains at least one slash '/' character,\n\t# * it is preceded by space\n\t# * it doesn't contain space (' '), colon (':'), and semicolon (';') characters\n\t# Search log file for path(s) only in case it exists!\n\tif [[ -f \"${LOG_FILE}\" ]]\n\tthen\n\t\tNORMALIZED_CONFIG_FILE_LINES=$(sed -e \"/^[#|$]/d\" \"${LOG_FILE}\")\n\t\tLINES_WITH_PATHS=$(grep '[^/]*\\s\\+\\S*/\\S\\+$' <<< \"${NORMALIZED_CONFIG_FILE_LINES}\")\n\t\tFILTERED_PATHS=$(sed -e 's/[^\\/]*[[:space:]]*\\([^:;[:space:]]*\\)/\\1/g' <<< \"${LINES_WITH_PATHS}\")\n\t\tCLEANED_PATHS=$(sed -e \"s/[\\\"')]//g; /\\\\/etc.*\\.conf/d; /\\\\/dev\\\\//d\" <<< \"${FILTERED_PATHS}\")\n\t\tMATCHED_ITEMS=$(sed -e \"/^$/d\" <<< \"${CLEANED_PATHS}\")\n\t\t# Since above sed command might return more than one item (delimited by newline), split the particular\n\t\t# matches entries into new array specific for this log file\n\t\treadarray -t ARRAY_FOR_LOG_FILE <<< \"$MATCHED_ITEMS\"\n\t\t# Concatenate the two arrays - previous content of $LOG_FILE_PATHS array with\n\t\t# items from newly created array for this log file\n\t\tLOG_FILE_PATHS+=(\"${ARRAY_FOR_LOG_FILE[@]}\")\n\t\t# Delete the temporary array\n\t\tunset ARRAY_FOR_LOG_FILE\n\tfi\ndone\n\nDESIRED_PERM_MOD=600\n\n# Correct the form o\nfor LOG_FILE_PATH in \"${LOG_FILE_PATHS[@]}\"\ndo\n\t# Sanity check - if particular $LOG_FILE_PATH is empty string, skip it from further processing\n\tif [ -z \"$LOG_FILE_PATH\" ]\n\tthen\n\t\tcontinue\n\tfi\n\n\t# Also for each log file check if its permissions differ from 600. If so, correct them\n\tif [ -f \"$LOG_FILE_PATH\" ] && [ \"$(/usr/bin/stat -c %a \"$LOG_FILE_PATH\")\" -ne $DESIRED_PERM_MOD ]\n\tthen\n\t\t/bin/chmod $DESIRED_PERM_MOD \"$LOG_FILE_PATH\"\n\tfi\ndone\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "rsyslog_files_permissions",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "medium",
					"strategy": "configure",
					"fix": "- name: Set rsyslog logfile configuration facts\n  set_fact:\n    rsyslog_etc_config: /etc/rsyslog.conf\n    desired_perm_mode: '600'\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-83689-0\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.1\n  - PCI-DSS-Req-10.5.2\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - rsyslog_files_permissions\n\n- name: Get IncludeConfig directive\n  shell: |\n    set -o pipefail\n    grep -e '$IncludeConfig' {{ rsyslog_etc_config }} | cut -d ' ' -f 2 || true\n  register: include_config_output\n  changed_when: false\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-83689-0\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.1\n  - PCI-DSS-Req-10.5.2\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - rsyslog_files_permissions\n\n- name: Get include files directives\n  shell: |\n    set -o pipefail\n    grep -oP '^\\s*include\\s*\\(\\s*file.*' {{ rsyslog_etc_config }} |cut  -d\"\\\"\" -f 2 || true\n  register: include_files_output\n  changed_when: false\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-83689-0\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.1\n  - PCI-DSS-Req-10.5.2\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - rsyslog_files_permissions\n\n- name: List all config files\n  shell: find \"$(dirname \"{{ item }}\" )\" -maxdepth 1 -name \"$(basename \"{{ item }}\")\"\n  loop: '{{ include_config_output.stdout_lines + include_files_output.stdout_lines\n    }}'\n  register: rsyslog_config_files\n  changed_when: false\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-83689-0\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.1\n  - PCI-DSS-Req-10.5.2\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - rsyslog_files_permissions\n\n- name: Extract log files\n  shell: |\n    set -o pipefail\n    grep -oP '^[^(\\s|#|\\$)]+[\\s]+.*[\\s]+-?(/+[^:;\\s]+);*\\.*$' {{ item }}  |awk '{print $NF}'|sed -e 's/^-//' || true\n  loop: '{{ rsyslog_config_files.results|map(attribute=''stdout_lines'')|list|flatten|unique\n    + [ rsyslog_etc_config ] }}'\n  register: log_files\n  changed_when: false\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-83689-0\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.1\n  - PCI-DSS-Req-10.5.2\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - rsyslog_files_permissions\n\n- name: Setup log files permissions\n  ignore_errors: true\n  file:\n    path: '{{ item }}'\n    mode: '{{ desired_perm_mode }}'\n  loop: '{{ log_files.results|map(attribute=''stdout_lines'')|list|flatten|unique\n    }}'\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-83689-0\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.5.1\n  - PCI-DSS-Req-10.5.2\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - rsyslog_files_permissions\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_ensure_logrotate_activated": {
			"rule_id": "xccdf_org.ssgproject.content_rule_ensure_logrotate_activated",
			"title": "Ensure Logrotate Runs Periodically",
			"result": "fail",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83993-6"
			],
			"references": [
				"BP28(R43)",
				"NT12(R18)",
				"1",
				"14",
				"15",
				"16",
				"3",
				"5",
				"6",
				"APO11.04",
				"BAI03.05",
				"DSS05.04",
				"DSS05.07",
				"MEA02.01",
				"CCI-000366",
				"4.3.3.3.9",
				"4.3.3.5.8",
				"4.3.4.4.7",
				"4.4.2.1",
				"4.4.2.2",
				"4.4.2.4",
				"SR 2.10",
				"SR 2.11",
				"SR 2.12",
				"SR 2.8",
				"SR 2.9",
				"A.12.4.1",
				"A.12.4.2",
				"A.12.4.3",
				"A.12.4.4",
				"A.12.7.1",
				"CM-6(a)",
				"PR.PT-1",
				"Req-10.7"
			],
			"description": "The <code>logrotate</code> utility allows for the automatic rotation of\nlog files.  The frequency of rotation is specified in <code>/etc/logrotate.conf</code>,\nwhich triggers a cron task.  To configure logrotate to run daily, add or correct\nthe following line in <code>/etc/logrotate.conf</code>:\n<pre># rotate log files <i>frequency</i>\ndaily</pre>",
			"rationale": "Log files that are not properly rotated run the risk of growing so large\nthat they fill up the /var/log partition. Valuable logging information could be lost\nif the /var/log partition becomes full.",
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-ensure_logrotate_activated:def:1",
			"remediations": [
				{
					"remediation_id": "ensure_logrotate_activated",
					"system": "urn:xccdf:fix:script:kubernetes",
					"complexity": "low",
					"disruption": "low",
					"strategy": "restrict",
					"fix": "---\napiVersion: machineconfiguration.openshift.io/v1\nkind: MachineConfig\nspec:\n  config:\n    ignition:\n      version: 3.1.0\n    storage:\n      files:\n      - contents:\n          source: data:,{{ %23%20see%20%22man%20logrotate%22%20for%20details%0A%23%20rotate%20log%20files%20daily%0Adaily%0A%0A%23%20keep%204%20weeks%20worth%20of%20backlogs%0Arotate%2030%0A%0A%23%20create%20new%20%28empty%29%20log%20files%20after%20rotating%20old%20ones%0Acreate%0A%0A%23%20use%20date%20as%20a%20suffix%20of%20the%20rotated%20file%0Adateext%0A%0A%23%20uncomment%20this%20if%20you%20want%20your%20log%20files%20compressed%0A%23compress%0A%0A%23%20RPM%20packages%20drop%20log%20rotation%20information%20into%20this%20directory%0Ainclude%20/etc/logrotate.d%0A%0A%23%20system-specific%20logs%20may%20be%20also%20be%20configured%20here. }}\n        mode: 0644\n        path: /etc/logrotate.conf\n        overwrite: true\n"
				},
				{
					"remediation_id": "ensure_logrotate_activated",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nLOGROTATE_CONF_FILE=\"/etc/logrotate.conf\"\nCRON_DAILY_LOGROTATE_FILE=\"/etc/cron.daily/logrotate\"\n\n# daily rotation is configured\ngrep -q \"^daily$\" $LOGROTATE_CONF_FILE|| echo \"daily\" >> $LOGROTATE_CONF_FILE\n\n# remove any line configuring weekly, monthly or yearly rotation\nsed -i '/^\\s*\\(weekly\\|monthly\\|yearly\\).*$/d' $LOGROTATE_CONF_FILE\n\n# configure cron.daily if not already\nif ! grep -q \"^[[:space:]]*/usr/sbin/logrotate[[:alnum:][:blank:][:punct:]]*$LOGROTATE_CONF_FILE$\" $CRON_DAILY_LOGROTATE_FILE; then\n\techo \"#!/bin/sh\" > $CRON_DAILY_LOGROTATE_FILE\n\techo \"/usr/sbin/logrotate $LOGROTATE_CONF_FILE\" >> $CRON_DAILY_LOGROTATE_FILE\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "ensure_logrotate_activated",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "- name: Configure daily log rotation in /etc/logrotate.conf\n  lineinfile:\n    create: true\n    dest: /etc/logrotate.conf\n    regexp: ^daily$\n    line: daily\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-83993-6\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.7\n  - configure_strategy\n  - ensure_logrotate_activated\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Make sure daily log rotation setting is not overriden in /etc/logrotate.conf\n  lineinfile:\n    create: false\n    dest: /etc/logrotate.conf\n    regexp: ^[\\s]*(weekly|monthly|yearly)$\n    state: absent\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-83993-6\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.7\n  - configure_strategy\n  - ensure_logrotate_activated\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Configure cron.daily if not already\n  block:\n\n  - name: Add shebang\n    lineinfile:\n      path: /etc/cron.daily/logrotate\n      line: '#!/bin/sh'\n      insertbefore: BOF\n      create: true\n\n  - name: Add logrotate call\n    lineinfile:\n      path: /etc/cron.daily/logrotate\n      line: /usr/sbin/logrotate /etc/logrotate.conf\n      regexp: ^[\\s]*/usr/sbin/logrotate[\\s\\S]*/etc/logrotate.conf$\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-83993-6\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.7\n  - configure_strategy\n  - ensure_logrotate_activated\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_package_libreswan_installed": {
			"rule_id": "xccdf_org.ssgproject.content_rule_package_libreswan_installed",
			"title": "Install libreswan Package",
			"result": "fail",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-84068-6"
			],
			"references": [
				"12",
				"15",
				"3",
				"5",
				"8",
				"APO13.01",
				"DSS01.04",
				"DSS05.02",
				"DSS05.03",
				"DSS05.04",
				"CCI-001130",
				"CCI-001131",
				"4.3.3.6.5",
				"4.3.3.6.6",
				"4.3.3.6.7",
				"4.3.3.6.8",
				"SR 1.13",
				"SR 2.6",
				"SR 3.1",
				"SR 3.5",
				"SR 3.8",
				"SR 4.1",
				"SR 4.3",
				"SR 5.1",
				"SR 5.2",
				"SR 5.3",
				"SR 7.1",
				"SR 7.6",
				"A.11.2.4",
				"A.11.2.6",
				"A.13.1.1",
				"A.13.2.1",
				"A.14.1.3",
				"A.15.1.1",
				"A.15.2.1",
				"A.6.2.1",
				"A.6.2.2",
				"CM-6(a)",
				"PR.AC-3",
				"PR.MA-2",
				"PR.PT-4",
				"Req-4.1",
				"SRG-OS-000480-GPOS-00227",
				"SRG-OS-000120-GPOS-00061"
			],
			"description": "The Libreswan package provides an implementation of IPsec\nand IKE, which permits the creation of secure tunnels over\nuntrusted networks. The <code>libreswan</code> package can be installed with the following command:\n<pre>\n$ sudo dnf install libreswan</pre>",
			"rationale": "Providing the ability for remote users or systems\nto initiate a secure VPN connection protects information when it is\ntransmitted over a wide area network.",
			"oval_definition_id": "oval:ssg-package_libreswan_installed:def:1",
			"remediations": [
				{
					"remediation_id": "package_libreswan_installed",
					"system": "urn:redhat:osbuild:blueprint",
					"fix": "\n[[packages]]\nname = \"libreswan\"\nversion = \"*\"\n"
				},
				{
					"remediation_id": "package_libreswan_installed",
					"system": "urn:redhat:anaconda:pre",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "\npackage --add=libreswan\n"
				},
				{
					"remediation_id": "package_libreswan_installed",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "\nif ! rpm -q --quiet \"libreswan\" ; then\n    dnf install -y \"libreswan\"\nfi\n"
				},
				{
					"remediation_id": "package_libreswan_installed",
					"system": "urn:xccdf:fix:script:puppet",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "include install_libreswan\n\nclass install_libreswan {\n  package { 'libreswan':\n    ensure => 'installed',\n  }\n}\n"
				},
				{
					"remediation_id": "package_libreswan_installed",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "- name: Ensure libreswan is installed\n  package:\n    name: libreswan\n    state: present\n  tags:\n  - CCE-84068-6\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-4.1\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - package_libreswan_installed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_file_groupowner_etc_group": {
			"rule_id": "xccdf_org.ssgproject.content_rule_file_groupowner_etc_group",
			"title": "Verify Group Who Owns group File",
			"result": "pass",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83945-6"
			],
			"references": [
				"12",
				"13",
				"14",
				"15",
				"16",
				"18",
				"3",
				"5",
				"5.5.2.2",
				"APO01.06",
				"DSS05.04",
				"DSS05.07",
				"DSS06.02",
				"4.3.3.7.3",
				"SR 2.1",
				"SR 5.2",
				"A.10.1.1",
				"A.11.1.4",
				"A.11.1.5",
				"A.11.2.1",
				"A.13.1.1",
				"A.13.1.3",
				"A.13.2.1",
				"A.13.2.3",
				"A.13.2.4",
				"A.14.1.2",
				"A.14.1.3",
				"A.6.1.2",
				"A.7.1.1",
				"A.7.1.2",
				"A.7.3.1",
				"A.8.2.2",
				"A.8.2.3",
				"A.9.1.1",
				"A.9.1.2",
				"A.9.2.3",
				"A.9.4.1",
				"A.9.4.4",
				"A.9.4.5",
				"CIP-003-8 R5.1.1",
				"CIP-003-8 R5.3",
				"CIP-004-6 R2.3",
				"CIP-007-3 R2.1",
				"CIP-007-3 R2.2",
				"CIP-007-3 R2.3",
				"CIP-007-3 R5.1",
				"CIP-007-3 R5.1.1",
				"CIP-007-3 R5.1.2",
				"CM-6(a)",
				"AC-6(1)",
				"PR.AC-4",
				"PR.DS-5",
				"Req-8.7.c"
			],
			"description": " To properly set the group owner of <code>/etc/group</code>, run the command: <pre>$ sudo chgrp root /etc/group</pre>",
			"rationale": "The <code>/etc/group</code> file contains information regarding groups that are configured\non the system. Protection of this file is important for system security.",
			"oval_definition_id": "oval:ssg-file_groupowner_etc_group:def:1",
			"remediations": [
				{
					"remediation_id": "file_groupowner_etc_group",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "\n\n\nchgrp 0 /etc/group\n"
				},
				{
					"remediation_id": "file_groupowner_etc_group",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "- name: Test for existence /etc/group\n  stat:\n    path: /etc/group\n  register: file_exists\n  tags:\n  - CCE-83945-6\n  - CJIS-5.5.2.2\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.7.c\n  - configure_strategy\n  - file_groupowner_etc_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner 0 on /etc/group\n  file:\n    path: /etc/group\n    group: '0'\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - CCE-83945-6\n  - CJIS-5.5.2.2\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.7.c\n  - configure_strategy\n  - file_groupowner_etc_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_file_groupowner_etc_passwd": {
			"rule_id": "xccdf_org.ssgproject.content_rule_file_groupowner_etc_passwd",
			"title": "Verify Group Who Owns passwd File",
			"result": "pass",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83950-6"
			],
			"references": [
				"12",
				"13",
				"14",
				"15",
				"16",
				"18",
				"3",
				"5",
				"5.5.2.2",
				"APO01.06",
				"DSS05.04",
				"DSS05.07",
				"DSS06.02",
				"4.3.3.7.3",
				"SR 2.1",
				"SR 5.2",
				"A.10.1.1",
				"A.11.1.4",
				"A.11.1.5",
				"A.11.2.1",
				"A.13.1.1",
				"A.13.1.3",
				"A.13.2.1",
				"A.13.2.3",
				"A.13.2.4",
				"A.14.1.2",
				"A.14.1.3",
				"A.6.1.2",
				"A.7.1.1",
				"A.7.1.2",
				"A.7.3.1",
				"A.8.2.2",
				"A.8.2.3",
				"A.9.1.1",
				"A.9.1.2",
				"A.9.2.3",
				"A.9.4.1",
				"A.9.4.4",
				"A.9.4.5",
				"CIP-003-8 R5.1.1",
				"CIP-003-8 R5.3",
				"CIP-004-6 R2.3",
				"CIP-007-3 R2.1",
				"CIP-007-3 R2.2",
				"CIP-007-3 R2.3",
				"CIP-007-3 R5.1",
				"CIP-007-3 R5.1.1",
				"CIP-007-3 R5.1.2",
				"CM-6(a)",
				"AC-6(1)",
				"PR.AC-4",
				"PR.DS-5",
				"Req-8.7.c"
			],
			"description": " To properly set the group owner of <code>/etc/passwd</code>, run the command: <pre>$ sudo chgrp root /etc/passwd</pre>",
			"rationale": "The <code>/etc/passwd</code> file contains information about the users that are configured on\nthe system. Protection of this file is critical for system security.",
			"oval_definition_id": "oval:ssg-file_groupowner_etc_passwd:def:1",
			"remediations": [
				{
					"remediation_id": "file_groupowner_etc_passwd",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "\n\n\nchgrp 0 /etc/passwd\n"
				},
				{
					"remediation_id": "file_groupowner_etc_passwd",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "- name: Test for existence /etc/passwd\n  stat:\n    path: /etc/passwd\n  register: file_exists\n  tags:\n  - CCE-83950-6\n  - CJIS-5.5.2.2\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.7.c\n  - configure_strategy\n  - file_groupowner_etc_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner 0 on /etc/passwd\n  file:\n    path: /etc/passwd\n    group: '0'\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - CCE-83950-6\n  - CJIS-5.5.2.2\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.7.c\n  - configure_strategy\n  - file_groupowner_etc_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_file_groupowner_etc_shadow": {
			"rule_id": "xccdf_org.ssgproject.content_rule_file_groupowner_etc_shadow",
			"title": "Verify Group Who Owns shadow File",
			"result": "pass",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83930-8"
			],
			"references": [
				"12",
				"13",
				"14",
				"15",
				"16",
				"18",
				"3",
				"5",
				"5.5.2.2",
				"APO01.06",
				"DSS05.04",
				"DSS05.07",
				"DSS06.02",
				"4.3.3.7.3",
				"SR 2.1",
				"SR 5.2",
				"A.10.1.1",
				"A.11.1.4",
				"A.11.1.5",
				"A.11.2.1",
				"A.13.1.1",
				"A.13.1.3",
				"A.13.2.1",
				"A.13.2.3",
				"A.13.2.4",
				"A.14.1.2",
				"A.14.1.3",
				"A.6.1.2",
				"A.7.1.1",
				"A.7.1.2",
				"A.7.3.1",
				"A.8.2.2",
				"A.8.2.3",
				"A.9.1.1",
				"A.9.1.2",
				"A.9.2.3",
				"A.9.4.1",
				"A.9.4.4",
				"A.9.4.5",
				"CIP-003-8 R5.1.1",
				"CIP-003-8 R5.3",
				"CIP-004-6 R2.3",
				"CIP-007-3 R2.1",
				"CIP-007-3 R2.2",
				"CIP-007-3 R2.3",
				"CIP-007-3 R5.1",
				"CIP-007-3 R5.1.1",
				"CIP-007-3 R5.1.2",
				"CM-6(a)",
				"AC-6(1)",
				"PR.AC-4",
				"PR.DS-5",
				"Req-8.7.c"
			],
			"description": " To properly set the group owner of <code>/etc/shadow</code>, run the command: <pre>$ sudo chgrp root /etc/shadow</pre>",
			"rationale": "The <code>/etc/shadow</code> file stores password hashes. Protection of this file is\ncritical for system security.",
			"oval_definition_id": "oval:ssg-file_groupowner_etc_shadow:def:1",
			"remediations": [
				{
					"remediation_id": "file_groupowner_etc_shadow",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "\n\n\nchgrp 0 /etc/shadow\n"
				},
				{
					"remediation_id": "file_groupowner_etc_shadow",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "- name: Test for existence /etc/shadow\n  stat:\n    path: /etc/shadow\n  register: file_exists\n  tags:\n  - CCE-83930-8\n  - CJIS-5.5.2.2\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.7.c\n  - configure_strategy\n  - file_groupowner_etc_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure group owner 0 on /etc/shadow\n  file:\n    path: /etc/shadow\n    group: '0'\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - CCE-83930-8\n  - CJIS-5.5.2.2\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.7.c\n  - configure_strategy\n  - file_groupowner_etc_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_file_owner_etc_group": {
			"rule_id": "xccdf_org.ssgproject.content_rule_file_owner_etc_group",
			"title": "Verify User Who Owns group File",
			"result": "pass",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83925-8"
			],
			"references": [
				"12",
				"13",
				"14",
				"15",
				"16",
				"18",
				"3",
				"5",
				"5.5.2.2",
				"APO01.06",
				"DSS05.04",
				"DSS05.07",
				"DSS06.02",
				"CCI-002223",
				"4.3.3.7.3",
				"SR 2.1",
				"SR 5.2",
				"A.10.1.1",
				"A.11.1.4",
				"A.11.1.5",
				"A.11.2.1",
				"A.13.1.1",
				"A.13.1.3",
				"A.13.2.1",
				"A.13.2.3",
				"A.13.2.4",
				"A.14.1.2",
				"A.14.1.3",
				"A.6.1.2",
				"A.7.1.1",
				"A.7.1.2",
				"A.7.3.1",
				"A.8.2.2",
				"A.8.2.3",
				"A.9.1.1",
				"A.9.1.2",
				"A.9.2.3",
				"A.9.4.1",
				"A.9.4.4",
				"A.9.4.5",
				"CIP-003-8 R5.1.1",
				"CIP-003-8 R5.3",
				"CIP-004-6 R2.3",
				"CIP-007-3 R2.1",
				"CIP-007-3 R2.2",
				"CIP-007-3 R2.3",
				"CIP-007-3 R5.1",
				"CIP-007-3 R5.1.1",
				"CIP-007-3 R5.1.2",
				"CM-6(a)",
				"AC-6(1)",
				"PR.AC-4",
				"PR.DS-5",
				"Req-8.7.c",
				"SRG-OS-000480-GPOS-00227"
			],
			"description": " To properly set the owner of <code>/etc/group</code>, run the command: <pre>$ sudo chown root /etc/group </pre>",
			"rationale": "The <code>/etc/group</code> file contains information regarding groups that are configured\non the system. Protection of this file is important for system security.",
			"oval_definition_id": "oval:ssg-file_owner_etc_group:def:1",
			"remediations": [
				{
					"remediation_id": "file_owner_etc_group",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "\n\n\nchown 0 /etc/group\n"
				},
				{
					"remediation_id": "file_owner_etc_group",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "- name: Test for existence /etc/group\n  stat:\n    path: /etc/group\n  register: file_exists\n  tags:\n  - CCE-83925-8\n  - CJIS-5.5.2.2\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.7.c\n  - configure_strategy\n  - file_owner_etc_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner 0 on /etc/group\n  file:\n    path: /etc/group\n    owner: '0'\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - CCE-83925-8\n  - CJIS-5.5.2.2\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.7.c\n  - configure_strategy\n  - file_owner_etc_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_file_owner_etc_passwd": {
			"rule_id": "xccdf_org.ssgproject.content_rule_file_owner_etc_passwd",
			"title": "Verify User Who Owns passwd File",
			"result": "pass",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83943-1"
			],
			"references": [
				"12",
				"13",
				"14",
				"15",
				"16",
				"18",
				"3",
				"5",
				"5.5.2.2",
				"APO01.06",
				"DSS05.04",
				"DSS05.07",
				"DSS06.02",
				"CCI-002223",
				"4.3.3.7.3",
				"SR 2.1",
				"SR 5.2",
				"A.10.1.1",
				"A.11.1.4",
				"A.11.1.5",
				"A.11.2.1",
				"A.13.1.1",
				"A.13.1.3",
				"A.13.2.1",
				"A.13.2.3",
				"A.13.2.4",
				"A.14.1.2",
				"A.14.1.3",
				"A.6.1.2",
				"A.7.1.1",
				"A.7.1.2",
				"A.7.3.1",
				"A.8.2.2",
				"A.8.2.3",
				"A.9.1.1",
				"A.9.1.2",
				"A.9.2.3",
				"A.9.4.1",
				"A.9.4.4",
				"A.9.4.5",
				"CIP-003-8 R5.1.1",
				"CIP-003-8 R5.3",
				"CIP-004-6 R2.3",
				"CIP-007-3 R2.1",
				"CIP-007-3 R2.2",
				"CIP-007-3 R2.3",
				"CIP-007-3 R5.1",
				"CIP-007-3 R5.1.1",
				"CIP-007-3 R5.1.2",
				"CM-6(a)",
				"AC-6(1)",
				"PR.AC-4",
				"PR.DS-5",
				"Req-8.7.c",
				"SRG-OS-000480-GPOS-00227"
			],
			"description": " To properly set the owner of <code>/etc/passwd</code>, run the command: <pre>$ sudo chown root /etc/passwd </pre>",
			"rationale": "The <code>/etc/passwd</code> file contains information about the users that are configured on\nthe system. Protection of this file is critical for system security.",
			"oval_definition_id": "oval:ssg-file_owner_etc_passwd:def:1",
			"remediations": [
				{
					"remediation_id": "file_owner_etc_passwd",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "\n\n\nchown 0 /etc/passwd\n"
				},
				{
					"remediation_id": "file_owner_etc_passwd",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "- name: Test for existence /etc/passwd\n  stat:\n    path: /etc/passwd\n  register: file_exists\n  tags:\n  - CCE-83943-1\n  - CJIS-5.5.2.2\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.7.c\n  - configure_strategy\n  - file_owner_etc_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner 0 on /etc/passwd\n  file:\n    path: /etc/passwd\n    owner: '0'\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - CCE-83943-1\n  - CJIS-5.5.2.2\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.7.c\n  - configure_strategy\n  - file_owner_etc_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_file_owner_etc_shadow": {
			"rule_id": "xccdf_org.ssgproject.content_rule_file_owner_etc_shadow",
			"title": "Verify User Who Owns shadow File",
			"result": "pass",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83926-6"
			],
			"references": [
				"BP28(R36)",
				"12",
				"13",
				"14",
				"15",
				"16",
				"18",
				"3",
				"5",
				"5.5.2.2",
				"APO01.06",
				"DSS05.04",
				"DSS05.07",
				"DSS06.02",
				"CCI-002223",
				"4.3.3.7.3",
				"SR 2.1",
				"SR 5.2",
				"A.10.1.1",
				"A.11.1.4",
				"A.11.1.5",
				"A.11.2.1",
				"A.13.1.1",
				"A.13.1.3",
				"A.13.2.1",
				"A.13.2.3",
				"A.13.2.4",
				"A.14.1.2",
				"A.14.1.3",
				"A.6.1.2",
				"A.7.1.1",
				"A.7.1.2",
				"A.7.3.1",
				"A.8.2.2",
				"A.8.2.3",
				"A.9.1.1",
				"A.9.1.2",
				"A.9.2.3",
				"A.9.4.1",
				"A.9.4.4",
				"A.9.4.5",
				"CIP-003-8 R5.1.1",
				"CIP-003-8 R5.3",
				"CIP-004-6 R2.3",
				"CIP-007-3 R2.1",
				"CIP-007-3 R2.2",
				"CIP-007-3 R2.3",
				"CIP-007-3 R5.1",
				"CIP-007-3 R5.1.1",
				"CIP-007-3 R5.1.2",
				"CM-6(a)",
				"AC-6(1)",
				"PR.AC-4",
				"PR.DS-5",
				"Req-8.7.c",
				"SRG-OS-000480-GPOS-00227"
			],
			"description": " To properly set the owner of <code>/etc/shadow</code>, run the command: <pre>$ sudo chown root /etc/shadow </pre>",
			"rationale": "The <code>/etc/shadow</code> file contains the list of local\nsystem accounts and stores password hashes. Protection of this file is\ncritical for system security. Failure to give ownership of this file\nto root provides the designated owner with access to sensitive information\nwhich could weaken the system security posture.",
			"oval_definition_id": "oval:ssg-file_owner_etc_shadow:def:1",
			"remediations": [
				{
					"remediation_id": "file_owner_etc_shadow",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "\n\n\nchown 0 /etc/shadow\n"
				},
				{
					"remediation_id": "file_owner_etc_shadow",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "- name: Test for existence /etc/shadow\n  stat:\n    path: /etc/shadow\n  register: file_exists\n  tags:\n  - CCE-83926-6\n  - CJIS-5.5.2.2\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.7.c\n  - configure_strategy\n  - file_owner_etc_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure owner 0 on /etc/shadow\n  file:\n    path: /etc/shadow\n    owner: '0'\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - CCE-83926-6\n  - CJIS-5.5.2.2\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.7.c\n  - configure_strategy\n  - file_owner_etc_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_file_permissions_etc_group": {
			"rule_id": "xccdf_org.ssgproject.content_rule_file_permissions_etc_group",
			"title": "Verify Permissions on group File",
			"result": "pass",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83934-0"
			],
			"references": [
				"BP28(R36)",
				"12",
				"13",
				"14",
				"15",
				"16",
				"18",
				"3",
				"5",
				"5.5.2.2",
				"APO01.06",
				"DSS05.04",
				"DSS05.07",
				"DSS06.02",
				"CCI-002223",
				"4.3.3.7.3",
				"SR 2.1",
				"SR 5.2",
				"A.10.1.1",
				"A.11.1.4",
				"A.11.1.5",
				"A.11.2.1",
				"A.13.1.1",
				"A.13.1.3",
				"A.13.2.1",
				"A.13.2.3",
				"A.13.2.4",
				"A.14.1.2",
				"A.14.1.3",
				"A.6.1.2",
				"A.7.1.1",
				"A.7.1.2",
				"A.7.3.1",
				"A.8.2.2",
				"A.8.2.3",
				"A.9.1.1",
				"A.9.1.2",
				"A.9.2.3",
				"A.9.4.1",
				"A.9.4.4",
				"A.9.4.5",
				"CIP-003-8 R5.1.1",
				"CIP-003-8 R5.3",
				"CIP-004-6 R2.3",
				"CIP-007-3 R2.1",
				"CIP-007-3 R2.2",
				"CIP-007-3 R2.3",
				"CIP-007-3 R5.1",
				"CIP-007-3 R5.1.1",
				"CIP-007-3 R5.1.2",
				"CM-6(a)",
				"AC-6(1)",
				"PR.AC-4",
				"PR.DS-5",
				"Req-8.7.c",
				"SRG-OS-000480-GPOS-00227"
			],
			"description": "\nTo properly set the permissions of <code>/etc/passwd</code>, run the command:\n<pre>$ sudo chmod 0644 /etc/passwd</pre>",
			"rationale": "The <code>/etc/group</code> file contains information regarding groups that are configured\non the system. Protection of this file is important for system security.",
			"oval_definition_id": "oval:ssg-file_permissions_etc_group:def:1",
			"remediations": [
				{
					"remediation_id": "file_permissions_etc_group",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "\n\n\n\nchmod u-xs,g-xws,o-xwt /etc/group\n"
				},
				{
					"remediation_id": "file_permissions_etc_group",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "- name: Test for existence /etc/group\n  stat:\n    path: /etc/group\n  register: file_exists\n  tags:\n  - CCE-83934-0\n  - CJIS-5.5.2.2\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.7.c\n  - configure_strategy\n  - file_permissions_etc_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure permission u-xs,g-xws,o-xwt on /etc/group\n  file:\n    path: /etc/group\n    mode: u-xs,g-xws,o-xwt\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - CCE-83934-0\n  - CJIS-5.5.2.2\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.7.c\n  - configure_strategy\n  - file_permissions_etc_group\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_file_permissions_etc_passwd": {
			"rule_id": "xccdf_org.ssgproject.content_rule_file_permissions_etc_passwd",
			"title": "Verify Permissions on passwd File",
			"result": "pass",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83931-6"
			],
			"references": [
				"BP28(R36)",
				"12",
				"13",
				"14",
				"15",
				"16",
				"18",
				"3",
				"5",
				"5.5.2.2",
				"APO01.06",
				"DSS05.04",
				"DSS05.07",
				"DSS06.02",
				"CCI-002223",
				"4.3.3.7.3",
				"SR 2.1",
				"SR 5.2",
				"A.10.1.1",
				"A.11.1.4",
				"A.11.1.5",
				"A.11.2.1",
				"A.13.1.1",
				"A.13.1.3",
				"A.13.2.1",
				"A.13.2.3",
				"A.13.2.4",
				"A.14.1.2",
				"A.14.1.3",
				"A.6.1.2",
				"A.7.1.1",
				"A.7.1.2",
				"A.7.3.1",
				"A.8.2.2",
				"A.8.2.3",
				"A.9.1.1",
				"A.9.1.2",
				"A.9.2.3",
				"A.9.4.1",
				"A.9.4.4",
				"A.9.4.5",
				"CIP-003-8 R5.1.1",
				"CIP-003-8 R5.3",
				"CIP-004-6 R2.3",
				"CIP-007-3 R2.1",
				"CIP-007-3 R2.2",
				"CIP-007-3 R2.3",
				"CIP-007-3 R5.1",
				"CIP-007-3 R5.1.1",
				"CIP-007-3 R5.1.2",
				"CM-6(a)",
				"AC-6(1)",
				"PR.AC-4",
				"PR.DS-5",
				"Req-8.7.c",
				"SRG-OS-000480-GPOS-00227"
			],
			"description": "\nTo properly set the permissions of <code>/etc/passwd</code>, run the command:\n<pre>$ sudo chmod 0644 /etc/passwd</pre>",
			"rationale": "If the <code>/etc/passwd</code> file is writable by a group-owner or the\nworld the risk of its compromise is increased. The file contains the list of\naccounts on the system and associated information, and protection of this file\nis critical for system security.",
			"oval_definition_id": "oval:ssg-file_permissions_etc_passwd:def:1",
			"remediations": [
				{
					"remediation_id": "file_permissions_etc_passwd",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "\n\n\n\nchmod u-xs,g-xws,o-xwt /etc/passwd\n"
				},
				{
					"remediation_id": "file_permissions_etc_passwd",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "- name: Test for existence /etc/passwd\n  stat:\n    path: /etc/passwd\n  register: file_exists\n  tags:\n  - CCE-83931-6\n  - CJIS-5.5.2.2\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.7.c\n  - configure_strategy\n  - file_permissions_etc_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure permission u-xs,g-xws,o-xwt on /etc/passwd\n  file:\n    path: /etc/passwd\n    mode: u-xs,g-xws,o-xwt\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - CCE-83931-6\n  - CJIS-5.5.2.2\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.7.c\n  - configure_strategy\n  - file_permissions_etc_passwd\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_file_permissions_etc_shadow": {
			"rule_id": "xccdf_org.ssgproject.content_rule_file_permissions_etc_shadow",
			"title": "Verify Permissions on shadow File",
			"result": "pass",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-83941-5"
			],
			"references": [
				"BP28(R36)",
				"12",
				"13",
				"14",
				"15",
				"16",
				"18",
				"3",
				"5",
				"5.5.2.2",
				"APO01.06",
				"DSS05.04",
				"DSS05.07",
				"DSS06.02",
				"CCI-002223",
				"4.3.3.7.3",
				"SR 2.1",
				"SR 5.2",
				"A.10.1.1",
				"A.11.1.4",
				"A.11.1.5",
				"A.11.2.1",
				"A.13.1.1",
				"A.13.1.3",
				"A.13.2.1",
				"A.13.2.3",
				"A.13.2.4",
				"A.14.1.2",
				"A.14.1.3",
				"A.6.1.2",
				"A.7.1.1",
				"A.7.1.2",
				"A.7.3.1",
				"A.8.2.2",
				"A.8.2.3",
				"A.9.1.1",
				"A.9.1.2",
				"A.9.2.3",
				"A.9.4.1",
				"A.9.4.4",
				"A.9.4.5",
				"CIP-003-8 R5.1.1",
				"CIP-003-8 R5.3",
				"CIP-004-6 R2.3",
				"CIP-007-3 R2.1",
				"CIP-007-3 R2.2",
				"CIP-007-3 R2.3",
				"CIP-007-3 R5.1",
				"CIP-007-3 R5.1.1",
				"CIP-007-3 R5.1.2",
				"CM-6(a)",
				"AC-6(1)",
				"PR.AC-4",
				"PR.DS-5",
				"Req-8.7.c",
				"SRG-OS-000480-GPOS-00227"
			],
			"description": "\nTo properly set the permissions of <code>/etc/shadow</code>, run the command:\n<pre>$ sudo chmod 0000 /etc/shadow</pre>",
			"rationale": "The <code>/etc/shadow</code> file contains the list of local\nsystem accounts and stores password hashes. Protection of this file is\ncritical for system security. Failure to give ownership of this file\nto root provides the designated owner with access to sensitive information\nwhich could weaken the system security posture.",
			"oval_definition_id": "oval:ssg-file_permissions_etc_shadow:def:1",
			"remediations": [
				{
					"remediation_id": "file_permissions_etc_shadow",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "\n\n\n\nchmod u-xwrs,g-xwrs,o-xwrt /etc/shadow\n"
				},
				{
					"remediation_id": "file_permissions_etc_shadow",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "- name: Test for existence /etc/shadow\n  stat:\n    path: /etc/shadow\n  register: file_exists\n  tags:\n  - CCE-83941-5\n  - CJIS-5.5.2.2\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.7.c\n  - configure_strategy\n  - file_permissions_etc_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Ensure permission u-xwrs,g-xwrs,o-xwrt on /etc/shadow\n  file:\n    path: /etc/shadow\n    mode: u-xwrs,g-xwrs,o-xwrt\n  when: file_exists.stat is defined and file_exists.stat.exists\n  tags:\n  - CCE-83941-5\n  - CJIS-5.5.2.2\n  - NIST-800-53-AC-6(1)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-8.7.c\n  - configure_strategy\n  - file_permissions_etc_shadow\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_service_chronyd_enabled": {
			"rule_id": "xccdf_org.ssgproject.content_rule_service_chronyd_enabled",
			"title": "The Chronyd service is enabled",
			"result": "pass",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-84217-9"
			],
			"references": [
				"0988",
				"1405"
			],
			"description": "chrony is a daemon which implements the Network Time Protocol (NTP) is designed to\nsynchronize system clocks across a variety of systems and use a source that is highly\naccurate. More information on chrony can be found at\n\n    <a href=\"http://chrony.tuxfamily.org/\">http://chrony.tuxfamily.org/</a>.\nChrony can be configured to be a client and/or a server.\nTo enable Chronyd service, you can run:\n<code># systemctl enable chronyd.service</code>\nThis recommendation only applies if chrony is in use on the system.",
			"rationale": "If chrony is in use on the system proper configuration is vital to ensuring time\nsynchronization is working properly.",
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-service_chronyd_enabled:def:1",
			"remediations": [
				{
					"remediation_id": "service_chronyd_enabled",
					"system": "urn:redhat:osbuild:blueprint",
					"fix": "\n[customizations.services]\nenabled = [\"chronyd\"]\n"
				},
				{
					"remediation_id": "service_chronyd_enabled",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nSYSTEMCTL_EXEC='/usr/bin/systemctl'\n\"$SYSTEMCTL_EXEC\" unmask 'chronyd.service'\n\"$SYSTEMCTL_EXEC\" start 'chronyd.service'\n\"$SYSTEMCTL_EXEC\" enable 'chronyd.service'\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "service_chronyd_enabled",
					"system": "urn:xccdf:fix:script:puppet",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "include enable_chronyd\n\nclass enable_chronyd {\n  service {'chronyd':\n    enable => true,\n    ensure => 'running',\n  }\n}\n"
				},
				{
					"remediation_id": "service_chronyd_enabled",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "enable",
					"fix": "- name: Enable service chronyd\n  block:\n\n  - name: Gather the package facts\n    package_facts:\n      manager: auto\n\n  - name: Enable service chronyd\n    service:\n      name: chronyd\n      enabled: 'yes'\n      state: started\n      masked: 'no'\n    when:\n    - '\"chrony\" in ansible_facts.packages'\n  when: ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-84217-9\n  - enable_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n  - service_chronyd_enabled\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_chronyd_specify_remote_server": {
			"rule_id": "xccdf_org.ssgproject.content_rule_chronyd_specify_remote_server",
			"title": "A remote time server for Chrony is configured",
			"result": "pass",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-84218-7"
			],
			"references": [
				"BP28(R43)",
				"CCI-000160",
				"CCI-001891",
				"0988",
				"1405",
				"CM-6(a)",
				"AU-8(1)(a)",
				"Req-10.4.3"
			],
			"description": "<code>Chrony</code> is a daemon which implements the Network Time Protocol (NTP). It is designed to\nsynchronize system clocks across a variety of systems and use a source that is highly\naccurate. More information on <code>chrony</code> can be found at\n\n    <a href=\"http://chrony.tuxfamily.org/\">http://chrony.tuxfamily.org/</a>.\n<code>Chrony</code> can be configured to be a client and/or a server.\nAdd or edit server or pool lines to <code>/etc/chrony.conf</code> as appropriate:\n<pre>server &lt;remote-server&gt;</pre>\nMultiple servers may be configured.",
			"rationale": "If <code>chrony</code> is in use on the system proper configuration is vital to ensuring time\nsynchronization is working properly.",
			"platforms": [
				"#chrony"
			],
			"oval_definition_id": "oval:ssg-chronyd_specify_remote_server:def:1",
			"remediations": [
				{
					"remediation_id": "chronyd_specify_remote_server",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ] && { rpm --quiet -q chrony; }; then\n\nvar_multiple_time_servers='0.rhel.pool.ntp.org,1.rhel.pool.ntp.org,2.rhel.pool.ntp.org,3.rhel.pool.ntp.org'\n\n\nconfig_file=\"/etc/chrony.conf\"\n\nif ! grep -q '^[\\s]*(?:server|pool)[\\s]+[\\w]+' \"$config_file\" ; then\n  if ! grep -q '#[[:space:]]*server' \"$config_file\" ; then\n    for server in $(echo \"$var_multiple_time_servers\" | tr ',' '\\n') ; do\n      printf '\\nserver %s' \"$server\" >> \"$config_file\"\n    done\n  else\n    sed -i 's/#[ \\t]*server/server/g' \"$config_file\"\n  fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "chronyd_specify_remote_server",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "low",
					"strategy": "configure",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-84218-7\n  - NIST-800-53-AU-8(1)(a)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.4.3\n  - chronyd_specify_remote_server\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n- name: XCCDF Value var_multiple_time_servers # promote to variable\n  set_fact:\n    var_multiple_time_servers: !!str 0.rhel.pool.ntp.org,1.rhel.pool.ntp.org,2.rhel.pool.ntp.org,3.rhel.pool.ntp.org\n  tags:\n    - always\n\n- name: Detect if chrony is already configured with pools or servers\n  find:\n    path: /etc\n    patterns: chrony.conf\n    contains: ^[\\s]*(?:server|pool)[\\s]+[\\w]+\n  register: chrony_servers\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - '\"chrony\" in ansible_facts.packages'\n  tags:\n  - CCE-84218-7\n  - NIST-800-53-AU-8(1)(a)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.4.3\n  - chronyd_specify_remote_server\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n\n- name: Configure remote time servers\n  lineinfile:\n    path: /etc/chrony.conf\n    line: server {{ item }}\n    state: present\n    create: true\n  loop: '{{ var_multiple_time_servers.split(\",\") }}'\n  when:\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - '\"chrony\" in ansible_facts.packages'\n  - chrony_servers.matched == 0\n  tags:\n  - CCE-84218-7\n  - NIST-800-53-AU-8(1)(a)\n  - NIST-800-53-CM-6(a)\n  - PCI-DSS-Req-10.4.3\n  - chronyd_specify_remote_server\n  - configure_strategy\n  - low_complexity\n  - low_disruption\n  - medium_severity\n  - no_reboot_needed\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_sshd_use_directory_configuration": {
			"rule_id": "xccdf_org.ssgproject.content_rule_sshd_use_directory_configuration",
			"title": "Distribute the SSH Server configuration to multiple files in a config directory.",
			"result": "error",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-87681-3"
			],
			"description": "Make sure to have the <code>Include /etc/ssh/sshd_config.d/*.conf</code> line in the <code>/etc/ssh/sshd_config</code> file.\nIdeally, don&#x27;t have any active configuration directives in that file, and distribute the service configuration\nto several files in the <code>/etc/ssh/sshd_config.d</code> directory.",
			"rationale": "This form of distributed configuration is considered as a good practice, and as other sshd rules assume that directives in files in the <code>/etc/ssh/sshd_config.d</code> config directory are effective, there has to be a rule that ensures this.\nAside from that, having multiple configuration files makes the SSH Server configuration changes easier to partition according to the reason that they were introduced, and therefore it should help to perform merges of hardening updates.",
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-sshd_use_directory_configuration:def:1",
			"remediations": [
				{
					"remediation_id": "sshd_use_directory_configuration",
					"system": "urn:xccdf:fix:script:sh",
					"fix": "# Remediation is applicable only in certain platforms\nif [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; then\n\nif test -f /etc/ssh/sshd_config.d/sshd_config_original.conf; then\n\tprintf '%s\\n' \"Remediation probably already happened, '/etc/ssh/sshd_config.d/sshd_config_original.conf' already exists, not doing anything.\" >&2\nfalse 1\nelif grep -Eq '^\\s*Include\\s+/etc/ssh/sshd_config\\.d/\\*\\.conf' /etc/ssh/sshd_config && ! grep -Eq '^\\s*Match\\s' /etc/ssh/sshd_config; then\n\tprintf '%s\\n' \"Remediation probably already happened, '/etc/ssh/sshd_config' already contains the include directive.\" >&2\nfalse 1\nelse\n\tmkdir -p /etc/ssh/sshd_config.d\n\tmv /etc/ssh/sshd_config /etc/ssh/sshd_config.d/sshd_config_original.conf\ncat > /etc/ssh/sshd_config << EOF\n# To modify the system-wide sshd configuration, create a  *.conf  file under\n#  /etc/ssh/sshd_config.d/  which will be automatically included below\n\nInclude /etc/ssh/sshd_config.d/*.conf\nEOF\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				}
			]
		},
		"xccdf_org.ssgproject.content_rule_sssd_enable_smartcards": {
			"rule_id": "xccdf_org.ssgproject.content_rule_sssd_enable_smartcards",
			"title": "Enable Smartcards in SSSD",
			"result": "fail",
			"time": "2022-10-26T09:46:14+01:00",
			"severity": "medium",
			"identifiers": [
				"CCE-89155-6"
			],
			"references": [
				"CCI-001954",
				"CCI-000765",
				"CCI-000766",
				"CCI-000767",
				"CCI-000768",
				"0421",
				"0422",
				"0431",
				"0974",
				"1173",
				"1401",
				"1504",
				"1505",
				"1546",
				"1557",
				"1558",
				"1559",
				"1560",
				"1561",
				"SRG-OS-000375-GPOS-00160",
				"SRG-OS-000105-GPOS-00052",
				"SRG-OS-000106-GPOS-00053",
				"SRG-OS-000107-GPOS-00054",
				"SRG-OS-000108-GPOS-00055",
				"SRG-OS-000107-VMM-000530"
			],
			"description": "SSSD should be configured to authenticate access to the system using smart cards.\nTo enable smart cards in SSSD, set <code>pam_cert_auth</code> to <code>True</code> under the\n<code>[pam]</code> section in <code>/etc/sssd/sssd.conf</code>. For example:\n<pre>[pam]\npam_cert_auth = True\n</pre>\n\nAdd or update &quot;pam_sss.so&quot; line in auth section of &quot;/etc/pam.d/system-auth&quot; file to include\n&quot;try_cert_auth&quot; or &quot;require_cert_auth&quot; option, like in the following example:\n<pre>\n/etc/pam.d/system-auth:auth [success=done authinfo_unavail=ignore ignore=ignore default=die] pam_sss.so try_cert_auth\n</pre>\nAlso add or update &quot;pam_sss.so&quot; line in auth section of &quot;/etc/pam.d/smartcard-auth&quot; file to\ninclude the &quot;allow_missing_name&quot; option, like in the following example:\n<pre>/etc/pam.d/smartcard-auth:auth sufficient pam_sss.so allow_missing_name</pre>",
			"rationale": "Using an authentication device, such as a CAC or token that is separate from\nthe information system, ensures that even if the information system is\ncompromised, that compromise will not affect credentials stored on the\nauthentication device.\n<br><br>\nMulti-Factor Authentication (MFA) solutions that require devices separate from\ninformation systems gaining access include, for example, hardware tokens\nproviding time-based or challenge-response authenticators and smart cards such\nas the U.S. Government Personal Identity Verification card and the DoD Common\nAccess Card.",
			"platforms": [
				"#machine"
			],
			"oval_definition_id": "oval:ssg-sssd_enable_smartcards:def:1",
			"remediations": [
				{
					"remediation_id": "sssd_enable_smartcards",
					"system": "urn:xccdf:fix:script:sh",
					"complexity": "low",
					"disruption": "medium",
					"strategy": "configure",
					"fix": "# Remediation is applicable only in certain platforms\nif rpm --quiet -q sssd-common && { [ ! -f /.dockerenv ] && [ ! -f /run/.containerenv ]; }; then\n\nfound=false\n\n# set value in all files if they contain section or key\nfor f in $(echo -n \"/etc/sssd/sssd.conf\"); do\n    if [ ! -e \"$f\" ]; then\n        continue\n    fi\n\n    # find key in section and change value\n    if grep -qzosP \"[[:space:]]*\\[pam\\]([^\\n\\[]*\\n+)+?[[:space:]]*pam_cert_auth\" \"$f\"; then\n            sed -i \"s/pam_cert_auth[^(\\n)]*/pam_cert_auth = True/\" \"$f\"\n            found=true\n\n    # find section and add key = value to it\n    elif grep -qs \"[[:space:]]*\\[pam\\]\" \"$f\"; then\n            sed -i \"/[[:space:]]*\\[pam\\]/a pam_cert_auth = True\" \"$f\"\n            found=true\n    fi\ndone\n\n# if section not in any file, append section with key = value to FIRST file in files parameter\nif ! $found ; then\n    file=$(echo \"/etc/sssd/sssd.conf\" | cut -f1 -d ' ')\n    mkdir -p \"$(dirname \"$file\")\"\n    echo -e \"[pam]\\npam_cert_auth = True\" >> \"$file\"\nfi\n\n\nif [ -f /usr/bin/authselect ]; then\n    if authselect check; then\n        if ! authselect check; then\n        echo \"\n        authselect integrity check failed. Remediation aborted!\n        This remediation could not be applied because an authselect profile was not selected or the selected profile is not intact.\n        It is not recommended to manually edit the PAM files when authselect tool is available.\n        In cases where the default authselect profile does not cover a specific demand, a custom authselect profile is recommended.\"\n        exit 1\n        fi\n        authselect enable-feature with-smartcard\n\n        authselect apply-changes -b\n    fi\nelse\n    if ! grep -qP '^\\s*auth\\s+'\"sufficient\"'\\s+pam_sss.so\\s*.*' \"/etc/pam.d/smartcard-auth\"; then\n        # Line matching group + control + module was not found. Check group + module.\n        if [ \"$(grep -cP '^\\s*auth\\s+.*\\s+pam_sss.so\\s*' \"/etc/pam.d/smartcard-auth\")\" -eq 1 ]; then\n            # The control is updated only if one single line matches.\n            sed -i -E --follow-symlinks 's/^(\\s*auth\\s+).*(\\bpam_sss.so.*)/\\1'\"sufficient\"' \\2/' \"/etc/pam.d/smartcard-auth\"\n        else\n            echo 'auth    '\"sufficient\"'    pam_sss.so' >> \"/etc/pam.d/smartcard-auth\"\n        fi\n    fi\n    # Check the option\n    if ! grep -qP '^\\s*auth\\s+'\"sufficient\"'\\s+pam_sss.so\\s*.*\\sallow_missing_name\\b' \"/etc/pam.d/smartcard-auth\"; then\n        sed -i -E --follow-symlinks '/\\s*auth\\s+'\"sufficient\"'\\s+pam_sss.so.*/ s/$/ allow_missing_name/' \"/etc/pam.d/smartcard-auth\"\n    fi\n    if ! grep -qP '^\\s*auth\\s+'\"\\[success=done authinfo_unavail=ignore ignore=ignore default=die\\]\"'\\s+pam_sss.so\\s*.*' \"/etc/pam.d/system-auth\"; then\n        # Line matching group + control + module was not found. Check group + module.\n        if [ \"$(grep -cP '^\\s*auth\\s+.*\\s+pam_sss.so\\s*' \"/etc/pam.d/system-auth\")\" -eq 1 ]; then\n            # The control is updated only if one single line matches.\n            sed -i -E --follow-symlinks 's/^(\\s*auth\\s+).*(\\bpam_sss.so.*)/\\1'\"\\[success=done authinfo_unavail=ignore ignore=ignore default=die\\]\"' \\2/' \"/etc/pam.d/system-auth\"\n        else\n            echo 'auth    '\"\\[success=done authinfo_unavail=ignore ignore=ignore default=die\\]\"'    pam_sss.so' >> \"/etc/pam.d/system-auth\"\n        fi\n    fi\n    # Check the option\n    if ! grep -qP '^\\s*auth\\s+'\"\\[success=done authinfo_unavail=ignore ignore=ignore default=die\\]\"'\\s+pam_sss.so\\s*.*\\stry_cert_auth\\b' \"/etc/pam.d/system-auth\"; then\n        sed -i -E --follow-symlinks '/\\s*auth\\s+'\"\\[success=done authinfo_unavail=ignore ignore=ignore default=die\\]\"'\\s+pam_sss.so.*/ s/$/ try_cert_auth/' \"/etc/pam.d/system-auth\"\n    fi\nfi\n\nelse\n    >&2 echo 'Remediation is not applicable, nothing was done'\nfi\n"
				},
				{
					"remediation_id": "sssd_enable_smartcards",
					"system": "urn:xccdf:fix:script:ansible",
					"complexity": "low",
					"disruption": "medium",
					"strategy": "configure",
					"fix": "- name: Gather the package facts\n  package_facts:\n    manager: auto\n  tags:\n  - CCE-89155-6\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - sssd_enable_smartcards\n\n- name: Test for domain group\n  command: grep '^\\s*\\[domain\\/[^]]*]' /etc/sssd/sssd.conf\n  register: test_grep_domain\n  ignore_errors: true\n  changed_when: false\n  check_mode: false\n  when:\n  - '\"sssd-common\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-89155-6\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - sssd_enable_smartcards\n\n- name: Add default domain group (if no domain there)\n  ini_file:\n    path: /etc/sssd/sssd.conf\n    section: '{{ item.section }}'\n    option: '{{ item.option }}'\n    value: '{{ item.value }}'\n    create: true\n    mode: 384\n  with_items:\n  - section: sssd\n    option: domains\n    value: default\n  - section: domain/default\n    option: id_provider\n    value: files\n  when:\n  - '\"sssd-common\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - test_grep_domain.stdout is defined\n  - test_grep_domain.stdout | length < 1\n  tags:\n  - CCE-89155-6\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - sssd_enable_smartcards\n\n- name: Enable Smartcards in SSSD\n  ini_file:\n    dest: /etc/sssd/sssd.conf\n    section: pam\n    option: pam_cert_auth\n    value: 'True'\n    create: true\n    mode: 384\n  when:\n  - '\"sssd-common\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-89155-6\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - sssd_enable_smartcards\n\n- name: Enable Smartcards in SSSD - Check if system relies on authselect\n  ansible.builtin.stat:\n    path: /usr/bin/authselect\n  register: result_authselect_present\n  when:\n  - '\"sssd-common\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  tags:\n  - CCE-89155-6\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - sssd_enable_smartcards\n\n- name: Enable Smartcards in SSSD - Remediate using authselect\n  block:\n\n  - name: Enable Smartcards in SSSD - Check integrity of authselect current profile\n    ansible.builtin.command:\n      cmd: authselect check\n    register: result_authselect_check_cmd\n    changed_when: false\n    ignore_errors: true\n\n  - name: Enable Smartcards in SSSD - Informative message based on the authselect\n      integrity check result\n    ansible.builtin.assert:\n      that:\n      - result_authselect_check_cmd is success\n      fail_msg:\n      - authselect integrity check failed. Remediation aborted!\n      - This remediation could not be applied because an authselect profile was not\n        selected or the selected profile is not intact.\n      - It is not recommended to manually edit the PAM files when authselect tool\n        is available.\n      - In cases where the default authselect profile does not cover a specific demand,\n        a custom authselect profile is recommended.\n      success_msg:\n      - authselect integrity check passed\n\n  - name: Enable Smartcards in SSSD - Get authselect current features\n    ansible.builtin.shell:\n      cmd: authselect current | tail -n+3 | awk '{ print $2 }'\n    register: result_authselect_features\n    changed_when: false\n    when:\n    - result_authselect_check_cmd is success\n\n  - name: Enable Smartcards in SSSD - Ensure \"with-smartcard\" feature is enabled using\n      authselect tool\n    ansible.builtin.command:\n      cmd: authselect enable-feature with-smartcard\n    register: result_authselect_enable_feature_cmd\n    when:\n    - result_authselect_check_cmd is success\n    - result_authselect_features.stdout is not search(\"with-smartcard\")\n\n  - name: Enable Smartcards in SSSD - Ensure authselect changes are applied\n    ansible.builtin.command:\n      cmd: authselect apply-changes -b\n    when:\n    - result_authselect_enable_feature_cmd is not skipped\n    - result_authselect_enable_feature_cmd is success\n  when:\n  - '\"sssd-common\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - result_authselect_present.stat.exists\n  tags:\n  - CCE-89155-6\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - sssd_enable_smartcards\n\n- name: Enable Smartcards in SSSD - Remediate by directly editing PAM files\n  block:\n\n  - name: Enable Smartcards in SSSD - Check if expected PAM module line is present\n      in /etc/pam.d/smartcard-auth\n    ansible.builtin.lineinfile:\n      path: /etc/pam.d/smartcard-auth\n      regexp: ^\\s*auth\\s+sufficient\\s+pam_sss.so\\s*.*\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_line_present\n\n  - name: Enable Smartcards in SSSD - Include or update the PAM module line in /etc/pam.d/smartcard-auth\n    block:\n\n    - name: Enable Smartcards in SSSD - Check if required PAM module line is present\n        in /etc/pam.d/smartcard-auth with different control\n      ansible.builtin.lineinfile:\n        path: /etc/pam.d/smartcard-auth\n        regexp: ^\\s*auth\\s+.*\\s+pam_sss.so\\s*\n        state: absent\n      check_mode: true\n      changed_when: false\n      register: result_pam_line_other_control_present\n\n    - name: Enable Smartcards in SSSD - Ensure the correct control for the required\n        PAM module line in /etc/pam.d/smartcard-auth\n      ansible.builtin.replace:\n        dest: /etc/pam.d/smartcard-auth\n        regexp: ^(\\s*auth\\s+).*(\\bpam_sss.so.*)\n        replace: \\1sufficient \\2\n      register: result_pam_module_edit\n      when:\n      - result_pam_line_other_control_present.found == 1\n\n    - name: Enable Smartcards in SSSD - Ensure the required PAM module line is included\n        in /etc/pam.d/smartcard-auth\n      ansible.builtin.lineinfile:\n        dest: /etc/pam.d/smartcard-auth\n        line: auth    sufficient    pam_sss.so\n      register: result_pam_module_add\n      when:\n      - result_pam_line_other_control_present.found == 0 or result_pam_line_other_control_present.found\n        > 1\n\n    - name: Enable Smartcards in SSSD - Ensure authselect changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b\n      when:\n      - result_authselect_present.stat.exists\n      - (result_pam_module_add is defined and result_pam_module_add.changed) or (result_pam_module_edit\n        is defined and result_pam_module_edit.changed)\n    when:\n    - result_pam_line_present.found is defined\n    - result_pam_line_present.found == 0\n\n  - name: Enable Smartcards in SSSD - Check if the required PAM module option is present\n      in /etc/pam.d/smartcard-auth\n    ansible.builtin.lineinfile:\n      path: /etc/pam.d/smartcard-auth\n      regexp: ^\\s*auth\\s+sufficient\\s+pam_sss.so\\s*.*\\sallow_missing_name\\b\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_module_allow_missing_name_option_present\n\n  - name: Enable Smartcards in SSSD - Ensure the \"allow_missing_name\" PAM option for\n      \"pam_sss.so\" is included in /etc/pam.d/smartcard-auth\n    ansible.builtin.lineinfile:\n      path: /etc/pam.d/smartcard-auth\n      backrefs: true\n      regexp: ^(\\s*auth\\s+sufficient\\s+pam_sss.so.*)\n      line: \\1 allow_missing_name\n      state: present\n    register: result_pam_allow_missing_name_add\n    when:\n    - result_pam_module_allow_missing_name_option_present.found == 0\n\n  - name: Enable Smartcards in SSSD - Check if expected PAM module line is present\n      in /etc/pam.d/system-auth\n    ansible.builtin.lineinfile:\n      path: /etc/pam.d/system-auth\n      regexp: ^\\s*auth\\s+\\[success=done authinfo_unavail=ignore ignore=ignore default=die\\]\\s+pam_sss.so\\s*.*\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_line_present\n\n  - name: Enable Smartcards in SSSD - Include or update the PAM module line in /etc/pam.d/system-auth\n    block:\n\n    - name: Enable Smartcards in SSSD - Check if required PAM module line is present\n        in /etc/pam.d/system-auth with different control\n      ansible.builtin.lineinfile:\n        path: /etc/pam.d/system-auth\n        regexp: ^\\s*auth\\s+.*\\s+pam_sss.so\\s*\n        state: absent\n      check_mode: true\n      changed_when: false\n      register: result_pam_line_other_control_present\n\n    - name: Enable Smartcards in SSSD - Ensure the correct control for the required\n        PAM module line in /etc/pam.d/system-auth\n      ansible.builtin.replace:\n        dest: /etc/pam.d/system-auth\n        regexp: ^(\\s*auth\\s+).*(\\bpam_sss.so.*)\n        replace: \\1\\[success=done authinfo_unavail=ignore ignore=ignore default=die\\]\n          \\2\n      register: result_pam_module_edit\n      when:\n      - result_pam_line_other_control_present.found == 1\n\n    - name: Enable Smartcards in SSSD - Ensure the required PAM module line is included\n        in /etc/pam.d/system-auth\n      ansible.builtin.lineinfile:\n        dest: /etc/pam.d/system-auth\n        line: auth    \\[success=done authinfo_unavail=ignore ignore=ignore default=die\\]    pam_sss.so\n      register: result_pam_module_add\n      when:\n      - result_pam_line_other_control_present.found == 0 or result_pam_line_other_control_present.found\n        > 1\n\n    - name: Enable Smartcards in SSSD - Ensure authselect changes are applied\n      ansible.builtin.command:\n        cmd: authselect apply-changes -b\n      when:\n      - result_authselect_present.stat.exists\n      - (result_pam_module_add is defined and result_pam_module_add.changed) or (result_pam_module_edit\n        is defined and result_pam_module_edit.changed)\n    when:\n    - result_pam_line_present.found is defined\n    - result_pam_line_present.found == 0\n\n  - name: Enable Smartcards in SSSD - Check if the required PAM module option is present\n      in /etc/pam.d/system-auth\n    ansible.builtin.lineinfile:\n      path: /etc/pam.d/system-auth\n      regexp: ^\\s*auth\\s+\\[success=done authinfo_unavail=ignore ignore=ignore default=die\\]\\s+pam_sss.so\\s*.*\\stry_cert_auth\\b\n      state: absent\n    check_mode: true\n    changed_when: false\n    register: result_pam_module_try_cert_auth_option_present\n\n  - name: Enable Smartcards in SSSD - Ensure the \"try_cert_auth\" PAM option for \"pam_sss.so\"\n      is included in /etc/pam.d/system-auth\n    ansible.builtin.lineinfile:\n      path: /etc/pam.d/system-auth\n      backrefs: true\n      regexp: ^(\\s*auth\\s+\\[success=done authinfo_unavail=ignore ignore=ignore default=die\\]\\s+pam_sss.so.*)\n      line: \\1 try_cert_auth\n      state: present\n    register: result_pam_try_cert_auth_add\n    when:\n    - result_pam_module_try_cert_auth_option_present.found == 0\n  when:\n  - '\"sssd-common\" in ansible_facts.packages'\n  - ansible_virtualization_type not in [\"docker\", \"lxc\", \"openvz\", \"podman\", \"container\"]\n  - not result_authselect_present.stat.exists\n  tags:\n  - CCE-89155-6\n  - configure_strategy\n  - low_complexity\n  - medium_disruption\n  - medium_severity\n  - no_reboot_needed\n  - sssd_enable_smartcards\n"
				}
			]
		}
	},
	"references": {
		"11": "https://www.cisecurity.org/controls/",
		"2": "https://www.cisecurity.org/controls/",
		"3": "https://www.cisecurity.org/controls/",
		"9": "https://www.cisecurity.org/controls/",
		"5.10.4.1": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
		"APO01.06": "https://www.isaca.org/resources/cobit",
		"BAI03.05": "https://www.isaca.org/resources/cobit",
		"BAI06.01": "https://www.isaca.org/resources/cobit",
		"BAI10.01": "https://www.isaca.org/resources/cobit",
		"BAI10.02": "https://www.isaca.org/resources/cobit",
		"BAI10.03": "https://www.isaca.org/resources/cobit",
		"BAI10.05": "https://www.isaca.org/resources/cobit",
		"DSS06.02": "https://www.isaca.org/resources/cobit",
		"3.3.8": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
		"3.4.1": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
		"CCI-000366": "https://public.cyber.mil/stigs/cci/",
		"CCI-001749": "https://public.cyber.mil/stigs/cci/",
		"164.308(a)(1)(ii)(D)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"164.312(b)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"164.312(c)(1)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"164.312(c)(2)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"164.312(e)(2)(i)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"4.3.4.3.2": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.3.4.3.3": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.3.4.4.4": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"SR 3.1": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"SR 3.3": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"SR 3.4": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"SR 3.8": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"SR 7.6": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"A.11.2.4": "https://www.iso.org/standard/54534.html",
		"A.12.1.2": "https://www.iso.org/standard/54534.html",
		"A.12.2.1": "https://www.iso.org/standard/54534.html",
		"A.12.5.1": "https://www.iso.org/standard/54534.html",
		"A.12.6.2": "https://www.iso.org/standard/54534.html",
		"A.14.1.2": "https://www.iso.org/standard/54534.html",
		"A.14.1.3": "https://www.iso.org/standard/54534.html",
		"A.14.2.2": "https://www.iso.org/standard/54534.html",
		"A.14.2.3": "https://www.iso.org/standard/54534.html",
		"A.14.2.4": "https://www.iso.org/standard/54534.html",
		"CM-6(d)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"CM-6(c)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"SI-7": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"SI-7(1)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"SI-7(6)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"AU-9(3)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"PR.DS-6": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"PR.DS-8": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"PR.IP-1": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"Req-11.5": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"SRG-OS-000480-GPOS-00227": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"1": "https://www.cisecurity.org/controls/",
		"12": "https://www.cisecurity.org/controls/",
		"13": "https://www.cisecurity.org/controls/",
		"14": "https://www.cisecurity.org/controls/",
		"15": "https://www.cisecurity.org/controls/",
		"16": "https://www.cisecurity.org/controls/",
		"18": "https://www.cisecurity.org/controls/",
		"5": "https://www.cisecurity.org/controls/",
		"6": "https://www.cisecurity.org/controls/",
		"APO11.04": "https://www.isaca.org/resources/cobit",
		"DSS05.04": "https://www.isaca.org/resources/cobit",
		"DSS05.07": "https://www.isaca.org/resources/cobit",
		"MEA02.01": "https://www.isaca.org/resources/cobit",
		"CCI-001493": "https://public.cyber.mil/stigs/cci/",
		"CCI-001494": "https://public.cyber.mil/stigs/cci/",
		"CCI-001495": "https://public.cyber.mil/stigs/cci/",
		"CCI-001496": "https://public.cyber.mil/stigs/cci/",
		"4.3.3.3.9": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.3.3.5.8": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.3.3.7.3": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.3.4.4.7": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.4.2.1": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.4.2.2": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.4.2.4": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"SR 2.1": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"SR 2.10": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"SR 2.11": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"SR 2.12": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"SR 2.8": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"SR 2.9": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"SR 5.2": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"A.10.1.1": "https://www.iso.org/standard/54534.html",
		"A.11.1.4": "https://www.iso.org/standard/54534.html",
		"A.11.1.5": "https://www.iso.org/standard/54534.html",
		"A.11.2.1": "https://www.iso.org/standard/54534.html",
		"A.12.4.1": "https://www.iso.org/standard/54534.html",
		"A.12.4.2": "https://www.iso.org/standard/54534.html",
		"A.12.4.3": "https://www.iso.org/standard/54534.html",
		"A.12.4.4": "https://www.iso.org/standard/54534.html",
		"A.12.7.1": "https://www.iso.org/standard/54534.html",
		"A.13.1.1": "https://www.iso.org/standard/54534.html",
		"A.13.1.3": "https://www.iso.org/standard/54534.html",
		"A.13.2.1": "https://www.iso.org/standard/54534.html",
		"A.13.2.3": "https://www.iso.org/standard/54534.html",
		"A.13.2.4": "https://www.iso.org/standard/54534.html",
		"A.6.1.2": "https://www.iso.org/standard/54534.html",
		"A.7.1.1": "https://www.iso.org/standard/54534.html",
		"A.7.1.2": "https://www.iso.org/standard/54534.html",
		"A.7.3.1": "https://www.iso.org/standard/54534.html",
		"A.8.2.2": "https://www.iso.org/standard/54534.html",
		"A.8.2.3": "https://www.iso.org/standard/54534.html",
		"A.9.1.1": "https://www.iso.org/standard/54534.html",
		"A.9.1.2": "https://www.iso.org/standard/54534.html",
		"A.9.2.3": "https://www.iso.org/standard/54534.html",
		"A.9.4.1": "https://www.iso.org/standard/54534.html",
		"A.9.4.4": "https://www.iso.org/standard/54534.html",
		"A.9.4.5": "https://www.iso.org/standard/54534.html",
		"CIP-003-8 R4.2": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"CIP-003-8 R6": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"CIP-007-3 R4": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"CIP-007-3 R4.1": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"CIP-007-3 R4.2": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"CM-6(a)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"PR.AC-4": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"PR.DS-5": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"PR.PT-1": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"SRG-OS-000256-GPOS-00097": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000257-GPOS-00098": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000258-GPOS-00099": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000278-GPOS-00108": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"BP28(R51)": "http://www.ssi.gouv.fr/administration/bonnes-pratiques/",
		"7": "https://www.cisecurity.org/controls/",
		"8": "https://www.cisecurity.org/controls/",
		"5.10.1.3": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
		"BAI01.06": "https://www.isaca.org/resources/cobit",
		"BAI02.01": "https://www.isaca.org/resources/cobit",
		"DSS01.03": "https://www.isaca.org/resources/cobit",
		"DSS03.05": "https://www.isaca.org/resources/cobit",
		"DSS04.07": "https://www.isaca.org/resources/cobit",
		"DSS05.02": "https://www.isaca.org/resources/cobit",
		"DSS05.03": "https://www.isaca.org/resources/cobit",
		"DSS05.05": "https://www.isaca.org/resources/cobit",
		"DSS06.06": "https://www.isaca.org/resources/cobit",
		"CCI-002696": "https://public.cyber.mil/stigs/cci/",
		"CCI-002699": "https://public.cyber.mil/stigs/cci/",
		"CCI-001744": "https://public.cyber.mil/stigs/cci/",
		"SR 4.1": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"SR 6.2": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"A.14.2.7": "https://www.iso.org/standard/54534.html",
		"A.15.2.1": "https://www.iso.org/standard/54534.html",
		"DE.CM-1": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"DE.CM-7": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"PR.DS-1": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"PR.IP-3": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"SRG-OS-000363-GPOS-00150": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000445-GPOS-00199": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"CCI-002702": "https://public.cyber.mil/stigs/cci/",
		"SRG-OS-000446-GPOS-00200": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000447-GPOS-00201": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"CIP-007-3 R5.1": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"SC-13": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"SC-12(2)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"SC-12(3)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"SRG-OS-000423-GPOS-00187": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000426-GPOS-00190": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"164.308(a)(4)(i)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"164.308(b)(1)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"164.308(b)(3)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"164.312(e)(1)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"164.312(e)(2)(ii)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"CIP-007-3 R7.1": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"AC-17(a)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"AC-17(2)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"MA-4(6)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"FCS_COP.1(1)": "https://www.niap-ccevs.org/Profile/PP.cfm",
		"FCS_COP.1(2)": "https://www.niap-ccevs.org/Profile/PP.cfm",
		"FCS_COP.1(3)": "https://www.niap-ccevs.org/Profile/PP.cfm",
		"FCS_COP.1(4)": "https://www.niap-ccevs.org/Profile/PP.cfm",
		"FCS_CKM.1": "https://www.niap-ccevs.org/Profile/PP.cfm",
		"FCS_CKM.2": "https://www.niap-ccevs.org/Profile/PP.cfm",
		"FCS_TLSC_EXT.1": "https://www.niap-ccevs.org/Profile/PP.cfm",
		"SRG-OS-000396-GPOS-00176": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000393-GPOS-00173": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000394-GPOS-00174": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000120-GPOS-00061": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"FCS_IPSEC_EXT.1.4": "https://www.niap-ccevs.org/Profile/PP.cfm",
		"FCS_IPSEC_EXT.1.6": "https://www.niap-ccevs.org/Profile/PP.cfm",
		"SRG-OS-000033-GPOS-00014": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"CCI-001453": "https://public.cyber.mil/stigs/cci/",
		"SRG-OS-000250-GPOS-00093": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"FCS_SSH_EXT.1": "https://www.niap-ccevs.org/Profile/PP.cfm",
		"FCS_SSHS_EXT.1": "https://www.niap-ccevs.org/Profile/PP.cfm",
		"FCS_SSHC_EXT.1": "https://www.niap-ccevs.org/Profile/PP.cfm",
		"APO13.01": "https://www.isaca.org/resources/cobit",
		"DSS01.05": "https://www.isaca.org/resources/cobit",
		"CCI-001263": "https://public.cyber.mil/stigs/cci/",
		"4.3.3.4": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"SR 3.5": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"SR 4.3": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"SR 5.1": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"SR 5.3": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"SR 7.1": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"PR.AC-5": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"PR.PT-4": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"Req-11.4": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"164.308(a)(1)(ii)(B)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"164.308(a)(5)(ii)(A)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"5.5.5": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
		"DSS05.10": "https://www.isaca.org/resources/cobit",
		"DSS06.10": "https://www.isaca.org/resources/cobit",
		"3.1.10": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
		"CCI-000057": "https://public.cyber.mil/stigs/cci/",
		"4.3.3.6.1": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.3.3.6.2": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.3.3.6.3": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.3.3.6.4": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.3.3.6.5": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.3.3.6.6": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.3.3.6.7": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.3.3.6.8": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.3.3.6.9": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"SR 1.1": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"SR 1.10": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"SR 1.2": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"SR 1.5": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"SR 1.7": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"SR 1.8": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"SR 1.9": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"A.18.1.4": "https://www.iso.org/standard/54534.html",
		"A.9.2.1": "https://www.iso.org/standard/54534.html",
		"A.9.2.4": "https://www.iso.org/standard/54534.html",
		"A.9.3.1": "https://www.iso.org/standard/54534.html",
		"A.9.4.2": "https://www.iso.org/standard/54534.html",
		"A.9.4.3": "https://www.iso.org/standard/54534.html",
		"AC-11(a)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"PR.AC-7": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"FMT_MOF_EXT.1": "https://www.niap-ccevs.org/Profile/PP.cfm",
		"Req-8.1.8": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"SRG-OS-000029-GPOS-00010": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"CCI-000060": "https://public.cyber.mil/stigs/cci/",
		"SRG-OS-000031-GPOS-00012": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"CCI-000056": "https://public.cyber.mil/stigs/cci/",
		"CCI-000058": "https://public.cyber.mil/stigs/cci/",
		"SRG-OS-000028-GPOS-00009": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000030-GPOS-00011": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"AC-11(1)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"AC-11(1).1": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"BP28(R15)": "http://www.ssi.gouv.fr/administration/bonnes-pratiques/",
		"3.4.8": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
		"CM-5(3)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"SC-12": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"SA-12": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"SA-12(10)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"CM-11(a)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"CM-11(b)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"FPT_TUD_EXT.1": "https://www.niap-ccevs.org/Profile/PP.cfm",
		"FPT_TUD_EXT.2": "https://www.niap-ccevs.org/Profile/PP.cfm",
		"Req-6.2": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"SRG-OS-000366-GPOS-00153": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"BP28(R08)": "http://www.ssi.gouv.fr/administration/bonnes-pratiques/",
		"20": "https://www.cisecurity.org/controls/",
		"4": "https://www.cisecurity.org/controls/",
		"APO12.01": "https://www.isaca.org/resources/cobit",
		"APO12.02": "https://www.isaca.org/resources/cobit",
		"APO12.03": "https://www.isaca.org/resources/cobit",
		"APO12.04": "https://www.isaca.org/resources/cobit",
		"BAI03.10": "https://www.isaca.org/resources/cobit",
		"DSS05.01": "https://www.isaca.org/resources/cobit",
		"CCI-001227": "https://public.cyber.mil/stigs/cci/",
		"4.2.3": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.2.3.12": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.2.3.7": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.2.3.9": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"A.12.6.1": "https://www.iso.org/standard/54534.html",
		"A.16.1.3": "https://www.iso.org/standard/54534.html",
		"A.18.2.2": "https://www.iso.org/standard/54534.html",
		"A.18.2.3": "https://www.iso.org/standard/54534.html",
		"SI-2(5)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"SI-2(c)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"ID.RA-1": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"PR.IP-12": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"BP28(R5)": "http://www.ssi.gouv.fr/administration/bonnes-pratiques/",
		"CCI-000213": "https://public.cyber.mil/stigs/cci/",
		"164.308(a)(7)(i)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"164.308(a)(7)(ii)(A)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"164.310(a)(1)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"164.310(a)(2)(i)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"164.310(a)(2)(ii)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"164.310(a)(2)(iii)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"164.310(b)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"164.310(c)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"164.310(d)(1)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"164.310(d)(2)(iii)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"AC-3": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"FIA_UAU.1": "https://www.niap-ccevs.org/Profile/PP.cfm",
		"FIA_AFL.1": "https://www.niap-ccevs.org/Profile/PP.cfm",
		"5.5.2": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
		"AC-9(1)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"Req-10.2.4": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"BP28(R18)": "http://www.ssi.gouv.fr/administration/bonnes-pratiques/",
		"5.6.2.1.1": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
		"DSS06.03": "https://www.isaca.org/resources/cobit",
		"3.5.8": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
		"CCI-000200": "https://public.cyber.mil/stigs/cci/",
		"4.3.3.2.2": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.3.3.5.1": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.3.3.5.2": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.3.3.7.2": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.3.3.7.4": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"SR 1.3": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"SR 1.4": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"A.9.2.2": "https://www.iso.org/standard/54534.html",
		"A.9.2.6": "https://www.iso.org/standard/54534.html",
		"IA-5(f)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"IA-5(1)(e)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"PR.AC-1": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"PR.AC-6": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"Req-8.2.5": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"SRG-OS-000077-GPOS-00045": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"5.5.3": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
		"3.1.8": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
		"CCI-000044": "https://public.cyber.mil/stigs/cci/",
		"CCI-002236": "https://public.cyber.mil/stigs/cci/",
		"CCI-002237": "https://public.cyber.mil/stigs/cci/",
		"CCI-002238": "https://public.cyber.mil/stigs/cci/",
		"AC-7(a)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"Req-8.1.6": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"SRG-OS-000329-GPOS-00128": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000021-GPOS-00005": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"AC-7(b)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"Req-8.1.7": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"CCI-000194": "https://public.cyber.mil/stigs/cci/",
		"IA-5(c)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"IA-5(1)(a)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"IA-5(4)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"Req-8.2.3": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"SRG-OS-000071-GPOS-00039": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"CCI-000193": "https://public.cyber.mil/stigs/cci/",
		"SRG-OS-000070-GPOS-00038": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"CCI-000205": "https://public.cyber.mil/stigs/cci/",
		"SRG-OS-000078-GPOS-00046": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"CCI-000192": "https://public.cyber.mil/stigs/cci/",
		"SRG-OS-000069-GPOS-00037": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"5.6.2.2": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
		"3.13.11": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
		"CCI-000196": "https://public.cyber.mil/stigs/cci/",
		"IA-5(1)(c)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"Req-8.2.1": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"SRG-OS-000073-GPOS-00041": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"BP28(R32)": "http://www.ssi.gouv.fr/administration/bonnes-pratiques/",
		"CCI-000803": "https://public.cyber.mil/stigs/cci/",
		"CCI-001954": "https://public.cyber.mil/stigs/cci/",
		"CCI-001953": "https://public.cyber.mil/stigs/cci/",
		"SRG-OS-000375-GPOS-00160": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000376-GPOS-00161": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"IA-2(1)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"IA-2(2)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"IA-2(3)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"IA-2(4)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"IA-2(6)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"IA-2(7)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"IA-2(11)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"CCI-000765": "https://public.cyber.mil/stigs/cci/",
		"CCI-000766": "https://public.cyber.mil/stigs/cci/",
		"CCI-000767": "https://public.cyber.mil/stigs/cci/",
		"CCI-000768": "https://public.cyber.mil/stigs/cci/",
		"CCI-000771": "https://public.cyber.mil/stigs/cci/",
		"CCI-000772": "https://public.cyber.mil/stigs/cci/",
		"CCI-000884": "https://public.cyber.mil/stigs/cci/",
		"Req-8.3": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"SRG-OS-000104-GPOS-00051": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000106-GPOS-00053": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000107-GPOS-00054": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000109-GPOS-00056": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000108-GPOS-00055": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000108-GPOS-00057": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000108-GPOS-00058": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"3.5.6": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
		"CCI-000017": "https://public.cyber.mil/stigs/cci/",
		"CCI-000795": "https://public.cyber.mil/stigs/cci/",
		"CIP-004-6 R2.2.2": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"CIP-004-6 R2.2.3": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"CIP-007-3 R.1.3": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"CIP-007-3 R5": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"CIP-007-3 R5.1.1": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"CIP-007-3 R5.1.3": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"CIP-007-3 R5.2.1": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"CIP-007-3 R5.2.3": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"IA-4(e)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"AC-2(3)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"DE.CM-3": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"Req-8.1.4": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"SRG-OS-000118-GPOS-00060": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"CCI-000770": "https://public.cyber.mil/stigs/cci/",
		"CCI-000804": "https://public.cyber.mil/stigs/cci/",
		"Req-8.1.1": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"5.6.2.1": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
		"CCI-000199": "https://public.cyber.mil/stigs/cci/",
		"IA-5(1)(d)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"Req-8.2.4": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"SRG-OS-000076-GPOS-00044": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"3.5.10": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
		"IA-5(h)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"CCI-000764": "https://public.cyber.mil/stigs/cci/",
		"CIP-003-8 R5.1.1": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"CIP-003-8 R5.3": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"CIP-004-6 R2.3": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"CIP-007-3 R5.1.2": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"CIP-007-3 R5.2": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"CIP-007-3 R5.3.1": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"CIP-007-3 R5.3.2": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"CIP-007-3 R5.3.3": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"IA-2": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"Req-8.5.a": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"3.1.1": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
		"3.1.5": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
		"FMT_SMF_EXT.1": "https://www.niap-ccevs.org/Profile/PP.cfm",
		"SRG-OS-000342-GPOS-00133": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"19": "https://www.cisecurity.org/controls/",
		"5.4.1.1": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
		"APO10.01": "https://www.isaca.org/resources/cobit",
		"APO10.03": "https://www.isaca.org/resources/cobit",
		"APO10.04": "https://www.isaca.org/resources/cobit",
		"APO10.05": "https://www.isaca.org/resources/cobit",
		"APO12.06": "https://www.isaca.org/resources/cobit",
		"BAI08.02": "https://www.isaca.org/resources/cobit",
		"DSS01.04": "https://www.isaca.org/resources/cobit",
		"DSS02.02": "https://www.isaca.org/resources/cobit",
		"DSS02.04": "https://www.isaca.org/resources/cobit",
		"DSS02.07": "https://www.isaca.org/resources/cobit",
		"DSS03.01": "https://www.isaca.org/resources/cobit",
		"MEA01.01": "https://www.isaca.org/resources/cobit",
		"MEA01.02": "https://www.isaca.org/resources/cobit",
		"MEA01.03": "https://www.isaca.org/resources/cobit",
		"MEA01.04": "https://www.isaca.org/resources/cobit",
		"MEA01.05": "https://www.isaca.org/resources/cobit",
		"3.3.1": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
		"3.3.2": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
		"3.3.6": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
		"CCI-000126": "https://public.cyber.mil/stigs/cci/",
		"CCI-000130": "https://public.cyber.mil/stigs/cci/",
		"CCI-000131": "https://public.cyber.mil/stigs/cci/",
		"CCI-000132": "https://public.cyber.mil/stigs/cci/",
		"CCI-000133": "https://public.cyber.mil/stigs/cci/",
		"CCI-000134": "https://public.cyber.mil/stigs/cci/",
		"CCI-000135": "https://public.cyber.mil/stigs/cci/",
		"CCI-000154": "https://public.cyber.mil/stigs/cci/",
		"CCI-000158": "https://public.cyber.mil/stigs/cci/",
		"CCI-000172": "https://public.cyber.mil/stigs/cci/",
		"CCI-001464": "https://public.cyber.mil/stigs/cci/",
		"CCI-001487": "https://public.cyber.mil/stigs/cci/",
		"CCI-001814": "https://public.cyber.mil/stigs/cci/",
		"CCI-001875": "https://public.cyber.mil/stigs/cci/",
		"CCI-001876": "https://public.cyber.mil/stigs/cci/",
		"CCI-001877": "https://public.cyber.mil/stigs/cci/",
		"CCI-002884": "https://public.cyber.mil/stigs/cci/",
		"CCI-001878": "https://public.cyber.mil/stigs/cci/",
		"CCI-001879": "https://public.cyber.mil/stigs/cci/",
		"CCI-001880": "https://public.cyber.mil/stigs/cci/",
		"CCI-001881": "https://public.cyber.mil/stigs/cci/",
		"CCI-001882": "https://public.cyber.mil/stigs/cci/",
		"CCI-001889": "https://public.cyber.mil/stigs/cci/",
		"CCI-001914": "https://public.cyber.mil/stigs/cci/",
		"CCI-000169": "https://public.cyber.mil/stigs/cci/",
		"164.308(a)(5)(ii)(C)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"164.310(a)(2)(iv)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"4.2.3.10": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.3.2.6.7": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.3.4.5.6": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.3.4.5.7": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.3.4.5.8": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"SR 1.13": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"SR 2.6": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"SR 6.1": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"A.11.2.6": "https://www.iso.org/standard/54534.html",
		"A.15.2.2": "https://www.iso.org/standard/54534.html",
		"A.16.1.4": "https://www.iso.org/standard/54534.html",
		"A.16.1.5": "https://www.iso.org/standard/54534.html",
		"A.16.1.7": "https://www.iso.org/standard/54534.html",
		"A.6.2.1": "https://www.iso.org/standard/54534.html",
		"A.6.2.2": "https://www.iso.org/standard/54534.html",
		"CIP-004-6 R3.3": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"CIP-007-3 R6.5": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"AC-2(g)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"AU-3": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"AU-10": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"AU-2(d)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"AU-12(c)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"AU-14(1)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"AC-6(9)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"SI-4(23)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"DE.AE-3": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"DE.AE-5": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"ID.SC-4": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"PR.AC-3": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"RS.AN-1": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"RS.AN-4": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"FAU_GEN.1": "https://www.niap-ccevs.org/Profile/PP.cfm",
		"Req-10.1": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"SRG-OS-000062-GPOS-00031": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000037-GPOS-00015": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000038-GPOS-00016": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000039-GPOS-00017": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000040-GPOS-00018": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000041-GPOS-00019": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000042-GPOS-00021": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000051-GPOS-00024": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000054-GPOS-00025": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000122-GPOS-00063": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000254-GPOS-00095": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000255-GPOS-00096": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000337-GPOS-00129": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000348-GPOS-00136": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000349-GPOS-00137": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000350-GPOS-00138": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000351-GPOS-00139": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000352-GPOS-00140": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000353-GPOS-00141": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000354-GPOS-00142": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000358-GPOS-00145": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000365-GPOS-00152": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000392-GPOS-00172": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000475-GPOS-00220": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"AC-17(1)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"IR-5(1)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"Req-10.3": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"SRG-OS-000042-GPOS-00020": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000462-GPOS-00206": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000471-GPOS-00215": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000473-GPOS-00218": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"3.4.3": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
		"CCI-000162": "https://public.cyber.mil/stigs/cci/",
		"CCI-000163": "https://public.cyber.mil/stigs/cci/",
		"CCI-000164": "https://public.cyber.mil/stigs/cci/",
		"164.308(a)(3)(ii)(A)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"164.312(a)(2)(i)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"164.312(d)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"164.312(e)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"Req-10.5.2": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"SRG-OS-000057-GPOS-00027": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000058-GPOS-00028": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000059-GPOS-00029": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"FAU_GEN.1.1.c": "https://www.niap-ccevs.org/Profile/PP.cfm",
		"Req-10.5.5": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"3.1.7": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
		"Req-10.2.7": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"Req-10.2.3": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"AC-2(7)(b)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"Req-10.2.2": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"Req-10.2.5.b": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"SRG-OS-000004-GPOS-00004": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000304-GPOS-00121": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000470-GPOS-00214": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000239-GPOS-00089": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000240-GPOS-00090": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000241-GPOS-00091": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000303-GPOS-00120": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000466-GPOS-00210": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000476-GPOS-00221": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"CCI-000018": "https://public.cyber.mil/stigs/cci/",
		"CCI-001403": "https://public.cyber.mil/stigs/cci/",
		"CCI-001404": "https://public.cyber.mil/stigs/cci/",
		"CCI-001405": "https://public.cyber.mil/stigs/cci/",
		"CCI-001683": "https://public.cyber.mil/stigs/cci/",
		"CCI-001684": "https://public.cyber.mil/stigs/cci/",
		"CCI-001685": "https://public.cyber.mil/stigs/cci/",
		"CCI-001686": "https://public.cyber.mil/stigs/cci/",
		"CCI-002130": "https://public.cyber.mil/stigs/cci/",
		"CCI-002132": "https://public.cyber.mil/stigs/cci/",
		"AC-2(4)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"Req-10.2.5": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"SRG-OS-000274-GPOS-00104": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000275-GPOS-00105": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000276-GPOS-00106": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000277-GPOS-00107": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"CCI-001314": "https://public.cyber.mil/stigs/cci/",
		"CIP-007-3 R2.1": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"CIP-007-3 R2.2": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"CIP-007-3 R2.3": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"AC-6(1)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"AU-9(4)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"Req-10.5.1": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"Req-10.5": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"SRG-OS-000206-GPOS-00084": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000064-GPOS-00033": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000458-GPOS-00203": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000474-GPOS-00219": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000463-GPOS-00207": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000468-GPOS-00212": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"A.15.1.1": "https://www.iso.org/standard/54534.html",
		"PR.MA-2": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"SRG-OS-000467-GPOS-00211": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"Req-10.2.1": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"SRG-OS-000461-GPOS-00205": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000471-GPOS-00216": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000477-GPOS-00222": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"APO08.04": "https://www.isaca.org/resources/cobit",
		"DSS02.05": "https://www.isaca.org/resources/cobit",
		"CCI-002234": "https://public.cyber.mil/stigs/cci/",
		"4.3.4.5.5": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"4.3.4.5.9": "https://www.isa.org/products/isa-62443-2-1-2009-security-for-industrial-automat",
		"SR 3.9": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"A.16.1.1": "https://www.iso.org/standard/54534.html",
		"A.16.1.2": "https://www.iso.org/standard/54534.html",
		"A.6.1.3": "https://www.iso.org/standard/54534.html",
		"DE.AE-2": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"DE.DP-4": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"RS.CO-2": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"SRG-OS-000327-GPOS-00127": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"Req-10.4.2.b": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"CCI-000136": "https://public.cyber.mil/stigs/cci/",
		"164.308(a)(5)(ii)(B)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"164.308(a)(6)(ii)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"164.308(a)(8)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"164.314(a)(2)(i)(C)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"164.314(a)(2)(iii)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"AU-4(1)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"Req-10.5.3": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"SRG-OS-000479-GPOS-00224": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"BAI04.04": "https://www.isaca.org/resources/cobit",
		"CCI-000139": "https://public.cyber.mil/stigs/cci/",
		"CCI-001855": "https://public.cyber.mil/stigs/cci/",
		"164.312(a)(2)(ii)": "https://www.gpo.gov/fdsys/pkg/CFR-2007-title45-vol1/pdf/CFR-2007-title45-vol1-chapA-subchapC.pdf",
		"SR 7.2": "https://www.isa.org/products/ansi-isa-62443-3-3-99-03-03-2013-security-for-indu",
		"A.12.1.3": "https://www.iso.org/standard/54534.html",
		"A.17.2.1": "https://www.iso.org/standard/54534.html",
		"CIP-003-8 R1.3": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"CIP-003-8 R3": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"CIP-003-8 R3.1": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"CIP-003-8 R3.2": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"CIP-003-8 R3.3": "https://www.nerc.com/pa/Stand/Standard%20Purpose%20Statement%20DL/US_Standard_One-Stop-Shop.xlsx",
		"IA-5(1)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"AU-5(a)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"AU-5(2)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"PR.DS-4": "https://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04162018.pdf",
		"Req-10.7.a": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"SRG-OS-000046-GPOS-00022": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"SRG-OS-000343-GPOS-00134": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"CCI-000140": "https://public.cyber.mil/stigs/cci/",
		"CCI-001343": "https://public.cyber.mil/stigs/cci/",
		"AU-5(b)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"AU-5(1)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"AU-5(4)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"Req-10.7": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"AU-11": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"SRG-OS-000047-GPOS-00023": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os",
		"5.5.2.2": "https://www.fbi.gov/file-repository/cjis-security-policy-v5_5_20160601-2-1.pdf",
		"3.4.5": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-171.pdf",
		"CCI-000225": "https://public.cyber.mil/stigs/cci/",
		"Req-7.1": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"BP28(R46)": "http://www.ssi.gouv.fr/administration/bonnes-pratiques/",
		"BP28(R36)": "http://www.ssi.gouv.fr/administration/bonnes-pratiques/",
		"BP28(R43)": "http://www.ssi.gouv.fr/administration/bonnes-pratiques/",
		"NT12(R18)": "http://www.ssi.gouv.fr/administration/bonnes-pratiques/",
		"CCI-001130": "https://public.cyber.mil/stigs/cci/",
		"CCI-001131": "https://public.cyber.mil/stigs/cci/",
		"Req-4.1": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"Req-8.7.c": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"CCI-002223": "https://public.cyber.mil/stigs/cci/",
		"CCI-000160": "https://public.cyber.mil/stigs/cci/",
		"CCI-001891": "https://public.cyber.mil/stigs/cci/",
		"AU-8(1)(a)": "http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-53r4.pdf",
		"Req-10.4.3": "https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf",
		"SRG-OS-000105-GPOS-00052": "https://public.cyber.mil/stigs/downloads/?_dl_facet_stigs=operating-systems%2Cgeneral-purpose-os"
	},
	"identifiers": {
		"CCE-90841-8": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-90840-0": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-90843-4": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83438-2": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83437-4": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83451-5": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83450-7": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83449-9": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83446-5": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83452-3": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83445-7": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-88837-0": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-87295-2": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-87755-5": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-86510-5": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-89302-4": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-88733-1": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-85971-0": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83457-2": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83464-8": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-84180-9": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-84185-8": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-89732-2": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83560-3": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83584-3": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83587-6": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83588-4": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83566-0": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83570-2": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83579-3": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83568-6": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-88865-1": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-90590-1": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-85946-2": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83581-9": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83595-9": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-86280-5": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-87907-2": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-89122-6": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-89151-5": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83627-0": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83628-8": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83606-4": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83618-9": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83613-0": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83611-4": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83648-6": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-90829-3": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83651-0": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83716-1": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83721-1": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83735-1": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83706-2": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83713-8": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83729-4": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83722-9": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83723-7": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83712-0": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83714-6": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83725-2": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83726-0": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83720-3": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83830-0": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83812-8": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83832-6": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83822-7": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83829-2": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83831-8": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83821-9": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83817-7": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83833-4": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83814-4": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83808-6": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83807-8": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83811-0": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83754-2": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83756-7": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83758-3": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83757-5": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83755-9": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83786-4": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83800-3": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83801-1": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83796-3": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83794-8": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83792-2": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83802-9": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83803-7": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-90835-0": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83784-9": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83759-1": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83840-9": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83837-5": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83836-7": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83835-9": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83839-1": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83695-7": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83698-1": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83700-5": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83683-3": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83701-3": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83688-2": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83703-9": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83848-2": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83845-8": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83834-2": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83946-4": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83689-0": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83993-6": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-84068-6": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83945-6": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83950-6": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83930-8": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83925-8": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83943-1": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83926-6": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83934-0": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83931-6": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-83941-5": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-84217-9": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-84218-7": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-87681-3": "https://nvd.nist.gov/cce/index.cfm",
		"CCE-89155-6": "https://nvd.nist.gov/cce/index.cfm"
	}
}